(() => {
    var t = {
            41: function(t) {
                t.exports = function() {
                    "use strict";
                    var t = document,
                        e = t.createTextNode.bind(t);

                    function n(t, e, n) {
                        t.style.setProperty(e, n)
                    }

                    function i(t, e) {
                        return t.appendChild(e)
                    }

                    function r(e, n, r, a) {
                        var s = t.createElement("span");
                        return n && (s.className = n), r && (!a && s.setAttribute("data-" + n, r), s.textContent = r), e && i(e, s) || s
                    }

                    function a(t, e) {
                        return t.getAttribute("data-" + e)
                    }

                    function s(e, n) {
                        return e && 0 != e.length ? e.nodeName ? [e] : [].slice.call(e[0].nodeName ? e : (n || t).querySelectorAll(e)) : []
                    }

                    function o(t) {
                        for (var e = []; t--;) e[t] = [];
                        return e
                    }

                    function l(t, e) {
                        t && t.some(e)
                    }

                    function c(t) {
                        return function(e) {
                            return t[e]
                        }
                    }
                    var h = {};

                    function u(t, e, n) {
                        var i = n.indexOf(t);
                        if (-1 == i) n.unshift(t), l(h[t].depends, (function(e) {
                            u(e, t, n)
                        }));
                        else {
                            var r = n.indexOf(e);
                            n.splice(i, 1), n.splice(r, 0, t)
                        }
                        return n
                    }

                    function d(t, e, n, i) {
                        return {
                            by: t,
                            depends: e,
                            key: n,
                            split: i
                        }
                    }

                    function p(t) {
                        return u(t, 0, []).map(c(h))
                    }

                    function f(t) {
                        h[t.by] = t
                    }

                    function m(t, n, a, o, c) {
                        t.normalize();
                        var h = [],
                            u = document.createDocumentFragment();
                        o && h.push(t.previousSibling);
                        var d = [];
                        return s(t.childNodes).some((function(t) {
                            if (!t.tagName || t.hasChildNodes()) {
                                if (t.childNodes && t.childNodes.length) return d.push(t), void h.push.apply(h, m(t, n, a, o, c));
                                var i = t.wholeText || "",
                                    s = i.trim();
                                s.length && (" " === i[0] && d.push(e(" ")), l(s.split(a), (function(t, e) {
                                    e && c && d.push(r(u, "whitespace", " ", c));
                                    var i = r(u, n, t);
                                    h.push(i), d.push(i)
                                })), " " === i[i.length - 1] && d.push(e(" ")))
                            } else d.push(t)
                        })), l(d, (function(t) {
                            i(u, t)
                        })), t.innerHTML = "", i(t, u), h
                    }
                    var g = "words",
                        _ = d(g, 0, "word", (function(t) {
                            return m(t, "word", /\s+/, 0, 1)
                        })),
                        v = "chars",
                        x = d(v, [g], "char", (function(t, e, n) {
                            var i = [];
                            return l(n[g], (function(t, n) {
                                i.push.apply(i, m(t, "char", "", e.whitespace && n))
                            })), i
                        }));

                    function y(t) {
                        var e = (t = t || {}).key;
                        return s(t.target || "[data-splitting]").map((function(i) {
                            var r = i["ðŸŒ"];
                            if (!t.force && r) return r;
                            r = i["ðŸŒ"] = {
                                el: i
                            };
                            var s = p(t.by || a(i, "splitting") || v),
                                o = function(t, e) {
                                    for (var n in e) t[n] = e[n];
                                    return t
                                }({}, t);
                            return l(s, (function(t) {
                                if (t.split) {
                                    var a = t.by,
                                        s = (e ? "-" + e : "") + t.key,
                                        c = t.split(i, o, r);
                                    s && function(t, e, i) {
                                        var r = "--" + e,
                                            a = r + "-index";
                                        l(i, (function(t, e) {
                                            Array.isArray(t) ? l(t, (function(t) {
                                                n(t, a, e)
                                            })) : n(t, a, e)
                                        })), n(t, r + "-total", i.length)
                                    }(i, s, c), r[a] = c, i.classList.add(a)
                                }
                            })), i.classList.add("splitting"), r
                        }))
                    }

                    function M(t, e, n) {
                        var i = s(e.matching || t.children, t),
                            r = {};
                        return l(i, (function(t) {
                            var e = Math.round(t[n]);
                            (r[e] || (r[e] = [])).push(t)
                        })), Object.keys(r).map(Number).sort(S).map(c(r))
                    }

                    function S(t, e) {
                        return t - e
                    }
                    y.html = function(t) {
                        var e = (t = t || {}).target = r();
                        return e.innerHTML = t.content, y(t), e.outerHTML
                    }, y.add = f;
                    var T = d("lines", [g], "line", (function(t, e, n) {
                            return M(t, {
                                matching: n[g]
                            }, "offsetTop")
                        })),
                        E = d("items", 0, "item", (function(t, e) {
                            return s(e.matching || t.children, t)
                        })),
                        b = d("rows", 0, "row", (function(t, e) {
                            return M(t, e, "offsetTop")
                        })),
                        w = d("cols", 0, "col", (function(t, e) {
                            return M(t, e, "offsetLeft")
                        })),
                        A = d("grid", ["rows", "cols"]),
                        R = "layout",
                        C = d(R, 0, 0, (function(t, e) {
                            var o = e.rows = +(e.rows || a(t, "rows") || 1),
                                l = e.columns = +(e.columns || a(t, "columns") || 1);
                            if (e.image = e.image || a(t, "image") || t.currentSrc || t.src, e.image) {
                                var c = s("img", t)[0];
                                e.image = c && (c.currentSrc || c.src)
                            }
                            e.image && n(t, "background-image", "url(" + e.image + ")");
                            for (var h = o * l, u = [], d = r(0, "cell-grid"); h--;) {
                                var p = r(d, "cell");
                                r(p, "cell-inner"), u.push(p)
                            }
                            return i(t, d), u
                        })),
                        P = d("cellRows", [R], "row", (function(t, e, n) {
                            var i = e.rows,
                                r = o(i);
                            return l(n[R], (function(t, e, n) {
                                r[Math.floor(e / (n.length / i))].push(t)
                            })), r
                        })),
                        L = d("cellColumns", [R], "col", (function(t, e, n) {
                            var i = e.columns,
                                r = o(i);
                            return l(n[R], (function(t, e) {
                                r[e % i].push(t)
                            })), r
                        })),
                        U = d("cells", ["cellRows", "cellColumns"], "cell", (function(t, e, n) {
                            return n[R]
                        }));
                    return f(_), f(x), f(T), f(E), f(b), f(w), f(A), f(C), f(P), f(L), f(U), y
                }()
            },
            686: () => {}
        },
        e = {};

    function n(i) {
        var r = e[i];
        if (void 0 !== r) return r.exports;
        var a = e[i] = {
            exports: {}
        };
        return t[i].call(a.exports, a, a.exports, n), a.exports
    }
    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {
            a: e
        }), e
    }, n.d = (t, e) => {
        for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
            enumerable: !0,
            get: e[i]
        })
    }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), (() => {
        "use strict";
        const t = .5 * (Math.sqrt(3) - 1),
            e = (3 - Math.sqrt(3)) / 6,
            i = 1 / 6,
            r = (Math.sqrt(5), Math.sqrt(5), t => 0 | Math.floor(t)),
            a = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]),
            s = new Float64Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);

        function o(t = Math.random) {
            const e = l(t),
                n = new Float64Array(e).map((t => s[t % 12 * 3])),
                a = new Float64Array(e).map((t => s[t % 12 * 3 + 1])),
                o = new Float64Array(e).map((t => s[t % 12 * 3 + 2]));
            return function(t, s, l) {
                let c, h, u, d;
                const p = .3333333333333333 * (t + s + l),
                    f = r(t + p),
                    m = r(s + p),
                    g = r(l + p),
                    _ = (f + m + g) * i,
                    v = t - (f - _),
                    x = s - (m - _),
                    y = l - (g - _);
                let M, S, T, E, b, w;
                v >= x ? x >= y ? (M = 1, S = 0, T = 0, E = 1, b = 1, w = 0) : v >= y ? (M = 1, S = 0, T = 0, E = 1, b = 0, w = 1) : (M = 0, S = 0, T = 1, E = 1, b = 0, w = 1) : x < y ? (M = 0, S = 0, T = 1, E = 0, b = 1, w = 1) : v < y ? (M = 0, S = 1, T = 0, E = 0, b = 1, w = 1) : (M = 0, S = 1, T = 0, E = 1, b = 1, w = 0);
                const A = v - M + i,
                    R = x - S + i,
                    C = y - T + i,
                    P = v - E + 2 * i,
                    L = x - b + 2 * i,
                    U = y - w + 2 * i,
                    D = v - 1 + .5,
                    I = x - 1 + .5,
                    N = y - 1 + .5,
                    O = 255 & f,
                    F = 255 & m,
                    z = 255 & g;
                let B = .6 - v * v - x * x - y * y;
                if (B < 0) c = 0;
                else {
                    const t = O + e[F + e[z]];
                    B *= B, c = B * B * (n[t] * v + a[t] * x + o[t] * y)
                }
                let k = .6 - A * A - R * R - C * C;
                if (k < 0) h = 0;
                else {
                    const t = O + M + e[F + S + e[z + T]];
                    k *= k, h = k * k * (n[t] * A + a[t] * R + o[t] * C)
                }
                let H = .6 - P * P - L * L - U * U;
                if (H < 0) u = 0;
                else {
                    const t = O + E + e[F + b + e[z + w]];
                    H *= H, u = H * H * (n[t] * P + a[t] * L + o[t] * U)
                }
                let V = .6 - D * D - I * I - N * N;
                if (V < 0) d = 0;
                else {
                    const t = O + 1 + e[F + 1 + e[z + 1]];
                    V *= V, d = V * V * (n[t] * D + a[t] * I + o[t] * N)
                }
                return 32 * (c + h + u + d)
            }
        }

        function l(t) {
            const e = new Uint8Array(512);
            for (let t = 0; t < 256; t++) e[t] = t;
            for (let n = 0; n < 255; n++) {
                const i = n + ~~(t() * (256 - n)),
                    r = e[n];
                e[n] = e[i], e[i] = r
            }
            for (let t = 256; t < 512; t++) e[t] = e[t - 256];
            return e
        }
        class c {
            constructor(t) {
                this.element = t, this.cells = [], this.cols = [], this.noise = o(), this.frequency = .2, this.frequencyGroup = .05, this.threshold = .9, this.colsNum = 0, this.speed = 400, this.offset = 0, this.showCount = 0, this.showLevel = 0, this.maxLevel = 1, this.buildGrid()
            }
            buildGrid() {
                this.colsNum = 30;
                for (let t = 0; t < this.colsNum; t++) {
                    const e = document.createElement("div");
                    e.classList.add("col"), e.style.setProperty("flex", 2 * Math.random() + .5), this.element.appendChild(e), this.cols.push(e);
                    const n = Math.ceil(25 * Math.random()) + 50;
                    for (let i = 0; i < n; i++) {
                        const n = document.createElement("div"),
                            r = this.noise(t * this.frequency, i * this.frequency, this.offset) * (this.noise(t * this.frequencyGroup, i * this.frequencyGroup, this.offset) > .2 ? 0 : 1),
                            a = this.scale(r, -1, 1, 0, 1);
                        n.classList.add("cell"), n.style.setProperty("flex", .5 * Math.random()), e.appendChild(n), this.cells.push({
                            show: !1,
                            index: i,
                            element: n,
                            glitchTimeout: 0,
                            delayTimeout: 0,
                            delay: 10 * (i + 1) * t,
                            count: 0,
                            i: t,
                            j: i,
                            value: a,
                            showValue: a
                        })
                    }
                }
            }
            playGrid() {
                this.maxLevel <= 1 && (this.cols.map((t => {
                    t.style.setProperty("flex", 2 * Math.random() + .5), Math.random() > .8 && t.style.setProperty("flex", 0)
                })), this.cells.map((t => {
                    const e = this.noise(t.i * this.frequency, t.j * this.frequency, this.offset) * (this.noise(t.i * this.frequencyGroup, t.j * this.frequencyGroup, this.offset) > .5 ? 0 : 1),
                        n = this.scale(e, -1, 1, 0, 1);
                    t.value = n, Math.random() > .9 ? t.value = n : t.value = 0, t.show = !1, t.element.style.setProperty("flex", .5 * Math.random())
                })), this.showLevel = 0), this.maxLevel += .2, this.glitch()
            }
            updateGrid() {
                this.cols.map((t => {
                    t.style.setProperty("flex", 2 * Math.random() + .5), Math.random() > .8 && t.style.setProperty("flex", 0)
                })), this.cells.map((t => {
                    const e = this.noise(t.i * this.frequency, t.j * this.frequency, this.offset) * (this.noise(t.i * this.frequencyGroup, t.j * this.frequencyGroup, this.offset) > .2 ? 0 : 1),
                        n = this.scale(e, -1, 1, 0, 1);
                    t.value = n, n > this.threshold ? t.show = !0 : t.show = !1, t.element.style.setProperty("flex", .5 * Math.random())
                }))
            }
            glitch() {
                this.offset = 10 * Math.random(), this.showCount = 0, this.cells.map((t => {
                    this.showCount++, t.delayTimeout > 0 && clearTimeout(t.delayTimeout), t.glitchTimeout > 0 && clearTimeout(t.glitchTimeout), t.delayTimeout = setTimeout((() => {
                        this.updateCell(t)
                    }), t.value - this.threshold)
                }))
            }
            updateCell(t) {
                if (t.count < this.maxLevel) {
                    t.count = this.maxLevel, this.offset += .01;
                    const e = t.value * this.maxLevel > this.threshold;
                    t.element.style.setProperty("visibility", e ? "visible" : "hidden"), t.glitchTimeout = setTimeout((() => {
                        this.updateCell(t)
                    }), this.speed + 100 * (e - this.threshold))
                } else this.showCount--, t.count = 0, t.show = !1, t.element.style.setProperty("visibility", "hidden"), this.showCount <= 0 && (this.showLevel = 0, this.maxLevel = 1)
            }
            stop() {
                this.cells.map((t => {
                    clearTimeout(t.glitchTimeout), clearTimeout(t.delayTimeout)
                }))
            }
            clamp(t, e, n) {
                return Math.min(Math.max(t, e), n)
            }
            scale(t, e, n, i, r) {
                return (t - e) * (r - i) / (n - e) + i
            }
        }
        var h = n(41),
            u = n.n(h);
        class d {
            constructor(t, {
                position: e,
                previousCellPosition: n
            } = {}) {
                this.DOM = {
                    el: null
                }, this.DOM.el = t, this.original = this.DOM.el.innerHTML, this.state = this.original, this.color = this.originalColor = getComputedStyle(document.documentElement).getPropertyValue("--color-text"), this.position = e, this.previousCellPosition = n, this.cache, this.lineTimeout = null, this.characterTimeout = null, this.revealTimeout = null
            }
            set(t) {
                this.state = t, this.DOM.el.innerHTML = this.state
            }
        }
        class p {
            constructor(t) {
                this.DOM = {
                    el: null
                }, this.DOM.el = t, this.cells = [], this.original = this.DOM.el.innerHTML, this.lettersAndSymbols = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "!", "@", "#", "$", "&", "*", "(", ")", "-", "_", "+", "=", "/", "[", "]", "{", "}", ";", ":", "<", ">", ",", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], this.totalChars = 0, this.init()
            }
            init() {
                this.results = u()({
                    target: this.DOM.el,
                    by: "chars",
                    force: !0
                });
                let t = 0;
                for (const e of this.results[0].chars) {
                    const n = new d(e, {
                        position: t,
                        previousCellPosition: 0 === t ? -1 : t - 1
                    });
                    this.cells.push(n), ++t
                }
                this.totalChars = t
            }
            getRandomChar() {
                return this.lettersAndSymbols[Math.floor(Math.random() * this.lettersAndSymbols.length)]
            }
            animate() {
                let t = 0;
                const e = (n, i = 0) => {
                    19 === i ? (n.set(n.original), n.DOM.el.style.opacity = 0, this.revealTimeout = setTimeout((() => {
                        n.DOM.el.style.opacity = 1, n.position === this.totalChars - 1 && this.destroy()
                    }), 300), ++t, t === this.totalChars && (this.isAnimating = !1)) : n.set(this.getRandomChar()), ++i < 20 && (this.characterTimeout = setTimeout((() => e(n, i)), 40))
                };
                for (const t of this.cells) this.lineTimeout = setTimeout((() => e(t)), 30 * (t.position + 1))
            }
            trigger() {
                this.isAnimating || (this.isAnimating = !0, this.animate())
            }
            destroy() {
                this.stop(), this.DOM.el.innerHTML = this.original
            }
            stop() {
                clearTimeout(this.lineTimeout), clearTimeout(this.characterTimeout), clearTimeout(this.revealTimeout), this.DOM.el.classList.remove("words", "lines", "splitting", "chars"), this.DOM.el.style = "", this.cells = [], this.totalChars = 0, this.isAnimating = !1
            }
            randomNumber(t, e) {
                return Math.floor(Math.random() * (e - t + 1)) + t
            }
        }

        function f() {
            return f = Object.assign ? Object.assign.bind() : function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                }
                return t
            }, f.apply(this, arguments)
        }

        function m(t, e, n) {
            return Math.max(t, Math.min(e, n))
        }
        class g {
            advance(t) {
                var e;
                if (!this.isRunning) return;
                let n = !1;
                if (this.lerp) this.value = (i = this.value, r = this.to, (1 - (a = 1 - Math.exp(-60 * this.lerp * t))) * i + a * r), Math.round(this.value) === this.to && (this.value = this.to, n = !0);
                else {
                    this.currentTime += t;
                    const e = m(0, this.currentTime / this.duration, 1);
                    n = e >= 1;
                    const i = n ? 1 : this.easing(e);
                    this.value = this.from + (this.to - this.from) * i
                }
                var i, r, a;
                null == (e = this.onUpdate) || e.call(this, this.value, {
                    completed: n
                }), n && this.stop()
            }
            stop() {
                this.isRunning = !1
            }
            fromTo(t, e, {
                lerp: n = .1,
                duration: i = 1,
                easing: r = (t => t),
                onUpdate: a
            }) {
                this.from = this.value = t, this.to = e, this.lerp = n, this.duration = i, this.easing = r, this.currentTime = 0, this.isRunning = !0, this.onUpdate = a
            }
        }

        function _(t, e) {
            let n;
            return function() {
                let i = arguments,
                    r = this;
                clearTimeout(n), n = setTimeout((function() {
                    t.apply(r, i)
                }), e)
            }
        }
        class v {
            constructor(t, e) {
                this.onWindowResize = () => {
                    this.width = window.innerWidth, this.height = window.innerHeight
                }, this.onWrapperResize = () => {
                    this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight
                }, this.onContentResize = () => {
                    const t = this.wrapper === window ? document.documentElement : this.wrapper;
                    this.scrollHeight = t.scrollHeight, this.scrollWidth = t.scrollWidth
                }, this.wrapper = t, this.content = e, this.wrapper === window ? (window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize()) : (this.wrapperResizeObserver = new ResizeObserver(_(this.onWrapperResize, 100)), this.wrapperResizeObserver.observe(this.wrapper), this.onWrapperResize()), this.contentResizeObserver = new ResizeObserver(_(this.onContentResize, 100)), this.contentResizeObserver.observe(this.content), this.onContentResize()
            }
            destroy() {
                var t, e;
                window.removeEventListener("resize", this.onWindowResize, !1), null == (t = this.wrapperResizeObserver) || t.disconnect(), null == (e = this.contentResizeObserver) || e.disconnect()
            }
            get limit() {
                return {
                    x: this.scrollWidth - this.width,
                    y: this.scrollHeight - this.height
                }
            }
        }
        let x = () => ({
            events: {},
            emit(t, ...e) {
                let n = this.events[t] || [];
                for (let t = 0, i = n.length; t < i; t++) n[t](...e)
            },
            on(t, e) {
                var n;
                return (null == (n = this.events[t]) ? void 0 : n.push(e)) || (this.events[t] = [e]), () => {
                    var n;
                    this.events[t] = null == (n = this.events[t]) ? void 0 : n.filter((t => e !== t))
                }
            }
        });
        class y {
            constructor(t, {
                wheelMultiplier: e = 1,
                touchMultiplier: n = 2,
                normalizeWheel: i = !1
            }) {
                this.onTouchStart = t => {
                    const {
                        clientX: e,
                        clientY: n
                    } = t.targetTouches ? t.targetTouches[0] : t;
                    this.touchStart.x = e, this.touchStart.y = n, this.lastDelta = {
                        x: 0,
                        y: 0
                    }
                }, this.onTouchMove = t => {
                    const {
                        clientX: e,
                        clientY: n
                    } = t.targetTouches ? t.targetTouches[0] : t, i = -(e - this.touchStart.x) * this.touchMultiplier, r = -(n - this.touchStart.y) * this.touchMultiplier;
                    this.touchStart.x = e, this.touchStart.y = n, this.lastDelta = {
                        x: i,
                        y: r
                    }, this.emitter.emit("scroll", {
                        type: "touch",
                        deltaX: i,
                        deltaY: r,
                        event: t
                    })
                }, this.onTouchEnd = t => {
                    this.emitter.emit("scroll", {
                        type: "touch",
                        inertia: !0,
                        deltaX: this.lastDelta.x,
                        deltaY: this.lastDelta.y,
                        event: t
                    })
                }, this.onWheel = t => {
                    let {
                        deltaX: e,
                        deltaY: n
                    } = t;
                    this.normalizeWheel && (e = m(-100, e, 100), n = m(-100, n, 100)), e *= this.wheelMultiplier, n *= this.wheelMultiplier, this.emitter.emit("scroll", {
                        type: "wheel",
                        deltaX: e,
                        deltaY: n,
                        event: t
                    })
                }, this.element = t, this.wheelMultiplier = e, this.touchMultiplier = n, this.normalizeWheel = i, this.touchStart = {
                    x: null,
                    y: null
                }, this.emitter = x(), this.element.addEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.element.addEventListener("touchstart", this.onTouchStart, {
                    passive: !1
                }), this.element.addEventListener("touchmove", this.onTouchMove, {
                    passive: !1
                }), this.element.addEventListener("touchend", this.onTouchEnd, {
                    passive: !1
                })
            }
            on(t, e) {
                return this.emitter.on(t, e)
            }
            destroy() {
                this.emitter.events = {}, this.element.removeEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.element.removeEventListener("touchstart", this.onTouchStart, {
                    passive: !1
                }), this.element.removeEventListener("touchmove", this.onTouchMove, {
                    passive: !1
                }), this.element.removeEventListener("touchend", this.onTouchEnd, {
                    passive: !1
                })
            }
        }
        class M {
            constructor({
                direction: t,
                gestureDirection: e,
                mouseMultiplier: n,
                smooth: i,
                wrapper: r = window,
                content: a = document.documentElement,
                wheelEventsTarget: s = r,
                smoothWheel: o = null == i || i,
                smoothTouch: l = !1,
                syncTouch: c = !1,
                syncTouchLerp: h = .1,
                touchInertiaMultiplier: u = 35,
                duration: d,
                easing: p = (t => Math.min(1, 1.001 - Math.pow(2, -10 * t))),
                lerp: m = (d ? null : .1),
                infinite: _ = !1,
                orientation: M = (null != t ? t : "vertical"),
                gestureOrientation: S = (null != e ? e : "vertical"),
                touchMultiplier: T = 1,
                wheelMultiplier: E = (null != n ? n : 1),
                normalizeWheel: b = !1
            } = {}) {
                this.onVirtualScroll = ({
                    type: t,
                    inertia: e,
                    deltaX: n,
                    deltaY: i,
                    event: r
                }) => {
                    if (r.ctrlKey) return;
                    const a = "touch" === t,
                        s = "wheel" === t;
                    if ("vertical" === this.options.gestureOrientation && 0 === i || "horizontal" === this.options.gestureOrientation && 0 === n || a && "vertical" === this.options.gestureOrientation && 0 === this.scroll && !this.options.infinite && i <= 0) return;
                    if (r.composedPath().find((t => null == t || null == t.hasAttribute ? void 0 : t.hasAttribute("data-lenis-prevent")))) return;
                    if (this.isStopped || this.isLocked) return void r.preventDefault();
                    if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && a || this.options.smoothWheel && s, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
                    r.preventDefault();
                    let o = i;
                    "both" === this.options.gestureOrientation ? o = Math.abs(i) > Math.abs(n) ? i : n : "horizontal" === this.options.gestureOrientation && (o = n);
                    const l = a && this.options.syncTouch,
                        c = a && e && Math.abs(o) > 1;
                    c && (o = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + o, f({
                        programmatic: !1
                    }, l && {
                        lerp: c ? this.syncTouchLerp : .4
                    }))
                }, this.onScroll = () => {
                    if (!this.isScrolling) {
                        const t = this.animatedScroll;
                        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit()
                    }
                }, t && console.warn("Lenis: `direction` option is deprecated, use `orientation` instead"), e && console.warn("Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead"), n && console.warn("Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead"), i && console.warn("Lenis: `smooth` option is deprecated, use `smoothWheel` instead"), window.lenisVersion = "1.0.13", r !== document.documentElement && r !== document.body || (r = window), this.options = {
                    wrapper: r,
                    content: a,
                    wheelEventsTarget: s,
                    smoothWheel: o,
                    smoothTouch: l,
                    syncTouch: c,
                    syncTouchLerp: h,
                    touchInertiaMultiplier: u,
                    duration: d,
                    easing: p,
                    lerp: m,
                    infinite: _,
                    gestureOrientation: S,
                    orientation: M,
                    touchMultiplier: T,
                    wheelMultiplier: E,
                    normalizeWheel: b
                }, this.dimensions = new v(r, a), this.rootElement.classList.add("lenis"), this.velocity = 0, this.isStopped = !1, this.isSmooth = o || l, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.animate = new g, this.emitter = x(), this.options.wrapper.addEventListener("scroll", this.onScroll, {
                    passive: !1
                }), this.virtualScroll = new y(s, {
                    touchMultiplier: T,
                    wheelMultiplier: E,
                    normalizeWheel: b
                }), this.virtualScroll.on("scroll", this.onVirtualScroll)
            }
            destroy() {
                this.emitter.events = {}, this.options.wrapper.removeEventListener("scroll", this.onScroll, {
                    passive: !1
                }), this.virtualScroll.destroy(), this.rootElement.classList.remove("lenis"), this.rootElement.classList.remove("lenis-smooth"), this.rootElement.classList.remove("lenis-scrolling"), this.rootElement.classList.remove("lenis-stopped")
            }
            on(t, e) {
                return this.emitter.on(t, e)
            }
            off(t, e) {
                var n;
                this.emitter.events[t] = null == (n = this.emitter.events[t]) ? void 0 : n.filter((t => e !== t))
            }
            setScroll(t) {
                this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
            }
            emit() {
                this.emitter.emit("scroll", this)
            }
            reset() {
                this.isLocked = !1, this.isScrolling = !1, this.velocity = 0, this.animate.stop()
            }
            start() {
                this.isStopped = !1, this.reset()
            }
            stop() {
                this.isStopped = !0, this.animate.stop(), this.reset()
            }
            raf(t) {
                const e = t - (this.time || t);
                this.time = t, this.animate.advance(.001 * e)
            }
            scrollTo(t, {
                offset: e = 0,
                immediate: n = !1,
                lock: i = !1,
                duration: r = this.options.duration,
                easing: a = this.options.easing,
                lerp: s = !r && this.options.lerp,
                onComplete: o = null,
                force: l = !1,
                programmatic: c = !0
            } = {}) {
                if (!this.isStopped || l) {
                    if (["top", "left", "start"].includes(t)) t = 0;
                    else if (["bottom", "right", "end"].includes(t)) t = this.limit;
                    else {
                        var h;
                        let n;
                        if ("string" == typeof t ? n = document.querySelector(t) : null != (h = t) && h.nodeType && (n = t), n) {
                            if (this.options.wrapper !== window) {
                                const t = this.options.wrapper.getBoundingClientRect();
                                e -= this.isHorizontal ? t.left : t.top
                            }
                            const i = n.getBoundingClientRect();
                            t = (this.isHorizontal ? i.left : i.top) + this.animatedScroll
                        }
                    }
                    if ("number" == typeof t) {
                        if (t += e, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = m(0, t, this.limit), n) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), this.emit(), void(null == o || o());
                        if (!c) {
                            if (t === this.targetScroll) return;
                            this.targetScroll = t
                        }
                        this.animate.fromTo(this.animatedScroll, t, {
                            duration: r,
                            easing: a,
                            lerp: s,
                            onUpdate: (t, {
                                completed: e
                            }) => {
                                i && (this.isLocked = !0), this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e && (i && (this.isLocked = !1), requestAnimationFrame((() => {
                                    this.isScrolling = !1
                                })), this.velocity = 0, null == o || o()), this.emit()
                            }
                        })
                    }
                }
            }
            get rootElement() {
                return this.options.wrapper === window ? this.options.content : this.options.wrapper
            }
            get limit() {
                return this.isHorizontal ? this.dimensions.limit.x : this.dimensions.limit.y
            }
            get isHorizontal() {
                return "horizontal" === this.options.orientation
            }
            get actualScroll() {
                return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
            }
            get scroll() {
                return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;
                var t
            }
            get progress() {
                return 0 === this.limit ? 1 : this.scroll / this.limit
            }
            get isSmooth() {
                return this.__isSmooth
            }
            set isSmooth(t) {
                this.__isSmooth !== t && (this.rootElement.classList.toggle("lenis-smooth", t), this.__isSmooth = t)
            }
            get isScrolling() {
                return this.__isScrolling
            }
            set isScrolling(t) {
                this.__isScrolling !== t && (this.rootElement.classList.toggle("lenis-scrolling", t), this.__isScrolling = t)
            }
            get isStopped() {
                return this.__isStopped
            }
            set isStopped(t) {
                this.__isStopped !== t && (this.rootElement.classList.toggle("lenis-stopped", t), this.__isStopped = t)
            }
        }
        const S = "undefined" != typeof window;
        S || console.warn("Tempus can be used in client side only");
        var T = S && new class {
            constructor() {
                this.raf = t => {
                    requestAnimationFrame(this.raf);
                    const e = t - this.now;
                    this.now = t;
                    for (let n = 0; n < this.callbacks.length; n++) this.callbacks[n].callback(t, e)
                }, this.callbacks = [], this.now = performance.now(), requestAnimationFrame(this.raf)
            }
            add(t, e = 0) {
                return this.callbacks.push({
                    callback: t,
                    priority: e
                }), this.callbacks.sort(((t, e) => t.priority - e.priority)), () => this.remove(t)
            }
            remove(t) {
                this.callbacks = this.callbacks.filter((({
                    callback: e
                }) => t !== e))
            }
        };

        function E(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function b(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        var w, A, R, C, P, L, U, D, I, N, O, F = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            z = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            B = 1e8,
            k = 1e-8,
            H = 2 * Math.PI,
            V = H / 4,
            G = 0,
            W = Math.sqrt,
            X = Math.cos,
            q = Math.sin,
            j = function(t) {
                return "string" == typeof t
            },
            Y = function(t) {
                return "function" == typeof t
            },
            K = function(t) {
                return "number" == typeof t
            },
            Z = function(t) {
                return void 0 === t
            },
            J = function(t) {
                return "object" == typeof t
            },
            Q = function(t) {
                return !1 !== t
            },
            $ = function() {
                return "undefined" != typeof window
            },
            tt = function(t) {
                return Y(t) || j(t)
            },
            et = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
            nt = Array.isArray,
            it = /(?:-?\.?\d|\.)+/gi,
            rt = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            at = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            st = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            ot = /[+-]=-?[.\d]+/,
            lt = /[^,'"\[\]\s]+/gi,
            ct = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
            ht = {},
            ut = {},
            dt = function(t) {
                return (ut = Ht(t, ht)) && Vn
            },
            pt = function(t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            },
            ft = function(t, e) {
                return !e && console.warn(t)
            },
            mt = function(t, e) {
                return t && (ht[t] = e) && ut && (ut[t] = e) || ht
            },
            gt = function() {
                return 0
            },
            _t = {
                suppressEvents: !0,
                isStart: !0,
                kill: !1
            },
            vt = {
                suppressEvents: !0,
                kill: !1
            },
            xt = {
                suppressEvents: !0
            },
            yt = {},
            Mt = [],
            St = {},
            Tt = {},
            Et = {},
            bt = 30,
            wt = [],
            At = "",
            Rt = function(t) {
                var e, n, i = t[0];
                if (J(i) || Y(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                    for (n = wt.length; n-- && !wt[n].targetTest(i););
                    e = wt[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new en(t[n], e))) || t.splice(n, 1);
                return t
            },
            Ct = function(t) {
                return t._gsap || Rt(ve(t))[0]._gsap
            },
            Pt = function(t, e, n) {
                return (n = t[e]) && Y(n) ? t[e]() : Z(n) && t.getAttribute && t.getAttribute(e) || n
            },
            Lt = function(t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            Ut = function(t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            Dt = function(t) {
                return Math.round(1e7 * t) / 1e7 || 0
            },
            It = function(t, e) {
                var n = e.charAt(0),
                    i = parseFloat(e.substr(2));
                return t = parseFloat(t), "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
            },
            Nt = function(t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                return i < n
            },
            Ot = function() {
                var t, e, n = Mt.length,
                    i = Mt.slice(0);
                for (St = {}, Mt.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            },
            Ft = function(t, e, n, i) {
                Mt.length && !A && Ot(), t.render(e, n, i || A && e < 0 && (t._initted || t._startAt)), Mt.length && !A && Ot()
            },
            zt = function(t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(lt).length < 2 ? e : j(t) ? t.trim() : t
            },
            Bt = function(t) {
                return t
            },
            kt = function(t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            Ht = function(t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            Vt = function t(e, n) {
                for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = J(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
                return e
            },
            Gt = function(t, e) {
                var n, i = {};
                for (n in t) n in e || (i[n] = t[n]);
                return i
            },
            Wt = function(t) {
                var e, n = t.parent || C,
                    i = t.keyframes ? (e = nt(t.keyframes), function(t, n) {
                        for (var i in n) i in t || "duration" === i && e || "ease" === i || (t[i] = n[i])
                    }) : kt;
                if (Q(t.inherit))
                    for (; n;) i(t, n.vars.defaults), n = n.parent || n._dp;
                return t
            },
            Xt = function(t, e, n, i, r) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var a, s = t[i];
                if (r)
                    for (a = e[r]; s && s[r] > a;) s = s._prev;
                return s ? (e._next = s._next, s._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t, e
            },
            qt = function(t, e, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = e._prev,
                    a = e._next;
                r ? r._next = a : t[n] === e && (t[n] = a), a ? a._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
            },
            jt = function(t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0
            },
            Yt = function(t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            },
            Kt = function(t, e, n, i) {
                return t._startAt && (A ? t._startAt.revert(vt) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i))
            },
            Zt = function t(e) {
                return !e || e._ts && t(e.parent)
            },
            Jt = function(t) {
                return t._repeat ? Qt(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Qt = function(t, e) {
                var n = Math.floor(t /= e);
                return t && n === t ? n - 1 : n
            },
            $t = function(t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            te = function(t) {
                return t._end = Dt(t._start + (t._tDur / Math.abs(t._ts || t._rts || k) || 0))
            },
            ee = function(t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = Dt(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), te(t), n._dirty || Yt(n, t)), t
            },
            ne = function(t, e) {
                var n;
                if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (n = $t(t.rawTime(), e), (!e._dur || fe(0, e.totalDuration(), n) - e._tTime > k) && e.render(n, !0)), Yt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            ie = function(t, e, n, i) {
                return e.parent && jt(e), e._start = Dt((K(n) ? n : n || t !== C ? ue(t, n, e) : t._time) + e._delay), e._end = Dt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Xt(t, e, "_first", "_last", t._sort ? "_start" : 0), oe(e) || (t._recent = e), i || ne(t, e), t._ts < 0 && ee(t, t._tTime), t
            },
            re = function(t, e) {
                return (ht.ScrollTrigger || pt("scrollTrigger", e)) && ht.ScrollTrigger.create(e, t)
            },
            ae = function(t, e, n, i, r) {
                return hn(t, e, r), t._initted ? !n && t._pt && !A && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && I !== Ve.frame ? (Mt.push(t), t._lazy = [r, i], 1) : void 0 : 1
            },
            se = function t(e) {
                var n = e.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            },
            oe = function(t) {
                var e = t.data;
                return "isFromStart" === e || "isStart" === e
            },
            le = function(t, e, n, i) {
                var r = t._repeat,
                    a = Dt(e) || 0,
                    s = t._tTime / t._tDur;
                return s && !i && (t._time *= a / t._dur), t._dur = a, t._tDur = r ? r < 0 ? 1e10 : Dt(a * (r + 1) + t._rDelay * r) : a, s > 0 && !i && ee(t, t._tTime = t._tDur * s), t.parent && te(t), n || Yt(t.parent, t), t
            },
            ce = function(t) {
                return t instanceof rn ? Yt(t) : le(t, t._dur)
            },
            he = {
                _start: 0,
                endTime: gt,
                totalDuration: gt
            },
            ue = function t(e, n, i) {
                var r, a, s, o = e.labels,
                    l = e._recent || he,
                    c = e.duration() >= B ? l.endTime(!1) : e._dur;
                return j(n) && (isNaN(n) || n in o) ? (a = n.charAt(0), s = "%" === n.substr(-1), r = n.indexOf("="), "<" === a || ">" === a ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === a ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (s ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c), o[n]) : (a = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), s && i && (a = a / 100 * (nt(i) ? i[0] : i).totalDuration()), r > 1 ? t(e, n.substr(0, r - 1), i) + a : c + a)) : null == n ? c : +n
            },
            de = function(t, e, n) {
                var i, r, a = K(e[1]),
                    s = (a ? 2 : 1) + (t < 2 ? 0 : 1),
                    o = e[s];
                if (a && (o.duration = e[1]), o.parent = n, t) {
                    for (i = o, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = Q(r.vars.inherit) && r.parent;
                    o.immediateRender = Q(i.immediateRender), t < 2 ? o.runBackwards = 1 : o.startAt = e[s - 1]
                }
                return new mn(e[0], o, e[s + 1])
            },
            pe = function(t, e) {
                return t || 0 === t ? e(t) : e
            },
            fe = function(t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            me = function(t, e) {
                return j(t) && (e = ct.exec(t)) ? e[1] : ""
            },
            ge = [].slice,
            _e = function(t, e) {
                return t && J(t) && "length" in t && (!e && !t.length || t.length - 1 in t && J(t[0])) && !t.nodeType && t !== P
            },
            ve = function(t, e, n) {
                return R && !e && R.selector ? R.selector(t) : !j(t) || n || !L && Ge() ? nt(t) ? function(t, e, n) {
                    return void 0 === n && (n = []), t.forEach((function(t) {
                        var i;
                        return j(t) && !e || _e(t, 1) ? (i = n).push.apply(i, ve(t)) : n.push(t)
                    })) || n
                }(t, n) : _e(t) ? ge.call(t, 0) : t ? [t] : [] : ge.call((e || U).querySelectorAll(t), 0)
            },
            xe = function(t) {
                return t = ve(t)[0] || ft("Invalid scope") || {},
                    function(e) {
                        var n = t.current || t.nativeElement || t;
                        return ve(e, n.querySelectorAll ? n : n === t ? ft("Invalid scope") || U.createElement("div") : t)
                    }
            },
            ye = function(t) {
                return t.sort((function() {
                    return .5 - Math.random()
                }))
            },
            Me = function(t) {
                if (Y(t)) return t;
                var e = J(t) ? t : {
                        each: t
                    },
                    n = Ze(e.ease),
                    i = e.from || 0,
                    r = parseFloat(e.base) || 0,
                    a = {},
                    s = i > 0 && i < 1,
                    o = isNaN(i) || s,
                    l = e.axis,
                    c = i,
                    h = i;
                return j(i) ? c = h = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[i] || 0 : !s && o && (c = i[0], h = i[1]),
                    function(t, s, u) {
                        var d, p, f, m, g, _, v, x, y, M = (u || e).length,
                            S = a[M];
                        if (!S) {
                            if (!(y = "auto" === e.grid ? 0 : (e.grid || [1, B])[1])) {
                                for (v = -B; v < (v = u[y++].getBoundingClientRect().left) && y < M;);
                                y--
                            }
                            for (S = a[M] = [], d = o ? Math.min(y, M) * c - .5 : i % y, p = y === B ? 0 : o ? M * h / y - .5 : i / y | 0, v = 0, x = B, _ = 0; _ < M; _++) f = _ % y - d, m = p - (_ / y | 0), S[_] = g = l ? Math.abs("y" === l ? m : f) : W(f * f + m * m), g > v && (v = g), g < x && (x = g);
                            "random" === i && ye(S), S.max = v - x, S.min = x, S.v = M = (parseFloat(e.amount) || parseFloat(e.each) * (y > M ? M - 1 : l ? "y" === l ? M / y : y : Math.max(y, M / y)) || 0) * ("edges" === i ? -1 : 1), S.b = M < 0 ? r - M : r, S.u = me(e.amount || e.each) || 0, n = n && M < 0 ? Ye(n) : n
                        }
                        return M = (S[t] - S.min) / S.max || 0, Dt(S.b + (n ? n(M) : M) * S.v) + S.u
                    }
            },
            Se = function(t) {
                var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                return function(n) {
                    var i = Dt(Math.round(parseFloat(n) / t) * t * e);
                    return (i - i % 1) / e + (K(n) ? 0 : me(n))
                }
            },
            Te = function(t, e) {
                var n, i, r = nt(t);
                return !r && J(t) && (n = r = t.radius || B, t.values ? (t = ve(t.values), (i = !K(t[0])) && (n *= n)) : t = Se(t.increment)), pe(e, r ? Y(t) ? function(e) {
                    return i = t(e), Math.abs(i - e) <= n ? i : e
                } : function(e) {
                    for (var r, a, s = parseFloat(i ? e.x : e), o = parseFloat(i ? e.y : 0), l = B, c = 0, h = t.length; h--;)(r = i ? (r = t[h].x - s) * r + (a = t[h].y - o) * a : Math.abs(t[h] - s)) < l && (l = r, c = h);
                    return c = !n || l <= n ? t[c] : e, i || c === e || K(e) ? c : c + me(e)
                } : Se(t))
            },
            Ee = function(t, e, n, i) {
                return pe(nt(t) ? !e : !0 === n ? !!(n = 0) : !i, (function() {
                    return nt(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
                }))
            },
            be = function(t, e, n) {
                return pe(n, (function(n) {
                    return t[~~e(n)]
                }))
            },
            we = function(t) {
                for (var e, n, i, r, a = 0, s = ""; ~(e = t.indexOf("random(", a));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? lt : it), s += t.substr(a, e - a) + Ee(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), a = i + 1;
                return s + t.substr(a, t.length - a)
            },
            Ae = function(t, e, n, i, r) {
                var a = e - t,
                    s = i - n;
                return pe(r, (function(e) {
                    return n + ((e - t) / a * s || 0)
                }))
            },
            Re = function(t, e, n) {
                var i, r, a, s = t.labels,
                    o = B;
                for (i in s)(r = s[i] - e) < 0 == !!n && r && o > (r = Math.abs(r)) && (a = i, o = r);
                return a
            },
            Ce = function(t, e, n) {
                var i, r, a, s = t.vars,
                    o = s[e],
                    l = R,
                    c = t._ctx;
                if (o) return i = s[e + "Params"], r = s.callbackScope || t, n && Mt.length && Ot(), c && (R = c), a = i ? o.apply(r, i) : o.call(r), R = l, a
            },
            Pe = function(t) {
                return jt(t), t.scrollTrigger && t.scrollTrigger.kill(!!A), t.progress() < 1 && Ce(t, "onInterrupt"), t
            },
            Le = [],
            Ue = function(t) {
                if ($() && t) {
                    var e = (t = !t.name && t.default || t).name,
                        n = Y(t),
                        i = e && !n && t.init ? function() {
                            this._props = []
                        } : t,
                        r = {
                            init: gt,
                            render: En,
                            add: ln,
                            kill: wn,
                            modifier: bn,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: yn,
                            aliases: {},
                            register: 0
                        };
                    if (Ge(), t !== i) {
                        if (Tt[e]) return;
                        kt(i, kt(Gt(t, r), a)), Ht(i.prototype, Ht(r, Gt(t, a))), Tt[i.prop = e] = i, t.targetTest && (wt.push(i), yt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                    }
                    mt(e, i), t.register && t.register(Vn, i, Cn)
                } else t && Le.push(t)
            },
            De = 255,
            Ie = {
                aqua: [0, De, De],
                lime: [0, De, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, De],
                navy: [0, 0, 128],
                white: [De, De, De],
                olive: [128, 128, 0],
                yellow: [De, De, 0],
                orange: [De, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [De, 0, 0],
                pink: [De, 192, 203],
                cyan: [0, De, De],
                transparent: [De, De, De, 0]
            },
            Ne = function(t, e, n) {
                return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * De + .5 | 0
            },
            Oe = function(t, e, n) {
                var i, r, a, s, o, l, c, h, u, d, p = t ? K(t) ? [t >> 16, t >> 8 & De, t & De] : 0 : Ie.black;
                if (!p) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Ie[t]) p = Ie[t];
                    else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (i = t.charAt(1), r = t.charAt(2), a = t.charAt(3), t = "#" + i + i + r + r + a + a + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & De, p & De, parseInt(t.substr(7), 16) / 255];
                        p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & De, t & De]
                    } else if ("hsl" === t.substr(0, 3))
                        if (p = d = t.match(it), e) {
                            if (~t.indexOf("=")) return p = t.match(rt), n && p.length < 4 && (p[3] = 1), p
                        } else s = +p[0] % 360 / 360, o = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = Ne(s + 1 / 3, i, r), p[1] = Ne(s, i, r), p[2] = Ne(s - 1 / 3, i, r);
                    else p = t.match(it) || Ie.transparent;
                    p = p.map(Number)
                }
                return e && !d && (i = p[0] / De, r = p[1] / De, a = p[2] / De, l = ((c = Math.max(i, r, a)) + (h = Math.min(i, r, a))) / 2, c === h ? s = o = 0 : (u = c - h, o = l > .5 ? u / (2 - c - h) : u / (c + h), s = c === i ? (r - a) / u + (r < a ? 6 : 0) : c === r ? (a - i) / u + 2 : (i - r) / u + 4, s *= 60), p[0] = ~~(s + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
            },
            Fe = function(t) {
                var e = [],
                    n = [],
                    i = -1;
                return t.split(Be).forEach((function(t) {
                    var r = t.match(at) || [];
                    e.push.apply(e, r), n.push(i += r.length + 1)
                })), e.c = n, e
            },
            ze = function(t, e, n) {
                var i, r, a, s, o = "",
                    l = (t + o).match(Be),
                    c = e ? "hsla(" : "rgba(",
                    h = 0;
                if (!l) return t;
                if (l = l.map((function(t) {
                        return (t = Oe(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    })), n && (a = Fe(t), (i = n.c).join(o) !== a.c.join(o)))
                    for (s = (r = t.replace(Be, "1").split(at)).length - 1; h < s; h++) o += r[h] + (~i.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift());
                if (!r)
                    for (s = (r = t.split(Be)).length - 1; h < s; h++) o += r[h] + l[h];
                return o + r[s]
            },
            Be = function() {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (t in Ie) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            ke = /hsl[a]?\(/,
            He = function(t) {
                var e, n = t.join(" ");
                if (Be.lastIndex = 0, Be.test(n)) return e = ke.test(n), t[1] = ze(t[1], e), t[0] = ze(t[0], e, Fe(t[1])), !0
            },
            Ve = function() {
                var t, e, n, i, r, a, s = Date.now,
                    o = 500,
                    l = 33,
                    c = s(),
                    h = c,
                    u = 1e3 / 240,
                    d = u,
                    p = [],
                    f = function n(f) {
                        var m, g, _, v, x = s() - h,
                            y = !0 === f;
                        if (x > o && (c += x - l), ((m = (_ = (h += x) - c) - d) > 0 || y) && (v = ++i.frame, r = _ - 1e3 * i.time, i.time = _ /= 1e3, d += m + (m >= u ? 4 : u - m), g = 1), y || (t = e(n)), g)
                            for (a = 0; a < p.length; a++) p[a](_, r, v, f)
                    };
                return i = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        f(!0)
                    },
                    deltaRatio: function(t) {
                        return r / (1e3 / (t || 60))
                    },
                    wake: function() {
                        D && (!L && $() && (P = L = window, U = P.document || {}, ht.gsap = Vn, (P.gsapVersions || (P.gsapVersions = [])).push(Vn.version), dt(ut || P.GreenSockGlobals || !P.gsap && P || {}), n = P.requestAnimationFrame, Le.forEach(Ue)), t && i.sleep(), e = n || function(t) {
                            return setTimeout(t, d - 1e3 * i.time + 1 | 0)
                        }, O = 1, f(2))
                    },
                    sleep: function() {
                        (n ? P.cancelAnimationFrame : clearTimeout)(t), O = 0, e = gt
                    },
                    lagSmoothing: function(t, e) {
                        o = t || 1 / 0, l = Math.min(e || 33, o)
                    },
                    fps: function(t) {
                        u = 1e3 / (t || 240), d = 1e3 * i.time + u
                    },
                    add: function(t, e, n) {
                        var r = e ? function(e, n, a, s) {
                            t(e, n, a, s), i.remove(r)
                        } : t;
                        return i.remove(t), p[n ? "unshift" : "push"](r), Ge(), r
                    },
                    remove: function(t, e) {
                        ~(e = p.indexOf(t)) && p.splice(e, 1) && a >= e && a--
                    },
                    _listeners: p
                }, i
            }(),
            Ge = function() {
                return !O && Ve.wake()
            },
            We = {},
            Xe = /^[\d.\-M][\d.\-,\s]/,
            qe = /["']/g,
            je = function(t) {
                for (var e, n, i, r = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) n = a[o], e = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[s] = isNaN(i) ? i.replace(qe, "").trim() : +i, s = n.substr(e + 1).trim();
                return r
            },
            Ye = function(t) {
                return function(e) {
                    return 1 - t(1 - e)
                }
            },
            Ke = function t(e, n) {
                for (var i, r = e._first; r;) r instanceof rn ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            },
            Ze = function(t, e) {
                return t && (Y(t) ? t : We[t] || function(t) {
                    var e, n, i, r, a = (t + "").split("("),
                        s = We[a[0]];
                    return s && a.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [je(a[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(zt)) : We._CE && Xe.test(t) ? We._CE("", t) : s
                }(t)) || e
            },
            Je = function(t, e, n, i) {
                void 0 === n && (n = function(t) {
                    return 1 - e(1 - t)
                }), void 0 === i && (i = function(t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, a = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: i
                };
                return Lt(t, (function(t) {
                    for (var e in We[t] = ht[t] = a, We[r = t.toLowerCase()] = n, a) We[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = We[t + "." + e] = a[e]
                })), a
            },
            Qe = function(t) {
                return function(e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            },
            $e = function t(e, n, i) {
                var r = n >= 1 ? n : 1,
                    a = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    s = a / H * (Math.asin(1 / r) || 0),
                    o = function(t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * q((t - s) * a) + 1
                    },
                    l = "out" === e ? o : "in" === e ? function(t) {
                        return 1 - o(1 - t)
                    } : Qe(o);
                return a = H / a, l.config = function(n, i) {
                    return t(e, n, i)
                }, l
            },
            tn = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var i = function(t) {
                        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                    },
                    r = "out" === e ? i : "in" === e ? function(t) {
                        return 1 - i(1 - t)
                    } : Qe(i);
                return r.config = function(n) {
                    return t(e, n)
                }, r
            };
        Lt("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
                var n = e < 5 ? e + 1 : e;
                Je(t + ",Power" + (n - 1), e ? function(t) {
                    return Math.pow(t, n)
                } : function(t) {
                    return t
                }, (function(t) {
                    return 1 - Math.pow(1 - t, n)
                }), (function(t) {
                    return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
                }))
            })), We.Linear.easeNone = We.none = We.Linear.easeIn, Je("Elastic", $e("in"), $e("out"), $e()),
            function(t, e) {
                var n = function(n) {
                    return n < .36363636363636365 ? t * n * n : n < .7272727272727273 ? t * Math.pow(n - 1.5 / e, 2) + .75 : n < .9090909090909092 ? t * (n -= 2.25 / e) * n + .9375 : t * Math.pow(n - 2.625 / e, 2) + .984375
                };
                Je("Bounce", (function(t) {
                    return 1 - n(1 - t)
                }), n)
            }(7.5625, 2.75), Je("Expo", (function(t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            })), Je("Circ", (function(t) {
                return -(W(1 - t * t) - 1)
            })), Je("Sine", (function(t) {
                return 1 === t ? 1 : 1 - X(t * V)
            })), Je("Back", tn("in"), tn("out"), tn()), We.SteppedEase = We.steps = ht.SteppedEase = {
                config: function(t, e) {
                    void 0 === t && (t = 1);
                    var n = 1 / t,
                        i = t + (e ? 0 : 1),
                        r = e ? 1 : 0;
                    return function(t) {
                        return ((i * fe(0, .99999999, t) | 0) + r) * n
                    }
                }
            }, z.ease = We["quad.out"], Lt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
                return At += t + "," + t + "Params,"
            }));
        var en = function(t, e) {
                this.id = G++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : Pt, this.set = e ? e.getSetter : yn
            },
            nn = function() {
                function t(t) {
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, le(this, +t.duration, 1, 1), this.data = t.data, R && (this._ctx = R, R.data.push(this)), O || Ve.wake()
                }
                var e = t.prototype;
                return e.delay = function(t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function(t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function(t) {
                    return arguments.length ? (this._dirty = 0, le(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function(t, e) {
                    if (Ge(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (ee(this, t), !n._dp || n.parent || ne(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && ie(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === k || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Ft(this, t, e)), this
                }, e.time = function(t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Jt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function(t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, e.progress = function(t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Jt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, e.iteration = function(t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Qt(this._tTime, n) + 1 : 1
                }, e.timeScale = function(t) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var e = this.parent && this._ts ? $t(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime(fe(-Math.abs(this._delay), this._tDur, e), !0), te(this),
                        function(t) {
                            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                            return t
                        }(this)
                }, e.paused = function(t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ge(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== k && (this._tTime -= k)))), this) : this._ps
                }, e.startTime = function(t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && ie(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function(t) {
                    return this._start + (Q(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }, e.rawTime = function(t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? $t(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.revert = function(t) {
                    void 0 === t && (t = xt);
                    var e = A;
                    return A = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), A = e, this
                }, e.globalTime = function(t) {
                    for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
                    return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 / 0 : this._sat.globalTime(t) : n
                }, e.repeat = function(t) {
                    return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, ce(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }, e.repeatDelay = function(t) {
                    if (arguments.length) {
                        var e = this._time;
                        return this._rDelay = t, ce(this), e ? this.time(e) : this
                    }
                    return this._rDelay
                }, e.yoyo = function(t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function(t, e) {
                    return this.totalTime(ue(this, t), Q(e))
                }, e.restart = function(t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, Q(e))
                }, e.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function() {
                    return this.paused(!1)
                }, e.reversed = function(t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function() {
                    return this._initted = this._act = 0, this._zTime = -1e-8, this
                }, e.isActive = function() {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - k))
                }, e.eventCallback = function(t, e, n) {
                    var i = this.vars;
                    return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
                }, e.then = function(t) {
                    var e = this;
                    return new Promise((function(n) {
                        var i = Y(t) ? t : Bt,
                            r = function() {
                                var t = e.then;
                                e.then = null, Y(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                    }))
                }, e.kill = function() {
                    Pe(this)
                }, t
            }();
        kt(nn.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var rn = function(t) {
            function e(e, n) {
                var i;
                return void 0 === e && (e = {}), (i = t.call(this, e) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = Q(e.sortChildren), C && ie(e.parent || C, E(i), n), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && re(E(i), e.scrollTrigger), i
            }
            b(e, t);
            var n = e.prototype;
            return n.to = function(t, e, n) {
                return de(0, arguments, this), this
            }, n.from = function(t, e, n) {
                return de(1, arguments, this), this
            }, n.fromTo = function(t, e, n, i) {
                return de(2, arguments, this), this
            }, n.set = function(t, e, n) {
                return e.duration = 0, e.parent = this, Wt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new mn(t, e, ue(this, n), 1), this
            }, n.call = function(t, e, n) {
                return ie(this, mn.delayedCall(0, t, e), n)
            }, n.staggerTo = function(t, e, n, i, r, a, s) {
                return n.duration = e, n.stagger = n.stagger || i, n.onComplete = a, n.onCompleteParams = s, n.parent = this, new mn(t, n, ue(this, r)), this
            }, n.staggerFrom = function(t, e, n, i, r, a, s) {
                return n.runBackwards = 1, Wt(n).immediateRender = Q(n.immediateRender), this.staggerTo(t, e, n, i, r, a, s)
            }, n.staggerFromTo = function(t, e, n, i, r, a, s, o) {
                return i.startAt = n, Wt(i).immediateRender = Q(i.immediateRender), this.staggerTo(t, e, i, r, a, s, o)
            }, n.render = function(t, e, n) {
                var i, r, a, s, o, l, c, h, u, d, p, f, m = this._time,
                    g = this._dirty ? this.totalDuration() : this._tDur,
                    _ = this._dur,
                    v = t <= 0 ? 0 : Dt(t),
                    x = this._zTime < 0 != t < 0 && (this._initted || !_);
                if (this !== C && v > g && t >= 0 && (v = g), v !== this._tTime || n || x) {
                    if (m !== this._time && _ && (v += this._time - m, t += this._time - m), i = v, u = this._start, l = !(h = this._ts), x && (_ || (m = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (p = this._yoyo, o = _ + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * o + t, e, n);
                        if (i = Dt(v % o), v === g ? (s = this._repeat, i = _) : ((s = ~~(v / o)) && s === v / o && (i = _, s--), i > _ && (i = _)), d = Qt(this._tTime, o), !m && this._tTime && d !== s && this._tTime - d * o - this._dur <= 0 && (d = s), p && 1 & s && (i = _ - i, f = 1), s !== d && !this._lock) {
                            var y = p && 1 & d,
                                M = y === (p && 1 & s);
                            if (s < d && (y = !y), m = y ? 0 : v % _ ? _ : v, this._lock = 1, this.render(m || (f ? 0 : Dt(s * o)), e, !_)._lock = 0, this._tTime = v, !e && this.parent && Ce(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (_ = this._dur, g = this._tDur, M && (this._lock = 2, m = y ? _ : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                            Ke(this, f)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(t, e, n) {
                            var i;
                            if (n > e)
                                for (i = t._first; i && i._start <= n;) {
                                    if ("isPause" === i.data && i._start > e) return i;
                                    i = i._next
                                } else
                                    for (i = t._last; i && i._start >= n;) {
                                        if ("isPause" === i.data && i._start < e) return i;
                                        i = i._prev
                                    }
                        }(this, Dt(m), Dt(i)), c && (v -= i - (i = c._start))), this._tTime = v, this._time = i, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, m = 0), !m && i && !e && !s && (Ce(this, "onStart"), this._tTime !== v)) return this;
                    if (i >= m && t >= 0)
                        for (r = this._first; r;) {
                            if (a = r._next, (r._act || i >= r._start) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    c = 0, a && (v += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = a
                        } else {
                            r = this._last;
                            for (var S = t < 0 ? t : i; r;) {
                                if (a = r._prev, (r._act || S <= r._end) && r._ts && c !== r) {
                                    if (r.parent !== this) return this.render(t, e, n);
                                    if (r.render(r._ts > 0 ? (S - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (S - r._start) * r._ts, e, n || A && (r._initted || r._startAt)), i !== this._time || !this._ts && !l) {
                                        c = 0, a && (v += this._zTime = S ? -1e-8 : k);
                                        break
                                    }
                                }
                                r = a
                            }
                        }
                    if (c && !e && (this.pause(), c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = u, te(this), this.render(t, e, n);
                    this._onUpdate && !e && Ce(this, "onUpdate", !0), (v === g && this._tTime >= this.totalDuration() || !v && m) && (u !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !_) && (v === g && this._ts > 0 || !v && this._ts < 0) && jt(this, 1), e || t < 0 && !m || !v && !m && g || (Ce(this, v === g && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < g && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function(t, e) {
                var n = this;
                if (K(e) || (e = ue(this, e, t)), !(t instanceof nn)) {
                    if (nt(t)) return t.forEach((function(t) {
                        return n.add(t, e)
                    })), this;
                    if (j(t)) return this.addLabel(t, e);
                    if (!Y(t)) return this;
                    t = mn.delayedCall(0, t)
                }
                return this !== t ? ie(this, t, e) : this
            }, n.getChildren = function(t, e, n, i) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -B);
                for (var r = [], a = this._first; a;) a._start >= i && (a instanceof mn ? e && r.push(a) : (n && r.push(a), t && r.push.apply(r, a.getChildren(!0, e, n)))), a = a._next;
                return r
            }, n.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                    if (e[n].vars.id === t) return e[n]
            }, n.remove = function(t) {
                return j(t) ? this.removeLabel(t) : Y(t) ? this.killTweensOf(t) : (qt(this, t), t === this._recent && (this._recent = this._last), Yt(this))
            }, n.totalTime = function(e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Dt(Ve.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function(t, e) {
                return this.labels[t] = ue(this, e), this
            }, n.removeLabel = function(t) {
                return delete this.labels[t], this
            }, n.addPause = function(t, e, n) {
                var i = mn.delayedCall(0, e || gt, n);
                return i.data = "isPause", this._hasPause = 1, ie(this, i, ue(this, t))
            }, n.removePause = function(t) {
                var e = this._first;
                for (t = ue(this, t); e;) e._start === t && "isPause" === e.data && jt(e), e = e._next
            }, n.killTweensOf = function(t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--;) an !== i[r] && i[r].kill(t, e);
                return this
            }, n.getTweensOf = function(t, e) {
                for (var n, i = [], r = ve(t), a = this._first, s = K(e); a;) a instanceof mn ? Nt(a._targets, r) && (s ? (!an || a._initted && a._ts) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && i.push(a) : (n = a.getTweensOf(r, e)).length && i.push.apply(i, n), a = a._next;
                return i
            }, n.tweenTo = function(t, e) {
                e = e || {};
                var n, i = this,
                    r = ue(i, t),
                    a = e,
                    s = a.startAt,
                    o = a.onStart,
                    l = a.onStartParams,
                    c = a.immediateRender,
                    h = mn.to(i, kt({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: r,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale()) || k,
                        onStart: function() {
                            if (i.pause(), !n) {
                                var t = e.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale());
                                h._dur !== t && le(h, t, 0, 1).render(h._time, !0, !0), n = 1
                            }
                            o && o.apply(h, l || [])
                        }
                    }, e));
                return c ? h.render(0) : h
            }, n.tweenFromTo = function(t, e, n) {
                return this.tweenTo(e, kt({
                    startAt: {
                        time: ue(this, t)
                    }
                }, n))
            }, n.recent = function() {
                return this._recent
            }, n.nextLabel = function(t) {
                return void 0 === t && (t = this._time), Re(this, ue(this, t))
            }, n.previousLabel = function(t) {
                return void 0 === t && (t = this._time), Re(this, ue(this, t), 1)
            }, n.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + k)
            }, n.shiftChildren = function(t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, a = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (i in a) a[i] >= n && (a[i] += t);
                return Yt(this)
            }, n.invalidate = function(e) {
                var n = this._first;
                for (this._lock = 0; n;) n.invalidate(e), n = n._next;
                return t.prototype.invalidate.call(this, e)
            }, n.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Yt(this)
            }, n.totalDuration = function(t) {
                var e, n, i, r = 0,
                    a = this,
                    s = a._last,
                    o = B;
                if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
                if (a._dirty) {
                    for (i = a.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (n = s._start) > o && a._sort && s._ts && !a._lock ? (a._lock = 1, ie(a, s, n - s._delay, 1)._lock = 0) : o = n, n < 0 && s._ts && (r -= n, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += n / a._ts, a._time -= n, a._tTime -= n), a.shiftChildren(-n, !1, -1 / 0), o = 0), s._end > r && s._ts && (r = s._end), s = e;
                    le(a, a === C && a._time > r ? a._time : r, 1, 1), a._dirty = 0
                }
                return a._tDur
            }, e.updateRoot = function(t) {
                if (C._ts && (Ft(C, $t(t, C)), I = Ve.frame), Ve.frame >= bt) {
                    bt += F.autoSleep || 120;
                    var e = C._first;
                    if ((!e || !e._ts) && F.autoSleep && Ve._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || Ve.sleep()
                    }
                }
            }, e
        }(nn);
        kt(rn.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var an, sn, on = function(t, e, n, i, r, a, s) {
                var o, l, c, h, u, d, p, f, m = new Cn(this._pt, t, e, 0, 1, Tn, null, r),
                    g = 0,
                    _ = 0;
                for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = we(i)), a && (a(f = [n, i], t, e), n = f[0], i = f[1]), l = n.match(st) || []; o = st.exec(i);) h = o[0], u = i.substring(g, o.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), h !== l[_++] && (d = parseFloat(l[_ - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: u || 1 === _ ? u : ",",
                    s: d,
                    c: "=" === h.charAt(1) ? It(d, h) - d : parseFloat(h) - d,
                    m: c && c < 4 ? Math.round : 0
                }, g = st.lastIndex);
                return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = s, (ot.test(i) || p) && (m.e = 0), this._pt = m, m
            },
            ln = function(t, e, n, i, r, a, s, o, l, c) {
                Y(i) && (i = i(r || 0, t, a));
                var h, u = t[e],
                    d = "get" !== n ? n : Y(u) ? l ? t[e.indexOf("set") || !Y(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                    p = Y(u) ? l ? vn : _n : gn;
                if (j(i) && (~i.indexOf("random(") && (i = we(i)), "=" === i.charAt(1) && ((h = It(d, i) + (me(d) || 0)) || 0 === h) && (i = h)), !c || d !== i || sn) return isNaN(d * i) || "" === i ? (!u && !(e in t) && pt(e, i), on.call(this, t, e, d, i, p, o || F.stringFilter, l)) : (h = new Cn(this._pt, t, e, +d || 0, i - (d || 0), "boolean" == typeof u ? Sn : Mn, 0, p), l && (h.fp = l), s && h.modifier(s, this, t), this._pt = h)
            },
            cn = function(t, e, n, i, r, a) {
                var s, o, l, c;
                if (Tt[t] && !1 !== (s = new Tt[t]).init(r, s.rawVars ? e[t] : function(t, e, n, i, r) {
                        if (Y(t) && (t = dn(t, r, e, n, i)), !J(t) || t.style && t.nodeType || nt(t) || et(t)) return j(t) ? dn(t, r, e, n, i) : t;
                        var a, s = {};
                        for (a in t) s[a] = dn(t[a], r, e, n, i);
                        return s
                    }(e[t], i, r, a, n), n, i, a) && (n._pt = o = new Cn(n._pt, r, t, 0, 1, s.render, s, 0, s.priority), n !== N))
                    for (l = n._ptLookup[n._targets.indexOf(r)], c = s._props.length; c--;) l[s._props[c]] = o;
                return s
            },
            hn = function t(e, n, i) {
                var r, a, s, o, l, c, h, u, d, p, f, m, g, _ = e.vars,
                    v = _.ease,
                    x = _.startAt,
                    y = _.immediateRender,
                    M = _.lazy,
                    S = _.onUpdate,
                    T = _.onUpdateParams,
                    E = _.callbackScope,
                    b = _.runBackwards,
                    R = _.yoyoEase,
                    P = _.keyframes,
                    L = _.autoRevert,
                    U = e._dur,
                    D = e._startAt,
                    I = e._targets,
                    N = e.parent,
                    O = N && "nested" === N.data ? N.vars.targets : I,
                    F = "auto" === e._overwrite && !w,
                    H = e.timeline;
                if (H && (!P || !v) && (v = "none"), e._ease = Ze(v, z.ease), e._yEase = R ? Ye(Ze(!0 === R ? v : R, z.ease)) : 0, R && e._yoyo && !e._repeat && (R = e._yEase, e._yEase = e._ease, e._ease = R), e._from = !H && !!_.runBackwards, !H || P && !_.stagger) {
                    if (m = (u = I[0] ? Ct(I[0]).harness : 0) && _[u.prop], r = Gt(_, yt), D && (D._zTime < 0 && D.progress(1), n < 0 && b && y && !L ? D.render(-1, !0) : D.revert(b && U ? vt : _t), D._lazy = 0), x) {
                        if (jt(e._startAt = mn.set(I, kt({
                                data: "isStart",
                                overwrite: !1,
                                parent: N,
                                immediateRender: !0,
                                lazy: !D && Q(M),
                                startAt: null,
                                delay: 0,
                                onUpdate: S,
                                onUpdateParams: T,
                                callbackScope: E,
                                stagger: 0
                            }, x))), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (A || !y && !L) && e._startAt.revert(vt), y && U && n <= 0 && i <= 0) return void(n && (e._zTime = n))
                    } else if (b && U && !D)
                        if (n && (y = !1), s = kt({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: y && !D && Q(M),
                                immediateRender: y,
                                stagger: 0,
                                parent: N
                            }, r), m && (s[u.prop] = m), jt(e._startAt = mn.set(I, s)), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (A ? e._startAt.revert(vt) : e._startAt.render(-1, !0)), e._zTime = n, y) {
                            if (!n) return
                        } else t(e._startAt, k, k);
                    for (e._pt = e._ptCache = 0, M = U && Q(M) || M && !U, a = 0; a < I.length; a++) {
                        if (h = (l = I[a])._gsap || Rt(I)[a]._gsap, e._ptLookup[a] = p = {}, St[h.id] && Mt.length && Ot(), f = O === I ? a : O.indexOf(l), u && !1 !== (d = new u).init(l, m || r, e, f, O) && (e._pt = o = new Cn(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function(t) {
                                p[t] = o
                            })), d.priority && (c = 1)), !u || m)
                            for (s in r) Tt[s] && (d = cn(s, r, e, f, l, O)) ? d.priority && (c = 1) : p[s] = o = ln.call(e, l, s, "get", r[s], f, O, 0, _.stringFilter);
                        e._op && e._op[a] && e.kill(l, e._op[a]), F && e._pt && (an = e, C.killTweensOf(l, p, e.globalTime(n)), g = !e.parent, an = 0), e._pt && M && (St[h.id] = 1)
                    }
                    c && Rn(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = S, e._initted = (!e._op || e._pt) && !g, P && n <= 0 && H.render(B, !0, !0)
            },
            un = function(t, e, n, i) {
                var r, a, s = e.ease || i || "power1.inOut";
                if (nt(e)) a = n[t] || (n[t] = []), e.forEach((function(t, n) {
                    return a.push({
                        t: n / (e.length - 1) * 100,
                        v: t,
                        e: s
                    })
                }));
                else
                    for (r in e) a = n[r] || (n[r] = []), "ease" === r || a.push({
                        t: parseFloat(t),
                        v: e[r],
                        e: s
                    })
            },
            dn = function(t, e, n, i, r) {
                return Y(t) ? t.call(e, n, i, r) : j(t) && ~t.indexOf("random(") ? we(t) : t
            },
            pn = At + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
            fn = {};
        Lt(pn + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
            return fn[t] = 1
        }));
        var mn = function(t) {
            function e(e, n, i, r) {
                var a;
                "number" == typeof n && (i.duration = n, n = i, i = null);
                var s, o, l, c, h, u, d, p, f = (a = t.call(this, r ? n : Wt(n)) || this).vars,
                    m = f.duration,
                    g = f.delay,
                    _ = f.immediateRender,
                    v = f.stagger,
                    x = f.overwrite,
                    y = f.keyframes,
                    M = f.defaults,
                    S = f.scrollTrigger,
                    T = f.yoyoEase,
                    b = n.parent || C,
                    A = (nt(e) || et(e) ? K(e[0]) : "length" in n) ? [e] : ve(e);
                if (a._targets = A.length ? Rt(A) : ft("GSAP target " + e + " not found. https://greensock.com", !F.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = x, y || v || tt(m) || tt(g)) {
                    if (n = a.vars, (s = a.timeline = new rn({
                            data: "nested",
                            defaults: M || {},
                            targets: b && "nested" === b.data ? b.vars.targets : A
                        })).kill(), s.parent = s._dp = E(a), s._start = 0, v || tt(m) || tt(g)) {
                        if (c = A.length, d = v && Me(v), J(v))
                            for (h in v) ~pn.indexOf(h) && (p || (p = {}), p[h] = v[h]);
                        for (o = 0; o < c; o++)(l = Gt(n, fn)).stagger = 0, T && (l.yoyoEase = T), p && Ht(l, p), u = A[o], l.duration = +dn(m, E(a), o, u, A), l.delay = (+dn(g, E(a), o, u, A) || 0) - a._delay, !v && 1 === c && l.delay && (a._delay = g = l.delay, a._start += g, l.delay = 0), s.to(u, l, d ? d(o, u, A) : 0), s._ease = We.none;
                        s.duration() ? m = g = 0 : a.timeline = 0
                    } else if (y) {
                        Wt(kt(s.vars.defaults, {
                            ease: "none"
                        })), s._ease = Ze(y.ease || n.ease || "none");
                        var R, P, L, U = 0;
                        if (nt(y)) y.forEach((function(t) {
                            return s.to(A, t, ">")
                        })), s.duration();
                        else {
                            for (h in l = {}, y) "ease" === h || "easeEach" === h || un(h, y[h], l, y.easeEach);
                            for (h in l)
                                for (R = l[h].sort((function(t, e) {
                                        return t.t - e.t
                                    })), U = 0, o = 0; o < R.length; o++)(L = {
                                    ease: (P = R[o]).e,
                                    duration: (P.t - (o ? R[o - 1].t : 0)) / 100 * m
                                })[h] = P.v, s.to(A, L, U), U += L.duration;
                            s.duration() < m && s.to({}, {
                                duration: m - s.duration()
                            })
                        }
                    }
                    m || a.duration(m = s.duration())
                } else a.timeline = 0;
                return !0 !== x || w || (an = E(a), C.killTweensOf(A), an = 0), ie(b, E(a), i), n.reversed && a.reverse(), n.paused && a.paused(!0), (_ || !m && !y && a._start === Dt(b._time) && Q(_) && Zt(E(a)) && "nested" !== b.data) && (a._tTime = -1e-8, a.render(Math.max(0, -g) || 0)), S && re(E(a), S), a
            }
            b(e, t);
            var n = e.prototype;
            return n.render = function(t, e, n) {
                var i, r, a, s, o, l, c, h, u, d = this._time,
                    p = this._tDur,
                    f = this._dur,
                    m = t < 0,
                    g = t > p - k && !m ? p : t < k ? 0 : t;
                if (f) {
                    if (g !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) {
                        if (i = g, h = this.timeline, this._repeat) {
                            if (s = f + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * s + t, e, n);
                            if (i = Dt(g % s), g === p ? (a = this._repeat, i = f) : ((a = ~~(g / s)) && a === g / s && (i = f, a--), i > f && (i = f)), (l = this._yoyo && 1 & a) && (u = this._yEase, i = f - i), o = Qt(this._tTime, s), i === d && !n && this._initted) return this._tTime = g, this;
                            a !== o && (h && this._yEase && Ke(h, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(Dt(s * a), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (ae(this, m ? t : i, n, e, g)) return this._tTime = 0, this;
                            if (d !== this._time) return this;
                            if (f !== this._dur) return this.render(t, e, n)
                        }
                        if (this._tTime = g, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (u || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !e && !a && (Ce(this, "onStart"), this._tTime !== g)) return this;
                        for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                        h && h.render(t < 0 ? t : !i && l ? -1e-8 : h._dur * h._ease(i / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (m && Kt(this, t, 0, n), Ce(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && Ce(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && Kt(this, t, 0, !0), (t || !f) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && jt(this, 1), e || m && !d || !(g || d || l) || (Ce(this, g === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < p && this.timeScale() > 0) && this._prom()))
                    }
                } else ! function(t, e, n, i) {
                    var r, a, s, o = t.ratio,
                        l = e < 0 || !e && (!t._start && se(t) && (t._initted || !oe(t)) || (t._ts < 0 || t._dp._ts < 0) && !oe(t)) ? 0 : 1,
                        c = t._rDelay,
                        h = 0;
                    if (c && t._repeat && (h = fe(0, t._tDur, e), a = Qt(h, c), t._yoyo && 1 & a && (l = 1 - l), a !== Qt(t._tTime, c) && (o = 1 - l, t.vars.repeatRefresh && t._initted && t.invalidate())), l !== o || A || i || t._zTime === k || !e && t._zTime) {
                        if (!t._initted && ae(t, e, i, n, h)) return;
                        for (s = t._zTime, t._zTime = e || (n ? k : 0), n || (n = e && !s), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = h, r = t._pt; r;) r.r(l, r.d), r = r._next;
                        e < 0 && Kt(t, e, 0, !0), t._onUpdate && !n && Ce(t, "onUpdate"), h && t._repeat && !n && t.parent && Ce(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && jt(t, 1), n || A || (Ce(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                }(this, t, e, n);
                return this
            }, n.targets = function() {
                return this._targets
            }, n.invalidate = function(e) {
                return (!e || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(e), t.prototype.invalidate.call(this, e)
            }, n.resetTo = function(t, e, n, i) {
                O || Ve.wake(), this._ts || this.play();
                var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || hn(this, r),
                    function(t, e, n, i, r, a, s) {
                        var o, l, c, h, u = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                        if (!u)
                            for (u = t._ptCache[e] = [], c = t._ptLookup, h = t._targets.length; h--;) {
                                if ((o = c[h][e]) && o.d && o.d._pt)
                                    for (o = o.d._pt; o && o.p !== e && o.fp !== e;) o = o._next;
                                if (!o) return sn = 1, t.vars[e] = "+=0", hn(t, s), sn = 0, 1;
                                u.push(o)
                            }
                        for (h = u.length; h--;)(o = (l = u[h])._pt || l).s = !i && 0 !== i || r ? o.s + (i || 0) + a * o.c : i, o.c = n - o.s, l.e && (l.e = Ut(n) + me(l.e)), l.b && (l.b = o.s + me(l.b))
                    }(this, t, e, n, i, this._ease(r / this._dur), r) ? this.resetTo(t, e, n, i) : (ee(this, 0), this.parent || Xt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
            }, n.kill = function(t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? Pe(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, an && !0 !== an.vars.overwrite)._first || Pe(this), this.parent && n !== this.timeline.totalDuration() && le(this, this._dur * this.timeline._tDur / n, 0, 1), this
                }
                var i, r, a, s, o, l, c, h = this._targets,
                    u = t ? ve(t) : h,
                    d = this._ptLookup,
                    p = this._pt;
                if ((!e || "all" === e) && function(t, e) {
                        for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                        return n < 0
                    }(h, u)) return "all" === e && (this._pt = 0), Pe(this);
                for (i = this._op = this._op || [], "all" !== e && (j(e) && (o = {}, Lt(e, (function(t) {
                        return o[t] = 1
                    })), e = o), e = function(t, e) {
                        var n, i, r, a, s = t[0] ? Ct(t[0]).harness : 0,
                            o = s && s.aliases;
                        if (!o) return e;
                        for (i in n = Ht({}, e), o)
                            if (i in n)
                                for (r = (a = o[i].split(",")).length; r--;) n[a[r]] = n[i];
                        return n
                    }(h, e)), c = h.length; c--;)
                    if (~u.indexOf(h[c]))
                        for (o in r = d[c], "all" === e ? (i[c] = e, s = r, a = {}) : (a = i[c] = i[c] || {}, s = e), s)(l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || qt(this, l, "_pt"), delete r[o]), "all" !== a && (a[o] = 1);
                return this._initted && !this._pt && p && Pe(this), this
            }, e.to = function(t, n) {
                return new e(t, n, arguments[2])
            }, e.from = function(t, e) {
                return de(1, arguments)
            }, e.delayedCall = function(t, n, i, r) {
                return new e(n, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: r
                })
            }, e.fromTo = function(t, e, n) {
                return de(2, arguments)
            }, e.set = function(t, n) {
                return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
            }, e.killTweensOf = function(t, e, n) {
                return C.killTweensOf(t, e, n)
            }, e
        }(nn);
        kt(mn.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), Lt("staggerTo,staggerFrom,staggerFromTo", (function(t) {
            mn[t] = function() {
                var e = new rn,
                    n = ge.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var gn = function(t, e, n) {
                return t[e] = n
            },
            _n = function(t, e, n) {
                return t[e](n)
            },
            vn = function(t, e, n, i) {
                return t[e](i.fp, n)
            },
            xn = function(t, e, n) {
                return t.setAttribute(e, n)
            },
            yn = function(t, e) {
                return Y(t[e]) ? _n : Z(t[e]) && t.setAttribute ? xn : gn
            },
            Mn = function(t, e) {
                return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
            },
            Sn = function(t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            Tn = function(t, e) {
                var n = e._pt,
                    i = "";
                if (!t && e.b) i = e.b;
                else if (1 === t && e.e) i = e.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                    i += e.c
                }
                e.set(e.t, e.p, i, e)
            },
            En = function(t, e) {
                for (var n = e._pt; n;) n.r(t, n.d), n = n._next
            },
            bn = function(t, e, n, i) {
                for (var r, a = this._pt; a;) r = a._next, a.p === i && a.modifier(t, e, n), a = r
            },
            wn = function(t) {
                for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? qt(this, i, "_pt") : i.dep || (e = 1), i = n;
                return !e
            },
            An = function(t, e, n, i) {
                i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
            },
            Rn = function(t) {
                for (var e, n, i, r, a = t._pt; a;) {
                    for (e = a._next, n = i; n && n.pr > a.pr;) n = n._next;
                    (a._prev = n ? n._prev : r) ? a._prev._next = a: i = a, (a._next = n) ? n._prev = a : r = a, a = e
                }
                t._pt = i
            },
            Cn = function() {
                function t(t, e, n, i, r, a, s, o, l) {
                    this.t = e, this.s = i, this.c = r, this.p = n, this.r = a || Mn, this.d = s || this, this.set = o || gn, this.pr = l || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function(t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = An, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        Lt(At + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
            return yt[t] = 1
        })), ht.TweenMax = ht.TweenLite = mn, ht.TimelineLite = ht.TimelineMax = rn, C = new rn({
            sortChildren: !1,
            defaults: z,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), F.stringFilter = He;
        var Pn = [],
            Ln = {},
            Un = [],
            Dn = 0,
            In = 0,
            Nn = function(t) {
                return (Ln[t] || Un).map((function(t) {
                    return t()
                }))
            },
            On = function() {
                var t = Date.now(),
                    e = [];
                t - Dn > 2 && (Nn("matchMediaInit"), Pn.forEach((function(t) {
                    var n, i, r, a, s = t.queries,
                        o = t.conditions;
                    for (i in s)(n = P.matchMedia(s[i]).matches) && (r = 1), n !== o[i] && (o[i] = n, a = 1);
                    a && (t.revert(), r && e.push(t))
                })), Nn("matchMediaRevert"), e.forEach((function(t) {
                    return t.onMatch(t)
                })), Dn = t, Nn("matchMedia"))
            },
            Fn = function() {
                function t(t, e) {
                    this.selector = e && xe(e), this.data = [], this._r = [], this.isReverted = !1, this.id = In++, t && this.add(t)
                }
                var e = t.prototype;
                return e.add = function(t, e, n) {
                    Y(t) && (n = e, e = t, t = Y);
                    var i = this,
                        r = function() {
                            var t, r = R,
                                a = i.selector;
                            return r && r !== i && r.data.push(i), n && (i.selector = xe(n)), R = i, t = e.apply(i, arguments), Y(t) && i._r.push(t), R = r, i.selector = a, i.isReverted = !1, t
                        };
                    return i.last = r, t === Y ? r(i) : t ? i[t] = r : r
                }, e.ignore = function(t) {
                    var e = R;
                    R = null, t(this), R = e
                }, e.getTweens = function() {
                    var e = [];
                    return this.data.forEach((function(n) {
                        return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof mn && !(n.parent && "nested" === n.parent.data) && e.push(n)
                    })), e
                }, e.clear = function() {
                    this._r.length = this.data.length = 0
                }, e.kill = function(t, e) {
                    var n = this;
                    if (t) {
                        var i = this.getTweens();
                        this.data.forEach((function(t) {
                            "isFlip" === t.data && (t.revert(), t.getChildren(!0, !0, !1).forEach((function(t) {
                                return i.splice(i.indexOf(t), 1)
                            })))
                        })), i.map((function(t) {
                            return {
                                g: t.globalTime(0),
                                t: t
                            }
                        })).sort((function(t, e) {
                            return e.g - t.g || -1 / 0
                        })).forEach((function(e) {
                            return e.t.revert(t)
                        })), this.data.forEach((function(e) {
                            return !(e instanceof mn) && e.revert && e.revert(t)
                        })), this._r.forEach((function(e) {
                            return e(t, n)
                        })), this.isReverted = !0
                    } else this.data.forEach((function(t) {
                        return t.kill && t.kill()
                    }));
                    if (this.clear(), e)
                        for (var r = Pn.length; r--;) Pn[r].id === this.id && Pn.splice(r, 1)
                }, e.revert = function(t) {
                    this.kill(t || {})
                }, t
            }(),
            zn = function() {
                function t(t) {
                    this.contexts = [], this.scope = t
                }
                var e = t.prototype;
                return e.add = function(t, e, n) {
                    J(t) || (t = {
                        matches: t
                    });
                    var i, r, a, s = new Fn(0, n || this.scope),
                        o = s.conditions = {};
                    for (r in R && !s.selector && (s.selector = R.selector), this.contexts.push(s), e = s.add("onMatch", e), s.queries = t, t) "all" === r ? a = 1 : (i = P.matchMedia(t[r])) && (Pn.indexOf(s) < 0 && Pn.push(s), (o[r] = i.matches) && (a = 1), i.addListener ? i.addListener(On) : i.addEventListener("change", On));
                    return a && e(s), this
                }, e.revert = function(t) {
                    this.kill(t || {})
                }, e.kill = function(t) {
                    this.contexts.forEach((function(e) {
                        return e.kill(t, !0)
                    }))
                }, t
            }(),
            Bn = {
                registerPlugin: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function(t) {
                        return Ue(t)
                    }))
                },
                timeline: function(t) {
                    return new rn(t)
                },
                getTweensOf: function(t, e) {
                    return C.getTweensOf(t, e)
                },
                getProperty: function(t, e, n, i) {
                    j(t) && (t = ve(t)[0]);
                    var r = Ct(t || {}).get,
                        a = n ? Bt : zt;
                    return "native" === n && (n = ""), t ? e ? a((Tt[e] && Tt[e].get || r)(t, e, n, i)) : function(e, n, i) {
                        return a((Tt[e] && Tt[e].get || r)(t, e, n, i))
                    } : t
                },
                quickSetter: function(t, e, n) {
                    if ((t = ve(t)).length > 1) {
                        var i = t.map((function(t) {
                                return Vn.quickSetter(t, e, n)
                            })),
                            r = i.length;
                        return function(t) {
                            for (var e = r; e--;) i[e](t)
                        }
                    }
                    t = t[0] || {};
                    var a = Tt[e],
                        s = Ct(t),
                        o = s.harness && (s.harness.aliases || {})[e] || e,
                        l = a ? function(e) {
                            var i = new a;
                            N._pt = 0, i.init(t, n ? e + n : e, N, 0, [t]), i.render(1, i), N._pt && En(1, N)
                        } : s.set(t, o);
                    return a ? l : function(e) {
                        return l(t, o, n ? e + n : e, s, 1)
                    }
                },
                quickTo: function(t, e, n) {
                    var i, r = Vn.to(t, Ht(((i = {})[e] = "+=0.1", i.paused = !0, i), n || {})),
                        a = function(t, n, i) {
                            return r.resetTo(e, t, n, i)
                        };
                    return a.tween = r, a
                },
                isTweening: function(t) {
                    return C.getTweensOf(t, !0).length > 0
                },
                defaults: function(t) {
                    return t && t.ease && (t.ease = Ze(t.ease, z.ease)), Vt(z, t || {})
                },
                config: function(t) {
                    return Vt(F, t || {})
                },
                registerEffect: function(t) {
                    var e = t.name,
                        n = t.effect,
                        i = t.plugins,
                        r = t.defaults,
                        a = t.extendTimeline;
                    (i || "").split(",").forEach((function(t) {
                        return t && !Tt[t] && !ht[t] && ft(e + " effect requires " + t + " plugin.")
                    })), Et[e] = function(t, e, i) {
                        return n(ve(t), kt(e || {}, r), i)
                    }, a && (rn.prototype[e] = function(t, n, i) {
                        return this.add(Et[e](t, J(n) ? n : (i = n) && {}, this), i)
                    })
                },
                registerEase: function(t, e) {
                    We[t] = Ze(e)
                },
                parseEase: function(t, e) {
                    return arguments.length ? Ze(t, e) : We
                },
                getById: function(t) {
                    return C.getById(t)
                },
                exportRoot: function(t, e) {
                    void 0 === t && (t = {});
                    var n, i, r = new rn(t);
                    for (r.smoothChildTiming = Q(t.smoothChildTiming), C.remove(r), r._dp = 0, r._time = r._tTime = C._time, n = C._first; n;) i = n._next, !e && !n._dur && n instanceof mn && n.vars.onComplete === n._targets[0] || ie(r, n, n._start - n._delay), n = i;
                    return ie(C, r, 0), r
                },
                context: function(t, e) {
                    return t ? new Fn(t, e) : R
                },
                matchMedia: function(t) {
                    return new zn(t)
                },
                matchMediaRefresh: function() {
                    return Pn.forEach((function(t) {
                        var e, n, i = t.conditions;
                        for (n in i) i[n] && (i[n] = !1, e = 1);
                        e && t.revert()
                    })) || On()
                },
                addEventListener: function(t, e) {
                    var n = Ln[t] || (Ln[t] = []);
                    ~n.indexOf(e) || n.push(e)
                },
                removeEventListener: function(t, e) {
                    var n = Ln[t],
                        i = n && n.indexOf(e);
                    i >= 0 && n.splice(i, 1)
                },
                utils: {
                    wrap: function t(e, n, i) {
                        var r = n - e;
                        return nt(e) ? be(e, t(0, e.length), n) : pe(i, (function(t) {
                            return (r + (t - e) % r) % r + e
                        }))
                    },
                    wrapYoyo: function t(e, n, i) {
                        var r = n - e,
                            a = 2 * r;
                        return nt(e) ? be(e, t(0, e.length - 1), n) : pe(i, (function(t) {
                            return e + ((t = (a + (t - e) % a) % a || 0) > r ? a - t : t)
                        }))
                    },
                    distribute: Me,
                    random: Ee,
                    snap: Te,
                    normalize: function(t, e, n) {
                        return Ae(t, e, 0, 1, n)
                    },
                    getUnit: me,
                    clamp: function(t, e, n) {
                        return pe(n, (function(n) {
                            return fe(t, e, n)
                        }))
                    },
                    splitColor: Oe,
                    toArray: ve,
                    selector: xe,
                    mapRange: Ae,
                    pipe: function() {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return function(t) {
                            return e.reduce((function(t, e) {
                                return e(t)
                            }), t)
                        }
                    },
                    unitize: function(t, e) {
                        return function(n) {
                            return t(parseFloat(n)) + (e || me(n))
                        }
                    },
                    interpolate: function t(e, n, i, r) {
                        var a = isNaN(e + n) ? 0 : function(t) {
                            return (1 - t) * e + t * n
                        };
                        if (!a) {
                            var s, o, l, c, h, u = j(e),
                                d = {};
                            if (!0 === i && (r = 1) && (i = null), u) e = {
                                p: e
                            }, n = {
                                p: n
                            };
                            else if (nt(e) && !nt(n)) {
                                for (l = [], c = e.length, h = c - 2, o = 1; o < c; o++) l.push(t(e[o - 1], e[o]));
                                c--, a = function(t) {
                                    t *= c;
                                    var e = Math.min(h, ~~t);
                                    return l[e](t - e)
                                }, i = n
                            } else r || (e = Ht(nt(e) ? [] : {}, e));
                            if (!l) {
                                for (s in n) ln.call(d, e, s, "get", n[s]);
                                a = function(t) {
                                    return En(t, d) || (u ? e.p : e)
                                }
                            }
                        }
                        return pe(i, a)
                    },
                    shuffle: ye
                },
                install: dt,
                effects: Et,
                ticker: Ve,
                updateRoot: rn.updateRoot,
                plugins: Tt,
                globalTimeline: C,
                core: {
                    PropTween: Cn,
                    globals: mt,
                    Tween: mn,
                    Timeline: rn,
                    Animation: nn,
                    getCache: Ct,
                    _removeLinkedListItem: qt,
                    reverting: function() {
                        return A
                    },
                    context: function(t) {
                        return t && R && (R.data.push(t), t._ctx = R), R
                    },
                    suppressOverwrites: function(t) {
                        return w = t
                    }
                }
            };
        Lt("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
            return Bn[t] = mn[t]
        })), Ve.add(rn.updateRoot), N = Bn.to({}, {
            duration: 0
        });
        var kn = function(t, e) {
                for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                return n
            },
            Hn = function(t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function(t, n, i) {
                        i._onInit = function(t) {
                            var i, r;
                            if (j(n) && (i = {}, Lt(n, (function(t) {
                                    return i[t] = 1
                                })), n = i), e) {
                                for (r in i = {}, n) i[r] = e(n[r]);
                                n = i
                            }! function(t, e) {
                                var n, i, r, a = t._targets;
                                for (n in e)
                                    for (i = a.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = kn(r, n)), r && r.modifier && r.modifier(e[n], t, a[i], n))
                            }(t, n)
                        }
                    }
                }
            },
            Vn = Bn.registerPlugin({
                name: "attr",
                init: function(t, e, n, i, r) {
                    var a, s, o;
                    for (a in this.tween = n, e) o = t.getAttribute(a) || "", (s = this.add(t, "setAttribute", (o || 0) + "", e[a], i, r, 0, 0, a)).op = a, s.b = o, this._props.push(a)
                },
                render: function(t, e) {
                    for (var n = e._pt; n;) A ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next
                }
            }, {
                name: "endArray",
                init: function(t, e) {
                    for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
                }
            }, Hn("roundProps", Se), Hn("modifiers"), Hn("snap", Te)) || Bn;
        mn.version = rn.version = Vn.version = "3.12.2", D = 1, $() && Ge(), We.Power0, We.Power1, We.Power2, We.Power3, We.Power4, We.Linear, We.Quad, We.Cubic, We.Quart, We.Quint, We.Strong, We.Elastic, We.Back, We.SteppedEase, We.Bounce, We.Sine, We.Expo, We.Circ;
        var Gn, Wn, Xn, qn, jn, Yn, Kn, Zn, Jn = {},
            Qn = 180 / Math.PI,
            $n = Math.PI / 180,
            ti = Math.atan2,
            ei = /([A-Z])/g,
            ni = /(left|right|width|margin|padding|x)/i,
            ii = /[\s,\(]\S/,
            ri = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            ai = function(t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            si = function(t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            oi = function(t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            },
            li = function(t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            },
            ci = function(t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            },
            hi = function(t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            },
            ui = function(t, e, n) {
                return t.style[e] = n
            },
            di = function(t, e, n) {
                return t.style.setProperty(e, n)
            },
            pi = function(t, e, n) {
                return t._gsap[e] = n
            },
            fi = function(t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            mi = function(t, e, n, i, r) {
                var a = t._gsap;
                a.scaleX = a.scaleY = n, a.renderTransform(r, a)
            },
            gi = function(t, e, n, i, r) {
                var a = t._gsap;
                a[e] = n, a.renderTransform(r, a)
            },
            _i = "transform",
            vi = _i + "Origin",
            xi = function t(e, n) {
                var i = this,
                    r = this.target,
                    a = r.style;
                if (e in Jn && a) {
                    if (this.tfm = this.tfm || {}, "transform" === e) return ri.transform.split(",").forEach((function(e) {
                        return t.call(i, e, n)
                    }));
                    if (~(e = ri[e] || e).indexOf(",") ? e.split(",").forEach((function(t) {
                            return i.tfm[t] = Fi(r, t)
                        })) : this.tfm[e] = r._gsap.x ? r._gsap[e] : Fi(r, e), this.props.indexOf(_i) >= 0) return;
                    r._gsap.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(vi, n, "")), e = _i
                }(a || n) && this.props.push(e, n, a[e])
            },
            yi = function(t) {
                t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
            },
            Mi = function() {
                var t, e, n = this.props,
                    i = this.target,
                    r = i.style,
                    a = i._gsap;
                for (t = 0; t < n.length; t += 3) n[t + 1] ? i[n[t]] = n[t + 2] : n[t + 2] ? r[n[t]] = n[t + 2] : r.removeProperty("--" === n[t].substr(0, 2) ? n[t] : n[t].replace(ei, "-$1").toLowerCase());
                if (this.tfm) {
                    for (e in this.tfm) a[e] = this.tfm[e];
                    a.svg && (a.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (t = Kn()) && t.isStart || r[_i] || (yi(r), a.uncache = 1)
                }
            },
            Si = function(t, e) {
                var n = {
                    target: t,
                    props: [],
                    revert: Mi,
                    save: xi
                };
                return t._gsap || Vn.core.getCache(t), e && e.split(",").forEach((function(t) {
                    return n.save(t)
                })), n
            },
            Ti = function(t, e) {
                var n = Wn.createElementNS ? Wn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Wn.createElement(t);
                return n.style ? n : Wn.createElement(t)
            },
            Ei = function t(e, n, i) {
                var r = getComputedStyle(e);
                return r[n] || r.getPropertyValue(n.replace(ei, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, wi(n) || n, 1) || ""
            },
            bi = "O,Moz,ms,Ms,Webkit".split(","),
            wi = function(t, e, n) {
                var i = (e || jn).style,
                    r = 5;
                if (t in i && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(bi[r] + t in i););
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? bi[r] : "") + t
            },
            Ai = function() {
                "undefined" != typeof window && window.document && (Gn = window, Wn = Gn.document, Xn = Wn.documentElement, jn = Ti("div") || {
                    style: {}
                }, Ti("div"), _i = wi(_i), vi = _i + "Origin", jn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Zn = !!wi("perspective"), Kn = Vn.core.reverting, qn = 1)
            },
            Ri = function t(e) {
                var n, i = Ti("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    a = this.nextSibling,
                    s = this.style.cssText;
                if (Xn.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                return r && (a ? r.insertBefore(this, a) : r.appendChild(this)), Xn.removeChild(i), this.style.cssText = s, n
            },
            Ci = function(t, e) {
                for (var n = e.length; n--;)
                    if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            },
            Pi = function(t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = Ri.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === Ri || (e = Ri.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +Ci(t, ["x", "cx", "x1"]) || 0,
                    y: +Ci(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            Li = function(t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Pi(t))
            },
            Ui = function(t, e) {
                if (e) {
                    var n = t.style;
                    e in Jn && e !== vi && (e = _i), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(ei, "-$1").toLowerCase())) : n.removeAttribute(e)
                }
            },
            Di = function(t, e, n, i, r, a) {
                var s = new Cn(t._pt, e, n, 0, 1, a ? hi : ci);
                return t._pt = s, s.b = i, s.e = r, t._props.push(n), s
            },
            Ii = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            Ni = {
                grid: 1,
                flex: 1
            },
            Oi = function t(e, n, i, r) {
                var a, s, o, l, c = parseFloat(i) || 0,
                    h = (i + "").trim().substr((c + "").length) || "px",
                    u = jn.style,
                    d = ni.test(n),
                    p = "svg" === e.tagName.toLowerCase(),
                    f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                    m = 100,
                    g = "px" === r,
                    _ = "%" === r;
                return r === h || !c || Ii[r] || Ii[h] ? c : ("px" !== h && !g && (c = t(e, n, i, "px")), l = e.getCTM && Li(e), !_ && "%" !== h || !Jn[n] && !~n.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? h : r), s = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode, l && (s = (e.ownerSVGElement || {}).parentNode), s && s !== Wn && s.appendChild || (s = Wn.body), (o = s._gsap) && _ && o.width && d && o.time === Ve.time && !o.uncache ? Ut(c / o.width * m) : ((_ || "%" === h) && !Ni[Ei(s, "display")] && (u.position = Ei(e, "position")), s === e && (u.position = "static"), s.appendChild(jn), a = jn[f], s.removeChild(jn), u.position = "absolute", d && _ && ((o = Ct(s)).time = Ve.time, o.width = s[f]), Ut(g ? a * c / m : a && c ? m / a * c : 0))) : (a = l ? e.getBBox()[d ? "width" : "height"] : e[f], Ut(_ ? c / a * m : c / 100 * a)))
            },
            Fi = function(t, e, n, i) {
                var r;
                return qn || Ai(), e in ri && "transform" !== e && ~(e = ri[e]).indexOf(",") && (e = e.split(",")[0]), Jn[e] && "transform" !== e ? (r = Yi(t, i), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : Ki(Ei(t, vi)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Hi[e] && Hi[e](t, e, n) || Ei(t, e) || Pt(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? Oi(t, e, r, n) + n : r
            },
            zi = function(t, e, n, i) {
                if (!n || "none" === n) {
                    var r = wi(e, t, 1),
                        a = r && Ei(t, r, 1);
                    a && a !== n ? (e = r, n = a) : "borderColor" === e && (n = Ei(t, "borderTopColor"))
                }
                var s, o, l, c, h, u, d, p, f, m, g, _ = new Cn(this._pt, t.style, e, 0, 1, Tn),
                    v = 0,
                    x = 0;
                if (_.b = n, _.e = i, n += "", "auto" == (i += "") && (t.style[e] = i, i = Ei(t, e) || i, t.style[e] = n), He(s = [n, i]), i = s[1], l = (n = s[0]).match(at) || [], (i.match(at) || []).length) {
                    for (; o = at.exec(i);) d = o[0], f = i.substring(v, o.index), h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1), d !== (u = l[x++] || "") && (c = parseFloat(u) || 0, g = u.substr((c + "").length), "=" === d.charAt(1) && (d = It(c, d) + g), p = parseFloat(d), m = d.substr((p + "").length), v = at.lastIndex - m.length, m || (m = m || F.units[e] || g, v === i.length && (i += m, _.e += m)), g !== m && (c = Oi(t, e, u, m) || 0), _._pt = {
                        _next: _._pt,
                        p: f || 1 === x ? f : ",",
                        s: c,
                        c: p - c,
                        m: h && h < 4 || "zIndex" === e ? Math.round : 0
                    });
                    _.c = v < i.length ? i.substring(v, i.length) : ""
                } else _.r = "display" === e && "none" === i ? hi : ci;
                return ot.test(i) && (_.e = 0), this._pt = _, _
            },
            Bi = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            ki = function(t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, i, r, a = e.t,
                        s = a.style,
                        o = e.u,
                        l = a._gsap;
                    if ("all" === o || !0 === o) s.cssText = "", i = 1;
                    else
                        for (r = (o = o.split(",")).length; --r > -1;) n = o[r], Jn[n] && (i = 1, n = "transformOrigin" === n ? vi : _i), Ui(a, n);
                    i && (Ui(a, _i), l && (l.svg && a.removeAttribute("transform"), Yi(a, 1), l.uncache = 1, yi(s)))
                }
            },
            Hi = {
                clearProps: function(t, e, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var a = t._pt = new Cn(t._pt, e, n, 0, 0, ki);
                        return a.u = i, a.pr = -10, a.tween = r, t._props.push(n), 1
                    }
                }
            },
            Vi = [1, 0, 0, 1, 0, 0],
            Gi = {},
            Wi = function(t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            Xi = function(t) {
                var e = Ei(t, _i);
                return Wi(e) ? Vi : e.substr(7).match(rt).map(Ut)
            },
            qi = function(t, e) {
                var n, i, r, a, s = t._gsap || Ct(t),
                    o = t.style,
                    l = Xi(t);
                return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Vi : l : (l !== Vi || t.offsetParent || t === Xn || s.svg || (r = o.display, o.display = "block", (n = t.parentNode) && t.offsetParent || (a = 1, i = t.nextElementSibling, Xn.appendChild(t)), l = Xi(t), r ? o.display = r : Ui(t, "display"), a && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Xn.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            },
            ji = function(t, e, n, i, r, a) {
                var s, o, l, c = t._gsap,
                    h = r || qi(t, !0),
                    u = c.xOrigin || 0,
                    d = c.yOrigin || 0,
                    p = c.xOffset || 0,
                    f = c.yOffset || 0,
                    m = h[0],
                    g = h[1],
                    _ = h[2],
                    v = h[3],
                    x = h[4],
                    y = h[5],
                    M = e.split(" "),
                    S = parseFloat(M[0]) || 0,
                    T = parseFloat(M[1]) || 0;
                n ? h !== Vi && (o = m * v - g * _) && (l = S * (-g / o) + T * (m / o) - (m * y - g * x) / o, S = S * (v / o) + T * (-_ / o) + (_ * y - v * x) / o, T = l) : (S = (s = Pi(t)).x + (~M[0].indexOf("%") ? S / 100 * s.width : S), T = s.y + (~(M[1] || M[0]).indexOf("%") ? T / 100 * s.height : T)), i || !1 !== i && c.smooth ? (x = S - u, y = T - d, c.xOffset = p + (x * m + y * _) - x, c.yOffset = f + (x * g + y * v) - y) : c.xOffset = c.yOffset = 0, c.xOrigin = S, c.yOrigin = T, c.smooth = !!i, c.origin = e, c.originIsAbsolute = !!n, t.style[vi] = "0px 0px", a && (Di(a, c, "xOrigin", u, S), Di(a, c, "yOrigin", d, T), Di(a, c, "xOffset", p, c.xOffset), Di(a, c, "yOffset", f, c.yOffset)), t.setAttribute("data-svg-origin", S + " " + T)
            },
            Yi = function(t, e) {
                var n = t._gsap || new en(t);
                if ("x" in n && !e && !n.uncache) return n;
                var i, r, a, s, o, l, c, h, u, d, p, f, m, g, _, v, x, y, M, S, T, E, b, w, A, R, C, P, L, U, D, I, N = t.style,
                    O = n.scaleX < 0,
                    z = "px",
                    B = "deg",
                    k = getComputedStyle(t),
                    H = Ei(t, vi) || "0";
                return i = r = a = l = c = h = u = d = p = 0, s = o = 1, n.svg = !(!t.getCTM || !Li(t)), k.translate && ("none" === k.translate && "none" === k.scale && "none" === k.rotate || (N[_i] = ("none" !== k.translate ? "translate3d(" + (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") + ("none" !== k.scale ? "scale(" + k.scale.split(" ").join(",") + ") " : "") + ("none" !== k[_i] ? k[_i] : "")), N.scale = N.rotate = N.translate = "none"), g = qi(t, n.svg), n.svg && (n.uncache ? (A = t.getBBox(), H = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px", w = "") : w = !e && t.getAttribute("data-svg-origin"), ji(t, w || H, !!w || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== Vi && (y = g[0], M = g[1], S = g[2], T = g[3], i = E = g[4], r = b = g[5], 6 === g.length ? (s = Math.sqrt(y * y + M * M), o = Math.sqrt(T * T + S * S), l = y || M ? ti(M, y) * Qn : 0, (u = S || T ? ti(S, T) * Qn + l : 0) && (o *= Math.abs(Math.cos(u * $n))), n.svg && (i -= f - (f * y + m * S), r -= m - (f * M + m * T))) : (I = g[6], U = g[7], C = g[8], P = g[9], L = g[10], D = g[11], i = g[12], r = g[13], a = g[14], c = (_ = ti(I, L)) * Qn, _ && (w = E * (v = Math.cos(-_)) + C * (x = Math.sin(-_)), A = b * v + P * x, R = I * v + L * x, C = E * -x + C * v, P = b * -x + P * v, L = I * -x + L * v, D = U * -x + D * v, E = w, b = A, I = R), h = (_ = ti(-S, L)) * Qn, _ && (v = Math.cos(-_), D = T * (x = Math.sin(-_)) + D * v, y = w = y * v - C * x, M = A = M * v - P * x, S = R = S * v - L * x), l = (_ = ti(M, y)) * Qn, _ && (w = y * (v = Math.cos(_)) + M * (x = Math.sin(_)), A = E * v + b * x, M = M * v - y * x, b = b * v - E * x, y = w, E = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, h = 180 - h), s = Ut(Math.sqrt(y * y + M * M + S * S)), o = Ut(Math.sqrt(b * b + I * I)), _ = ti(E, b), u = Math.abs(_) > 2e-4 ? _ * Qn : 0, p = D ? 1 / (D < 0 ? -D : D) : 0), n.svg && (w = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Wi(Ei(t, _i)), w && t.setAttribute("transform", w))), Math.abs(u) > 90 && Math.abs(u) < 270 && (O ? (s *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), e = e || n.uncache, n.x = i - ((n.xPercent = i && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + z, n.y = r - ((n.yPercent = r && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + z, n.z = a + z, n.scaleX = Ut(s), n.scaleY = Ut(o), n.rotation = Ut(l) + B, n.rotationX = Ut(c) + B, n.rotationY = Ut(h) + B, n.skewX = u + B, n.skewY = d + B, n.transformPerspective = p + z, (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (N[vi] = Ki(H)), n.xOffset = n.yOffset = 0, n.force3D = F.force3D, n.renderTransform = n.svg ? nr : Zn ? er : Ji, n.uncache = 0, n
            },
            Ki = function(t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            Zi = function(t, e, n) {
                var i = me(e);
                return Ut(parseFloat(e) + parseFloat(Oi(t, "x", n + "px", i))) + i
            },
            Ji = function(t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, er(t, e)
            },
            Qi = "0deg",
            $i = "0px",
            tr = ") ",
            er = function(t, e) {
                var n = e || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    a = n.x,
                    s = n.y,
                    o = n.z,
                    l = n.rotation,
                    c = n.rotationY,
                    h = n.rotationX,
                    u = n.skewX,
                    d = n.skewY,
                    p = n.scaleX,
                    f = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    _ = n.target,
                    v = n.zOrigin,
                    x = "",
                    y = "auto" === g && t && 1 !== t || !0 === g;
                if (v && (h !== Qi || c !== Qi)) {
                    var M, S = parseFloat(c) * $n,
                        T = Math.sin(S),
                        E = Math.cos(S);
                    S = parseFloat(h) * $n, M = Math.cos(S), a = Zi(_, a, T * M * -v), s = Zi(_, s, -Math.sin(S) * -v), o = Zi(_, o, E * M * -v + v)
                }
                m !== $i && (x += "perspective(" + m + tr), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (y || a !== $i || s !== $i || o !== $i) && (x += o !== $i || y ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + tr), l !== Qi && (x += "rotate(" + l + tr), c !== Qi && (x += "rotateY(" + c + tr), h !== Qi && (x += "rotateX(" + h + tr), u === Qi && d === Qi || (x += "skew(" + u + ", " + d + tr), 1 === p && 1 === f || (x += "scale(" + p + ", " + f + tr), _.style[_i] = x || "translate(0, 0)"
            },
            nr = function(t, e) {
                var n, i, r, a, s, o = e || this,
                    l = o.xPercent,
                    c = o.yPercent,
                    h = o.x,
                    u = o.y,
                    d = o.rotation,
                    p = o.skewX,
                    f = o.skewY,
                    m = o.scaleX,
                    g = o.scaleY,
                    _ = o.target,
                    v = o.xOrigin,
                    x = o.yOrigin,
                    y = o.xOffset,
                    M = o.yOffset,
                    S = o.forceCSS,
                    T = parseFloat(h),
                    E = parseFloat(u);
                d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= $n, p *= $n, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, a = Math.cos(d - p) * g, p && (f *= $n, s = Math.tan(p - f), r *= s = Math.sqrt(1 + s * s), a *= s, f && (s = Math.tan(f), n *= s = Math.sqrt(1 + s * s), i *= s)), n = Ut(n), i = Ut(i), r = Ut(r), a = Ut(a)) : (n = m, a = g, i = r = 0), (T && !~(h + "").indexOf("px") || E && !~(u + "").indexOf("px")) && (T = Oi(_, "x", h, "px"), E = Oi(_, "y", u, "px")), (v || x || y || M) && (T = Ut(T + v - (v * n + x * r) + y), E = Ut(E + x - (v * i + x * a) + M)), (l || c) && (s = _.getBBox(), T = Ut(T + l / 100 * s.width), E = Ut(E + c / 100 * s.height)), s = "matrix(" + n + "," + i + "," + r + "," + a + "," + T + "," + E + ")", _.setAttribute("transform", s), S && (_.style[_i] = s)
            },
            ir = function(t, e, n, i, r) {
                var a, s, o = 360,
                    l = j(r),
                    c = parseFloat(r) * (l && ~r.indexOf("rad") ? Qn : 1) - i,
                    h = i + c + "deg";
                return l && ("short" === (a = r.split("_")[1]) && (c %= o) != c % 180 && (c += c < 0 ? o : -360), "cw" === a && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === a && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)), t._pt = s = new Cn(t._pt, e, n, i, c, si), s.e = h, s.u = "deg", t._props.push(n), s
            },
            rr = function(t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            ar = function(t, e, n) {
                var i, r, a, s, o, l, c, h = rr({}, n._gsap),
                    u = n.style;
                for (r in h.svg ? (a = n.getAttribute("transform"), n.setAttribute("transform", ""), u[_i] = e, i = Yi(n, 1), Ui(n, _i), n.setAttribute("transform", a)) : (a = getComputedStyle(n)[_i], u[_i] = e, i = Yi(n, 1), u[_i] = a), Jn)(a = h[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = me(a) !== (c = me(s)) ? Oi(n, r, a, c) : parseFloat(a), l = parseFloat(s), t._pt = new Cn(t._pt, i, r, o, l - o, ai), t._pt.u = c || 0, t._props.push(r));
                rr(i, h)
            };
        Lt("padding,margin,Width,Radius", (function(t, e) {
            var n = "Top",
                i = "Right",
                r = "Bottom",
                a = "Left",
                s = (e < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map((function(n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            Hi[e > 1 ? "border" + t : t] = function(t, e, n, i, r) {
                var a, o;
                if (arguments.length < 4) return a = s.map((function(e) {
                    return Fi(t, e, n)
                })), 5 === (o = a.join(" ")).split(a[0]).length ? a[0] : o;
                a = (i + "").split(" "), o = {}, s.forEach((function(t, e) {
                    return o[t] = a[e] = a[e] || a[(e - 1) / 2 | 0]
                })), t.init(e, o, r)
            }
        }));
        var sr, or, lr = {
            name: "css",
            register: Ai,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, n, i, r) {
                var a, s, o, l, c, h, u, d, p, f, m, g, _, v, x, y, M, S, T, E, b = this._props,
                    w = t.style,
                    A = n.vars.startAt;
                for (u in qn || Ai(), this.styles = this.styles || Si(t), y = this.styles.props, this.tween = n, e)
                    if ("autoRound" !== u && (s = e[u], !Tt[u] || !cn(u, e, n, i, t, r)))
                        if (c = typeof s, h = Hi[u], "function" === c && (c = typeof(s = s.call(n, i, t, r))), "string" === c && ~s.indexOf("random(") && (s = we(s)), h) h(this, t, u, s, n) && (x = 1);
                        else if ("--" === u.substr(0, 2)) a = (getComputedStyle(t).getPropertyValue(u) + "").trim(), s += "", Be.lastIndex = 0, Be.test(a) || (d = me(a), p = me(s)), p ? d !== p && (a = Oi(t, u, a, p) + p) : d && (s += d), this.add(w, "setProperty", a, s, i, r, 0, 0, u), b.push(u), y.push(u, 0, w[u]);
                else if ("undefined" !== c) {
                    if (A && u in A ? (a = "function" == typeof A[u] ? A[u].call(n, i, t, r) : A[u], j(a) && ~a.indexOf("random(") && (a = we(a)), me(a + "") || (a += F.units[u] || me(Fi(t, u)) || ""), "=" === (a + "").charAt(1) && (a = Fi(t, u))) : a = Fi(t, u), l = parseFloat(a), (f = "string" === c && "=" === s.charAt(1) && s.substr(0, 2)) && (s = s.substr(2)), o = parseFloat(s), u in ri && ("autoAlpha" === u && (1 === l && "hidden" === Fi(t, "visibility") && o && (l = 0), y.push("visibility", 0, w.visibility), Di(this, w, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== u && "transform" !== u && ~(u = ri[u]).indexOf(",") && (u = u.split(",")[0])), m = u in Jn)
                        if (this.styles.save(u), g || ((_ = t._gsap).renderTransform && !e.parseTransform || Yi(t, e.parseTransform), v = !1 !== e.smoothOrigin && _.smooth, (g = this._pt = new Cn(this._pt, w, _i, 0, 1, _.renderTransform, _, 0, -1)).dep = 1), "scale" === u) this._pt = new Cn(this._pt, _, "scaleY", _.scaleY, (f ? It(_.scaleY, f + o) : o) - _.scaleY || 0, ai), this._pt.u = 0, b.push("scaleY", u), u += "X";
                        else {
                            if ("transformOrigin" === u) {
                                y.push(vi, 0, w[vi]), S = void 0, T = void 0, E = void 0, T = (S = (M = s).split(" "))[0], E = S[1] || "50%", "top" !== T && "bottom" !== T && "left" !== E && "right" !== E || (M = T, T = E, E = M), S[0] = Bi[T] || T, S[1] = Bi[E] || E, s = S.join(" "), _.svg ? ji(t, s, 0, v, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== _.zOrigin && Di(this, _, "zOrigin", _.zOrigin, p), Di(this, w, u, Ki(a), Ki(s)));
                                continue
                            }
                            if ("svgOrigin" === u) {
                                ji(t, s, 1, v, 0, this);
                                continue
                            }
                            if (u in Gi) {
                                ir(this, _, u, l, f ? It(l, f + s) : s);
                                continue
                            }
                            if ("smoothOrigin" === u) {
                                Di(this, _, "smooth", _.smooth, s);
                                continue
                            }
                            if ("force3D" === u) {
                                _[u] = s;
                                continue
                            }
                            if ("transform" === u) {
                                ar(this, s, t);
                                continue
                            }
                        }
                    else u in w || (u = wi(u) || u);
                    if (m || (o || 0 === o) && (l || 0 === l) && !ii.test(s) && u in w) o || (o = 0), (d = (a + "").substr((l + "").length)) !== (p = me(s) || (u in F.units ? F.units[u] : d)) && (l = Oi(t, u, a, p)), this._pt = new Cn(this._pt, m ? _ : w, u, l, (f ? It(l, f + o) : o) - l, m || "px" !== p && "zIndex" !== u || !1 === e.autoRound ? ai : li), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = a, this._pt.r = oi);
                    else if (u in w) zi.call(this, t, u, a, f ? f + s : s);
                    else if (u in t) this.add(t, u, a || t[u], f ? f + s : s, i, r);
                    else if ("parseTransform" !== u) {
                        pt(u, s);
                        continue
                    }
                    m || (u in w ? y.push(u, 0, w[u]) : y.push(u, 1, a || t[u])), b.push(u)
                }
                x && Rn(this)
            },
            render: function(t, e) {
                if (e.tween._time || !Kn())
                    for (var n = e._pt; n;) n.r(t, n.d), n = n._next;
                else e.styles.revert()
            },
            get: Fi,
            aliases: ri,
            getSetter: function(t, e, n) {
                var i = ri[e];
                return i && i.indexOf(",") < 0 && (e = i), e in Jn && e !== vi && (t._gsap.x || Fi(t, "x")) ? n && Yn === n ? "scale" === e ? fi : pi : (Yn = n || {}) && ("scale" === e ? mi : gi) : t.style && !Z(t.style[e]) ? ui : ~e.indexOf("-") ? di : yn(t, e)
            },
            core: {
                _removeProperty: Ui,
                _getMatrix: qi
            }
        };
        Vn.utils.checkPrefix = wi, Vn.core.getStyleSaver = Si, or = Lt("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (sr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
            Jn[t] = 1
        })), Lt(sr, (function(t) {
            F.units[t] = "deg", Gi[t] = 1
        })), ri[or[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + sr, Lt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
            var e = t.split(":");
            ri[e[1]] = or[e[0]]
        })), Lt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
            F.units[t] = "px"
        })), Vn.registerPlugin(lr);
        var cr = Vn.registerPlugin(lr) || Vn;
        cr.core.Tween;
        var hr, ur, dr, pr, fr, mr, gr, _r, vr, xr, yr, Mr, Sr, Tr = function() {
                return hr || "undefined" != typeof window && (hr = window.gsap) && hr.registerPlugin && hr
            },
            Er = 1,
            br = [],
            wr = [],
            Ar = [],
            Rr = Date.now,
            Cr = function(t, e) {
                return e
            },
            Pr = function(t, e) {
                return ~Ar.indexOf(t) && Ar[Ar.indexOf(t) + 1][e]
            },
            Lr = function(t) {
                return !!~xr.indexOf(t)
            },
            Ur = function(t, e, n, i, r) {
                return t.addEventListener(e, n, {
                    passive: !i,
                    capture: !!r
                })
            },
            Dr = function(t, e, n, i) {
                return t.removeEventListener(e, n, !!i)
            },
            Ir = "scrollLeft",
            Nr = "scrollTop",
            Or = function() {
                return yr && yr.isPressed || wr.cache++
            },
            Fr = function(t, e) {
                var n = function n(i) {
                    if (i || 0 === i) {
                        Er && (dr.history.scrollRestoration = "manual");
                        var r = yr && yr.isPressed;
                        i = n.v = Math.round(i) || (yr && yr.iOS ? 1 : 0), t(i), n.cacheID = wr.cache, r && Cr("ss", i)
                    } else(e || wr.cache !== n.cacheID || Cr("ref")) && (n.cacheID = wr.cache, n.v = t());
                    return n.v + n.offset
                };
                return n.offset = 0, t && n
            },
            zr = {
                s: Ir,
                p: "left",
                p2: "Left",
                os: "right",
                os2: "Right",
                d: "width",
                d2: "Width",
                a: "x",
                sc: Fr((function(t) {
                    return arguments.length ? dr.scrollTo(t, Br.sc()) : dr.pageXOffset || pr[Ir] || fr[Ir] || mr[Ir] || 0
                }))
            },
            Br = {
                s: Nr,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: zr,
                sc: Fr((function(t) {
                    return arguments.length ? dr.scrollTo(zr.sc(), t) : dr.pageYOffset || pr[Nr] || fr[Nr] || mr[Nr] || 0
                }))
            },
            kr = function(t, e) {
                return (e && e._ctx && e._ctx.selector || hr.utils.toArray)(t)[0] || ("string" == typeof t && !1 !== hr.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
            },
            Hr = function(t, e) {
                var n = e.s,
                    i = e.sc;
                Lr(t) && (t = pr.scrollingElement || fr);
                var r = wr.indexOf(t),
                    a = i === Br.sc ? 1 : 2;
                !~r && (r = wr.push(t) - 1), wr[r + a] || Ur(t, "scroll", Or);
                var s = wr[r + a],
                    o = s || (wr[r + a] = Fr(Pr(t, n), !0) || (Lr(t) ? i : Fr((function(e) {
                        return arguments.length ? t[n] = e : t[n]
                    }))));
                return o.target = t, s || (o.smooth = "smooth" === hr.getProperty(t, "scrollBehavior")), o
            },
            Vr = function(t, e, n) {
                var i = t,
                    r = t,
                    a = Rr(),
                    s = a,
                    o = e || 50,
                    l = Math.max(500, 3 * o),
                    c = function(t, e) {
                        var l = Rr();
                        e || l - a > o ? (r = i, i = t, s = a, a = l) : n ? i += t : i = r + (t - r) / (l - s) * (a - s)
                    };
                return {
                    update: c,
                    reset: function() {
                        r = i = n ? 0 : i, s = a = 0
                    },
                    getVelocity: function(t) {
                        var e = s,
                            o = r,
                            h = Rr();
                        return (t || 0 === t) && t !== i && c(t), a === s || h - s > l ? 0 : (i + (n ? o : -o)) / ((n ? h : a) - e) * 1e3
                    }
                }
            },
            Gr = function(t, e) {
                return e && !t._gsapAllow && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t
            },
            Wr = function(t) {
                var e = Math.max.apply(Math, t),
                    n = Math.min.apply(Math, t);
                return Math.abs(e) >= Math.abs(n) ? e : n
            },
            Xr = function() {
                var t, e, n, i;
                (vr = hr.core.globals().ScrollTrigger) && vr.core && (t = vr.core, e = t.bridge || {}, n = t._scrollers, i = t._proxies, n.push.apply(n, wr), i.push.apply(i, Ar), wr = n, Ar = i, Cr = function(t, n) {
                    return e[t](n)
                })
            },
            qr = function(t) {
                return (hr = t || Tr()) && "undefined" != typeof document && document.body && (dr = window, pr = document, fr = pr.documentElement, mr = pr.body, xr = [dr, pr, fr, mr], hr.utils.clamp, Sr = hr.core.context || function() {}, _r = "onpointerenter" in mr ? "pointer" : "mouse", gr = jr.isTouch = dr.matchMedia && dr.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in dr || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Mr = jr.eventTypes = ("ontouchstart" in fr ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in fr ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function() {
                    return Er = 0
                }), 500), Xr(), ur = 1), ur
            };
        zr.op = Br, wr.cache = 0;
        var jr = function() {
            function t(t) {
                this.init(t)
            }
            var e;
            return t.prototype.init = function(t) {
                ur || qr(hr) || console.warn("Please gsap.registerPlugin(Observer)"), vr || Xr();
                var e = t.tolerance,
                    n = t.dragMinimum,
                    i = t.type,
                    r = t.target,
                    a = t.lineHeight,
                    s = t.debounce,
                    o = t.preventDefault,
                    l = t.onStop,
                    c = t.onStopDelay,
                    h = t.ignore,
                    u = t.wheelSpeed,
                    d = t.event,
                    p = t.onDragStart,
                    f = t.onDragEnd,
                    m = t.onDrag,
                    g = t.onPress,
                    _ = t.onRelease,
                    v = t.onRight,
                    x = t.onLeft,
                    y = t.onUp,
                    M = t.onDown,
                    S = t.onChangeX,
                    T = t.onChangeY,
                    E = t.onChange,
                    b = t.onToggleX,
                    w = t.onToggleY,
                    A = t.onHover,
                    R = t.onHoverEnd,
                    C = t.onMove,
                    P = t.ignoreCheck,
                    L = t.isNormalizer,
                    U = t.onGestureStart,
                    D = t.onGestureEnd,
                    I = t.onWheel,
                    N = t.onEnable,
                    O = t.onDisable,
                    F = t.onClick,
                    z = t.scrollSpeed,
                    B = t.capture,
                    k = t.allowClicks,
                    H = t.lockAxis,
                    V = t.onLockAxis;
                this.target = r = kr(r) || fr, this.vars = t, h && (h = hr.utils.toArray(h)), e = e || 1e-9, n = n || 0, u = u || 1, z = z || 1, i = i || "wheel,touch,pointer", s = !1 !== s, a || (a = parseFloat(dr.getComputedStyle(mr).lineHeight) || 22);
                var G, W, X, q, j, Y, K, Z = this,
                    J = 0,
                    Q = 0,
                    $ = Hr(r, zr),
                    tt = Hr(r, Br),
                    et = $(),
                    nt = tt(),
                    it = ~i.indexOf("touch") && !~i.indexOf("pointer") && "pointerdown" === Mr[0],
                    rt = Lr(r),
                    at = r.ownerDocument || pr,
                    st = [0, 0, 0],
                    ot = [0, 0, 0],
                    lt = 0,
                    ct = function() {
                        return lt = Rr()
                    },
                    ht = function(t, e) {
                        return (Z.event = t) && h && ~h.indexOf(t.target) || e && it && "touch" !== t.pointerType || P && P(t, e)
                    },
                    ut = function() {
                        var t = Z.deltaX = Wr(st),
                            n = Z.deltaY = Wr(ot),
                            i = Math.abs(t) >= e,
                            r = Math.abs(n) >= e;
                        E && (i || r) && E(Z, t, n, st, ot), i && (v && Z.deltaX > 0 && v(Z), x && Z.deltaX < 0 && x(Z), S && S(Z), b && Z.deltaX < 0 != J < 0 && b(Z), J = Z.deltaX, st[0] = st[1] = st[2] = 0), r && (M && Z.deltaY > 0 && M(Z), y && Z.deltaY < 0 && y(Z), T && T(Z), w && Z.deltaY < 0 != Q < 0 && w(Z), Q = Z.deltaY, ot[0] = ot[1] = ot[2] = 0), (q || X) && (C && C(Z), X && (m(Z), X = !1), q = !1), Y && !(Y = !1) && V && V(Z), j && (I(Z), j = !1), G = 0
                    },
                    dt = function(t, e, n) {
                        st[n] += t, ot[n] += e, Z._vx.update(t), Z._vy.update(e), s ? G || (G = requestAnimationFrame(ut)) : ut()
                    },
                    pt = function(t, e) {
                        H && !K && (Z.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y", Y = !0), "y" !== K && (st[2] += t, Z._vx.update(t, !0)), "x" !== K && (ot[2] += e, Z._vy.update(e, !0)), s ? G || (G = requestAnimationFrame(ut)) : ut()
                    },
                    ft = function(t) {
                        if (!ht(t, 1)) {
                            var e = (t = Gr(t, o)).clientX,
                                i = t.clientY,
                                r = e - Z.x,
                                a = i - Z.y,
                                s = Z.isDragging;
                            Z.x = e, Z.y = i, (s || Math.abs(Z.startX - e) >= n || Math.abs(Z.startY - i) >= n) && (m && (X = !0), s || (Z.isDragging = !0), pt(r, a), s || p && p(Z))
                        }
                    },
                    mt = Z.onPress = function(t) {
                        ht(t, 1) || t && t.button || (Z.axis = K = null, W.pause(), Z.isPressed = !0, t = Gr(t), J = Q = 0, Z.startX = Z.x = t.clientX, Z.startY = Z.y = t.clientY, Z._vx.reset(), Z._vy.reset(), Ur(L ? r : at, Mr[1], ft, o, !0), Z.deltaX = Z.deltaY = 0, g && g(Z))
                    },
                    gt = Z.onRelease = function(t) {
                        if (!ht(t, 1)) {
                            Dr(L ? r : at, Mr[1], ft, !0);
                            var e = !isNaN(Z.y - Z.startY),
                                n = Z.isDragging && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3),
                                i = Gr(t);
                            !n && e && (Z._vx.reset(), Z._vy.reset(), o && k && hr.delayedCall(.08, (function() {
                                if (Rr() - lt > 300 && !t.defaultPrevented)
                                    if (t.target.click) t.target.click();
                                    else if (at.createEvent) {
                                    var e = at.createEvent("MouseEvents");
                                    e.initMouseEvent("click", !0, !0, dr, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e)
                                }
                            }))), Z.isDragging = Z.isGesturing = Z.isPressed = !1, l && !L && W.restart(!0), f && n && f(Z), _ && _(Z, n)
                        }
                    },
                    _t = function(t) {
                        return t.touches && t.touches.length > 1 && (Z.isGesturing = !0) && U(t, Z.isDragging)
                    },
                    vt = function() {
                        return (Z.isGesturing = !1) || D(Z)
                    },
                    xt = function(t) {
                        if (!ht(t)) {
                            var e = $(),
                                n = tt();
                            dt((e - et) * z, (n - nt) * z, 1), et = e, nt = n, l && W.restart(!0)
                        }
                    },
                    yt = function(t) {
                        if (!ht(t)) {
                            t = Gr(t, o), I && (j = !0);
                            var e = (1 === t.deltaMode ? a : 2 === t.deltaMode ? dr.innerHeight : 1) * u;
                            dt(t.deltaX * e, t.deltaY * e, 0), l && !L && W.restart(!0)
                        }
                    },
                    Mt = function(t) {
                        if (!ht(t)) {
                            var e = t.clientX,
                                n = t.clientY,
                                i = e - Z.x,
                                r = n - Z.y;
                            Z.x = e, Z.y = n, q = !0, (i || r) && pt(i, r)
                        }
                    },
                    St = function(t) {
                        Z.event = t, A(Z)
                    },
                    Tt = function(t) {
                        Z.event = t, R(Z)
                    },
                    Et = function(t) {
                        return ht(t) || Gr(t, o) && F(Z)
                    };
                W = Z._dc = hr.delayedCall(c || .25, (function() {
                    Z._vx.reset(), Z._vy.reset(), W.pause(), l && l(Z)
                })).pause(), Z.deltaX = Z.deltaY = 0, Z._vx = Vr(0, 50, !0), Z._vy = Vr(0, 50, !0), Z.scrollX = $, Z.scrollY = tt, Z.isDragging = Z.isGesturing = Z.isPressed = !1, Sr(this), Z.enable = function(t) {
                    return Z.isEnabled || (Ur(rt ? at : r, "scroll", Or), i.indexOf("scroll") >= 0 && Ur(rt ? at : r, "scroll", xt, o, B), i.indexOf("wheel") >= 0 && Ur(r, "wheel", yt, o, B), (i.indexOf("touch") >= 0 && gr || i.indexOf("pointer") >= 0) && (Ur(r, Mr[0], mt, o, B), Ur(at, Mr[2], gt), Ur(at, Mr[3], gt), k && Ur(r, "click", ct, !1, !0), F && Ur(r, "click", Et), U && Ur(at, "gesturestart", _t), D && Ur(at, "gestureend", vt), A && Ur(r, _r + "enter", St), R && Ur(r, _r + "leave", Tt), C && Ur(r, _r + "move", Mt)), Z.isEnabled = !0, t && t.type && mt(t), N && N(Z)), Z
                }, Z.disable = function() {
                    Z.isEnabled && (br.filter((function(t) {
                        return t !== Z && Lr(t.target)
                    })).length || Dr(rt ? at : r, "scroll", Or), Z.isPressed && (Z._vx.reset(), Z._vy.reset(), Dr(L ? r : at, Mr[1], ft, !0)), Dr(rt ? at : r, "scroll", xt, B), Dr(r, "wheel", yt, B), Dr(r, Mr[0], mt, B), Dr(at, Mr[2], gt), Dr(at, Mr[3], gt), Dr(r, "click", ct, !0), Dr(r, "click", Et), Dr(at, "gesturestart", _t), Dr(at, "gestureend", vt), Dr(r, _r + "enter", St), Dr(r, _r + "leave", Tt), Dr(r, _r + "move", Mt), Z.isEnabled = Z.isPressed = Z.isDragging = !1, O && O(Z))
                }, Z.kill = Z.revert = function() {
                    Z.disable();
                    var t = br.indexOf(Z);
                    t >= 0 && br.splice(t, 1), yr === Z && (yr = 0)
                }, br.push(Z), L && Lr(r) && (yr = Z), Z.enable(d)
            }, (e = [{
                key: "velocityX",
                get: function() {
                    return this._vx.getVelocity()
                }
            }, {
                key: "velocityY",
                get: function() {
                    return this._vy.getVelocity()
                }
            }]) && function(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }(t.prototype, e), t
        }();
        jr.version = "3.12.2", jr.create = function(t) {
            return new jr(t)
        }, jr.register = qr, jr.getAll = function() {
            return br.slice()
        }, jr.getById = function(t) {
            return br.filter((function(e) {
                return e.vars.id === t
            }))[0]
        }, Tr() && hr.registerPlugin(jr);
        var Yr, Kr, Zr, Jr, Qr, $r, ta, ea, na, ia, ra, aa, sa, oa, la, ca, ha, ua, da, pa, fa, ma, ga, _a, va, xa, ya, Ma, Sa, Ta, Ea, ba, wa, Aa, Ra, Ca, Pa = 1,
            La = Date.now,
            Ua = La(),
            Da = 0,
            Ia = 0,
            Na = function(t, e, n) {
                var i = Ka(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
                return n["_" + e + "Clamp"] = i, i ? t.substr(6, t.length - 7) : t
            },
            Oa = function(t, e) {
                return !e || Ka(t) && "clamp(" === t.substr(0, 6) ? t : "clamp(" + t + ")"
            },
            Fa = function t() {
                return Ia && requestAnimationFrame(t)
            },
            za = function() {
                return oa = 1
            },
            Ba = function() {
                return oa = 0
            },
            ka = function(t) {
                return t
            },
            Ha = function(t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            Va = function() {
                return "undefined" != typeof window
            },
            Ga = function() {
                return Yr || Va() && (Yr = window.gsap) && Yr.registerPlugin && Yr
            },
            Wa = function(t) {
                return !!~ta.indexOf(t)
            },
            Xa = function(t) {
                return ("Height" === t ? Ea : Zr["inner" + t]) || Qr["client" + t] || $r["client" + t]
            },
            qa = function(t) {
                return Pr(t, "getBoundingClientRect") || (Wa(t) ? function() {
                    return ro.width = Zr.innerWidth, ro.height = Ea, ro
                } : function() {
                    return vs(t)
                })
            },
            ja = function(t, e) {
                var n = e.s,
                    i = e.d2,
                    r = e.d,
                    a = e.a;
                return Math.max(0, (n = "scroll" + i) && (a = Pr(t, n)) ? a() - qa(t)()[r] : Wa(t) ? (Qr[n] || $r[n]) - Xa(i) : t[n] - t["offset" + i])
            },
            Ya = function(t, e) {
                for (var n = 0; n < da.length; n += 3)(!e || ~e.indexOf(da[n + 1])) && t(da[n], da[n + 1], da[n + 2])
            },
            Ka = function(t) {
                return "string" == typeof t
            },
            Za = function(t) {
                return "function" == typeof t
            },
            Ja = function(t) {
                return "number" == typeof t
            },
            Qa = function(t) {
                return "object" == typeof t
            },
            $a = function(t, e, n) {
                return t && t.progress(e ? 0 : 1) && n && t.pause()
            },
            ts = function(t, e) {
                if (t.enabled) {
                    var n = e(t);
                    n && n.totalTime && (t.callbackAnimation = n)
                }
            },
            es = Math.abs,
            ns = "left",
            is = "right",
            rs = "bottom",
            as = "width",
            ss = "height",
            os = "Right",
            ls = "Left",
            cs = "Top",
            hs = "Bottom",
            us = "padding",
            ds = "margin",
            ps = "Width",
            fs = "Height",
            ms = "px",
            gs = function(t) {
                return Zr.getComputedStyle(t)
            },
            _s = function(t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            vs = function(t, e) {
                var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== gs(t)[la] && Yr.to(t, {
                        x: 0,
                        y: 0,
                        xPercent: 0,
                        yPercent: 0,
                        rotation: 0,
                        rotationX: 0,
                        rotationY: 0,
                        scale: 1,
                        skewX: 0,
                        skewY: 0
                    }).progress(1),
                    i = t.getBoundingClientRect();
                return n && n.progress(0).kill(), i
            },
            xs = function(t, e) {
                var n = e.d2;
                return t["offset" + n] || t["client" + n] || 0
            },
            ys = function(t) {
                var e, n = [],
                    i = t.labels,
                    r = t.duration();
                for (e in i) n.push(i[e] / r);
                return n
            },
            Ms = function(t) {
                var e = Yr.utils.snap(t),
                    n = Array.isArray(t) && t.slice(0).sort((function(t, e) {
                        return t - e
                    }));
                return n ? function(t, i, r) {
                    var a;
                    if (void 0 === r && (r = .001), !i) return e(t);
                    if (i > 0) {
                        for (t -= r, a = 0; a < n.length; a++)
                            if (n[a] >= t) return n[a];
                        return n[a - 1]
                    }
                    for (a = n.length, t += r; a--;)
                        if (n[a] <= t) return n[a];
                    return n[0]
                } : function(n, i, r) {
                    void 0 === r && (r = .001);
                    var a = e(n);
                    return !i || Math.abs(a - n) < r || a - n < 0 == i < 0 ? a : e(i < 0 ? n - t : n + t)
                }
            },
            Ss = function(t, e, n, i) {
                return n.split(",").forEach((function(n) {
                    return t(e, n, i)
                }))
            },
            Ts = function(t, e, n, i, r) {
                return t.addEventListener(e, n, {
                    passive: !i,
                    capture: !!r
                })
            },
            Es = function(t, e, n, i) {
                return t.removeEventListener(e, n, !!i)
            },
            bs = function(t, e, n) {
                (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n))
            },
            ws = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            },
            As = {
                toggleActions: "play",
                anticipatePin: 0
            },
            Rs = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            },
            Cs = function(t, e) {
                if (Ka(t)) {
                    var n = t.indexOf("="),
                        i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
                    ~n && (t.indexOf("%") > n && (i *= e / 100), t = t.substr(0, n - 1)), t = i + (t in Rs ? Rs[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
                }
                return t
            },
            Ps = function(t, e, n, i, r, a, s, o) {
                var l = r.startColor,
                    c = r.endColor,
                    h = r.fontSize,
                    u = r.indent,
                    d = r.fontWeight,
                    p = Jr.createElement("div"),
                    f = Wa(n) || "fixed" === Pr(n, "pinType"),
                    m = -1 !== t.indexOf("scroller"),
                    g = f ? $r : n,
                    _ = -1 !== t.indexOf("start"),
                    v = _ ? l : c,
                    x = "border-color:" + v + ";font-size:" + h + ";color:" + v + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return x += "position:" + ((m || o) && f ? "fixed;" : "absolute;"), (m || o || !f) && (x += (i === Br ? is : rs) + ":" + (a + parseFloat(u)) + "px;"), s && (x += "box-sizing:border-box;text-align:left;width:" + s.offsetWidth + "px;"), p._isStart = _, p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), p.style.cssText = x, p.innerText = e || 0 === e ? t + "-" + e : t, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + i.op.d2], Ls(p, 0, i, _), p
            },
            Ls = function(t, e, n, i) {
                var r = {
                        display: "block"
                    },
                    a = n[i ? "os2" : "p2"],
                    s = n[i ? "p2" : "os2"];
                t._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + a + ps] = 1, r["border" + s + ps] = 0, r[n.p] = e + "px", Yr.set(t, r)
            },
            Us = [],
            Ds = {},
            Is = function() {
                return La() - Da > 34 && (wa || (wa = requestAnimationFrame(Js)))
            },
            Ns = function() {
                (!ga || !ga.isPressed || ga.startX > $r.clientWidth) && (wr.cache++, ga ? wa || (wa = requestAnimationFrame(Js)) : Js(), Da || Hs("scrollStart"), Da = La())
            },
            Os = function() {
                xa = Zr.innerWidth, va = Zr.innerHeight
            },
            Fs = function() {
                wr.cache++, !sa && !ma && !Jr.fullscreenElement && !Jr.webkitFullscreenElement && (!_a || xa !== Zr.innerWidth || Math.abs(Zr.innerHeight - va) > .25 * Zr.innerHeight) && ea.restart(!0)
            },
            zs = {},
            Bs = [],
            ks = function t() {
                return Es(uo, "scrollEnd", t) || Ys(!0)
            },
            Hs = function(t) {
                return zs[t] && zs[t].map((function(t) {
                    return t()
                })) || Bs
            },
            Vs = [],
            Gs = function(t) {
                for (var e = 0; e < Vs.length; e += 5)(!t || Vs[e + 4] && Vs[e + 4].query === t) && (Vs[e].style.cssText = Vs[e + 1], Vs[e].getBBox && Vs[e].setAttribute("transform", Vs[e + 2] || ""), Vs[e + 3].uncache = 1)
            },
            Ws = function(t, e) {
                var n;
                for (ca = 0; ca < Us.length; ca++) !(n = Us[ca]) || e && n._ctx !== e || (t ? n.kill(1) : n.revert(!0, !0));
                e && Gs(e), e || Hs("revert")
            },
            Xs = function(t, e) {
                wr.cache++, (e || !Aa) && wr.forEach((function(t) {
                    return Za(t) && t.cacheID++ && (t.rec = 0)
                })), Ka(t) && (Zr.history.scrollRestoration = Sa = t)
            },
            qs = 0,
            js = function() {
                $r.appendChild(Ta), Ea = Ta.offsetHeight || Zr.innerHeight, $r.removeChild(Ta)
            },
            Ys = function(t, e) {
                if (!Da || t) {
                    js(), Aa = uo.isRefreshing = !0, wr.forEach((function(t) {
                        return Za(t) && ++t.cacheID && (t.rec = t())
                    }));
                    var n = Hs("refreshInit");
                    pa && uo.sort(), e || Ws(), wr.forEach((function(t) {
                        Za(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0))
                    })), Us.slice(0).forEach((function(t) {
                        return t.refresh()
                    })), Us.forEach((function(t, e) {
                        if (t._subPinOffset && t.pin) {
                            var n = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                i = t.pin[n];
                            t.revert(!0, 1), t.adjustPinSpacing(t.pin[n] - i), t.refresh()
                        }
                    })), Us.forEach((function(t) {
                        var e = ja(t.scroller, t._dir);
                        ("max" === t.vars.end || t._endClamp && t.end > e) && t.setPositions(t.start, Math.max(t.start + 1, e), !0)
                    })), n.forEach((function(t) {
                        return t && t.render && t.render(-1)
                    })), wr.forEach((function(t) {
                        Za(t) && (t.smooth && requestAnimationFrame((function() {
                            return t.target.style.scrollBehavior = "smooth"
                        })), t.rec && t(t.rec))
                    })), Xs(Sa, 1), ea.pause(), qs++, Aa = 2, Js(2), Us.forEach((function(t) {
                        return Za(t.vars.onRefresh) && t.vars.onRefresh(t)
                    })), Aa = uo.isRefreshing = !1, Hs("refresh")
                } else Ts(uo, "scrollEnd", ks)
            },
            Ks = 0,
            Zs = 1,
            Js = function(t) {
                if (!Aa || 2 === t) {
                    uo.isUpdating = !0, Ca && Ca.update(0);
                    var e = Us.length,
                        n = La(),
                        i = n - Ua >= 50,
                        r = e && Us[0].scroll();
                    if (Zs = Ks > r ? -1 : 1, Aa || (Ks = r), i && (Da && !oa && n - Da > 200 && (Da = 0, Hs("scrollEnd")), ra = Ua, Ua = n), Zs < 0) {
                        for (ca = e; ca-- > 0;) Us[ca] && Us[ca].update(0, i);
                        Zs = 1
                    } else
                        for (ca = 0; ca < e; ca++) Us[ca] && Us[ca].update(0, i);
                    uo.isUpdating = !1
                }
                wa = 0
            },
            Qs = [ns, "top", rs, is, ds + hs, ds + os, ds + cs, ds + ls, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
            $s = Qs.concat([as, ss, "boxSizing", "max" + ps, "max" + fs, "position", ds, us, us + cs, us + os, us + hs, us + ls]),
            to = function(t, e, n, i) {
                if (!t._gsap.swappedIn) {
                    for (var r, a = Qs.length, s = e.style, o = t.style; a--;) s[r = Qs[a]] = n[r];
                    s.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (s.display = "inline-block"), o[rs] = o[is] = "auto", s.flexBasis = n.flexBasis || "auto", s.overflow = "visible", s.boxSizing = "border-box", s[as] = xs(t, zr) + ms, s[ss] = xs(t, Br) + ms, s[us] = o[ds] = o.top = o[ns] = "0", no(i), o[as] = o["max" + ps] = n[as], o[ss] = o["max" + fs] = n[ss], o[us] = n[us], t.parentNode !== e && (t.parentNode.insertBefore(e, t), e.appendChild(t)), t._gsap.swappedIn = !0
                }
            },
            eo = /([A-Z])/g,
            no = function(t) {
                if (t) {
                    var e, n, i = t.t.style,
                        r = t.length,
                        a = 0;
                    for ((t.t._gsap || Yr.core.getCache(t.t)).uncache = 1; a < r; a += 2) n = t[a + 1], e = t[a], n ? i[e] = n : i[e] && i.removeProperty(e.replace(eo, "-$1").toLowerCase())
                }
            },
            io = function(t) {
                for (var e = $s.length, n = t.style, i = [], r = 0; r < e; r++) i.push($s[r], n[$s[r]]);
                return i.t = t, i
            },
            ro = {
                left: 0,
                top: 0
            },
            ao = function(t, e, n, i, r, a, s, o, l, c, h, u, d, p) {
                Za(t) && (t = t(o)), Ka(t) && "max" === t.substr(0, 3) && (t = u + ("=" === t.charAt(4) ? Cs("0" + t.substr(3), n) : 0));
                var f, m, g, _ = d ? d.time() : 0;
                if (d && d.seek(0), isNaN(t) || (t = +t), Ja(t)) d && (t = Yr.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, u, t)), s && Ls(s, n, i, !0);
                else {
                    Za(e) && (e = e(o));
                    var v, x, y, M, S = (t || "0").split(" ");
                    g = kr(e, o) || $r, (v = vs(g) || {}) && (v.left || v.top) || "none" !== gs(g).display || (M = g.style.display, g.style.display = "block", v = vs(g), M ? g.style.display = M : g.style.removeProperty("display")), x = Cs(S[0], v[i.d]), y = Cs(S[1] || "0", n), t = v[i.p] - l[i.p] - c + x + r - y, s && Ls(s, y, i, n - y < 20 || s._isStart && y > 20), n -= n - y
                }
                if (p && (o[p] = t || -.001, t < 0 && (t = 0)), a) {
                    var T = t + n,
                        E = a._isStart;
                    f = "scroll" + i.d2, Ls(a, T, i, E && T > 20 || !E && (h ? Math.max($r[f], Qr[f]) : a.parentNode[f]) <= T + 1), h && (l = vs(s), h && (a.style[i.op.p] = l[i.op.p] - i.op.m - a._offset + ms))
                }
                return d && g && (f = vs(g), d.seek(u), m = vs(g), d._caScrollDist = f[i.p] - m[i.p], t = t / d._caScrollDist * u), d && d.seek(_), d ? t : Math.round(t)
            },
            so = /(webkit|moz|length|cssText|inset)/i,
            oo = function(t, e, n, i) {
                if (t.parentNode !== e) {
                    var r, a, s = t.style;
                    if (e === $r) {
                        for (r in t._stOrig = s.cssText, a = gs(t)) + r || so.test(r) || !a[r] || "string" != typeof s[r] || "0" === r || (s[r] = a[r]);
                        s.top = n, s.left = i
                    } else s.cssText = t._stOrig;
                    Yr.core.getCache(t).uncache = 1, e.appendChild(t)
                }
            },
            lo = function(t, e, n) {
                var i = e,
                    r = i;
                return function(e) {
                    var a = Math.round(t());
                    return a !== i && a !== r && Math.abs(a - i) > 3 && Math.abs(a - r) > 3 && (e = a, n && n()), r = i, i = e, e
                }
            },
            co = function(t, e, n) {
                var i = {};
                i[e.p] = "+=" + n, Yr.set(t, i)
            },
            ho = function(t, e) {
                var n = Hr(t, e),
                    i = "_scroll" + e.p2,
                    r = function e(r, a, s, o, l) {
                        var c = e.tween,
                            h = a.onComplete,
                            u = {};
                        s = s || n();
                        var d = lo(n, s, (function() {
                            c.kill(), e.tween = 0
                        }));
                        return l = o && l || 0, o = o || r - s, c && c.kill(), a[i] = r, a.modifiers = u, u[i] = function() {
                            return d(s + o * c.ratio + l * c.ratio * c.ratio)
                        }, a.onUpdate = function() {
                            wr.cache++, Js()
                        }, a.onComplete = function() {
                            e.tween = 0, h && h.call(c)
                        }, c = e.tween = Yr.to(t, a)
                    };
                return t[i] = n, n.wheelHandler = function() {
                    return r.tween && r.tween.kill() && (r.tween = 0)
                }, Ts(t, "wheel", n.wheelHandler), uo.isTouch && Ts(t, "touchmove", n.wheelHandler), r
            },
            uo = function() {
                function t(e, n) {
                    Kr || t.register(Yr) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), Ma(this), this.init(e, n)
                }
                return t.prototype.init = function(e, n) {
                    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Ia) {
                        var i, r, a, s, o, l, c, h, u, d, p, f, m, g, _, v, x, y, M, S, T, E, b, w, A, R, C, P, L, U, D, I, N, O, F, z, B, k, H, V, G, W, X = e = _s(Ka(e) || Ja(e) || e.nodeType ? {
                                trigger: e
                            } : e, As),
                            q = X.onUpdate,
                            j = X.toggleClass,
                            Y = X.id,
                            K = X.onToggle,
                            Z = X.onRefresh,
                            J = X.scrub,
                            Q = X.trigger,
                            $ = X.pin,
                            tt = X.pinSpacing,
                            et = X.invalidateOnRefresh,
                            nt = X.anticipatePin,
                            it = X.onScrubComplete,
                            rt = X.onSnapComplete,
                            at = X.once,
                            st = X.snap,
                            ot = X.pinReparent,
                            lt = X.pinSpacer,
                            ct = X.containerAnimation,
                            ht = X.fastScrollEnd,
                            ut = X.preventOverlaps,
                            dt = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? zr : Br,
                            pt = !J && 0 !== J,
                            ft = kr(e.scroller || Zr),
                            mt = Yr.core.getCache(ft),
                            gt = Wa(ft),
                            _t = "fixed" === ("pinType" in e ? e.pinType : Pr(ft, "pinType") || gt && "fixed"),
                            vt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                            xt = pt && e.toggleActions.split(" "),
                            yt = "markers" in e ? e.markers : As.markers,
                            Mt = gt ? 0 : parseFloat(gs(ft)["border" + dt.p2 + ps]) || 0,
                            St = this,
                            Tt = e.onRefreshInit && function() {
                                return e.onRefreshInit(St)
                            },
                            Et = function(t, e, n) {
                                var i = n.d,
                                    r = n.d2,
                                    a = n.a;
                                return (a = Pr(t, "getBoundingClientRect")) ? function() {
                                    return a()[i]
                                } : function() {
                                    return (e ? Xa(r) : t["client" + r]) || 0
                                }
                            }(ft, gt, dt),
                            bt = function(t, e) {
                                return !e || ~Ar.indexOf(t) ? qa(t) : function() {
                                    return ro
                                }
                            }(ft, gt),
                            wt = 0,
                            At = 0,
                            Rt = 0,
                            Ct = Hr(ft, dt);
                        if (St._startClamp = St._endClamp = !1, St._dir = dt, nt *= 45, St.scroller = ft, St.scroll = ct ? ct.time.bind(ct) : Ct, s = Ct(), St.vars = e, n = n || e.animation, "refreshPriority" in e && (pa = 1, -9999 === e.refreshPriority && (Ca = St)), mt.tweenScroll = mt.tweenScroll || {
                                top: ho(ft, Br),
                                left: ho(ft, zr)
                            }, St.tweenTo = i = mt.tweenScroll[dt.p], St.scrubDuration = function(t) {
                                (N = Ja(t) && t) ? I ? I.duration(t) : I = Yr.to(n, {
                                    ease: "expo",
                                    totalProgress: "+=0",
                                    duration: N,
                                    paused: !0,
                                    onComplete: function() {
                                        return it && it(St)
                                    }
                                }): (I && I.progress(1).kill(), I = 0)
                            }, n && (n.vars.lazy = !1, n._initted && !St.isReverted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.duration() && n.render(0, !0, !0), St.animation = n.pause(), n.scrollTrigger = St, St.scrubDuration(J), U = 0, Y || (Y = n.vars.id)), st && (Qa(st) && !st.push || (st = {
                                snapTo: st
                            }), "scrollBehavior" in $r.style && Yr.set(gt ? [$r, Qr] : ft, {
                                scrollBehavior: "auto"
                            }), wr.forEach((function(t) {
                                return Za(t) && t.target === (gt ? Jr.scrollingElement || Qr : ft) && (t.smooth = !1)
                            })), a = Za(st.snapTo) ? st.snapTo : "labels" === st.snapTo ? function(t) {
                                return function(e) {
                                    return Yr.utils.snap(ys(t), e)
                                }
                            }(n) : "labelsDirectional" === st.snapTo ? (V = n, function(t, e) {
                                return Ms(ys(V))(t, e.direction)
                            }) : !1 !== st.directional ? function(t, e) {
                                return Ms(st.snapTo)(t, La() - At < 500 ? 0 : e.direction)
                            } : Yr.utils.snap(st.snapTo), O = st.duration || {
                                min: .1,
                                max: 2
                            }, O = Qa(O) ? ia(O.min, O.max) : ia(O, O), F = Yr.delayedCall(st.delay || N / 2 || .1, (function() {
                                var t = Ct(),
                                    e = La() - At < 500,
                                    r = i.tween;
                                if (!(e || Math.abs(St.getVelocity()) < 10) || r || oa || wt === t) St.isActive && wt !== t && F.restart(!0);
                                else {
                                    var s = (t - l) / g,
                                        o = n && !pt ? n.totalProgress() : s,
                                        h = e ? 0 : (o - D) / (La() - ra) * 1e3 || 0,
                                        u = Yr.utils.clamp(-s, 1 - s, es(h / 2) * h / .185),
                                        d = s + (!1 === st.inertia ? 0 : u),
                                        p = ia(0, 1, a(d, St)),
                                        f = Math.round(l + p * g),
                                        m = st,
                                        _ = m.onStart,
                                        v = m.onInterrupt,
                                        x = m.onComplete;
                                    if (t <= c && t >= l && f !== t) {
                                        if (r && !r._initted && r.data <= es(f - t)) return;
                                        !1 === st.inertia && (u = p - s), i(f, {
                                            duration: O(es(.185 * Math.max(es(d - o), es(p - o)) / h / .05 || 0)),
                                            ease: st.ease || "power3",
                                            data: es(f - t),
                                            onInterrupt: function() {
                                                return F.restart(!0) && v && v(St)
                                            },
                                            onComplete: function() {
                                                St.update(), wt = Ct(), U = D = n && !pt ? n.totalProgress() : St.progress, rt && rt(St), x && x(St)
                                            }
                                        }, t, u * g, f - t - u * g), _ && _(St, i.tween)
                                    }
                                }
                            })).pause()), Y && (Ds[Y] = St), (H = (Q = St.trigger = kr(Q || !0 !== $ && $)) && Q._gsap && Q._gsap.stRevert) && (H = H(St)), $ = !0 === $ ? Q : kr($), Ka(j) && (j = {
                                targets: Q,
                                className: j
                            }), $ && (!1 === tt || tt === ds || (tt = !(!tt && $.parentNode && $.parentNode.style && "flex" === gs($.parentNode).display) && us), St.pin = $, (r = Yr.core.getCache($)).spacer ? _ = r.pinState : (lt && ((lt = kr(lt)) && !lt.nodeType && (lt = lt.current || lt.nativeElement), r.spacerIsNative = !!lt, lt && (r.spacerState = io(lt))), r.spacer = y = lt || Jr.createElement("div"), y.classList.add("pin-spacer"), Y && y.classList.add("pin-spacer-" + Y), r.pinState = _ = io($)), !1 !== e.force3D && Yr.set($, {
                                force3D: !0
                            }), St.spacer = y = r.spacer, L = gs($), w = L[tt + dt.os2], S = Yr.getProperty($), T = Yr.quickSetter($, dt.a, ms), to($, y, L), x = io($)), yt) {
                            f = Qa(yt) ? _s(yt, ws) : ws, d = Ps("scroller-start", Y, ft, dt, f, 0), p = Ps("scroller-end", Y, ft, dt, f, 0, d), M = d["offset" + dt.op.d2];
                            var Pt = kr(Pr(ft, "content") || ft);
                            h = this.markerStart = Ps("start", Y, Pt, dt, f, M, 0, ct), u = this.markerEnd = Ps("end", Y, Pt, dt, f, M, 0, ct), ct && (k = Yr.quickSetter([h, u], dt.a, ms)), _t || Ar.length && !0 === Pr(ft, "fixedMarkers") || (W = gs(G = gt ? $r : ft).position, G.style.position = "absolute" === W || "fixed" === W ? W : "relative", Yr.set([d, p], {
                                force3D: !0
                            }), R = Yr.quickSetter(d, dt.a, ms), P = Yr.quickSetter(p, dt.a, ms))
                        }
                        if (ct) {
                            var Lt = ct.vars.onUpdate,
                                Ut = ct.vars.onUpdateParams;
                            ct.eventCallback("onUpdate", (function() {
                                St.update(0, 0, 1), Lt && Lt.apply(ct, Ut || [])
                            }))
                        }
                        if (St.previous = function() {
                                return Us[Us.indexOf(St) - 1]
                            }, St.next = function() {
                                return Us[Us.indexOf(St) + 1]
                            }, St.revert = function(t, e) {
                                if (!e) return St.kill(!0);
                                var i = !1 !== t || !St.enabled,
                                    r = sa;
                                i !== St.isReverted && (i && (z = Math.max(Ct(), St.scroll.rec || 0), Rt = St.progress, B = n && n.progress()), h && [h, u, d, p].forEach((function(t) {
                                    return t.style.display = i ? "none" : "block"
                                })), i && (sa = St, St.update(i)), !$ || ot && St.isActive || (i ? function(t, e, n) {
                                    no(n);
                                    var i = t._gsap;
                                    if (i.spacerIsNative) no(i.spacerState);
                                    else if (t._gsap.swappedIn) {
                                        var r = e.parentNode;
                                        r && (r.insertBefore(t, e), r.removeChild(e))
                                    }
                                    t._gsap.swappedIn = !1
                                }($, y, _) : to($, y, gs($), A)), i || St.update(i), sa = r, St.isReverted = i)
                            }, St.refresh = function(r, a, f, M) {
                                if (!sa && St.enabled || a)
                                    if ($ && r && Da) Ts(t, "scrollEnd", ks);
                                    else {
                                        !Aa && Tt && Tt(St), sa = St, i.tween && !f && (i.tween.kill(), i.tween = 0), I && I.pause(), et && n && n.revert({
                                            kill: !1
                                        }).invalidate(), St.isReverted || St.revert(!0, !0), St._subPinOffset = !1;
                                        var T, w, R, P, L, U, D, N, O, k, H, V, G, W = Et(),
                                            X = bt(),
                                            q = ct ? ct.duration() : ja(ft, dt),
                                            j = g <= .01,
                                            Y = 0,
                                            K = M || 0,
                                            J = Qa(f) ? f.end : e.end,
                                            nt = e.endTrigger || Q,
                                            it = Qa(f) ? f.start : e.start || (0 !== e.start && Q ? $ ? "0 0" : "0 100%" : 0),
                                            rt = St.pinnedContainer = e.pinnedContainer && kr(e.pinnedContainer, St),
                                            at = Q && Math.max(0, Us.indexOf(St)) || 0,
                                            st = at;
                                        for (yt && Qa(f) && (V = Yr.getProperty(d, dt.p), G = Yr.getProperty(p, dt.p)); st--;)(U = Us[st]).end || U.refresh(0, 1) || (sa = St), !(D = U.pin) || D !== Q && D !== $ && D !== rt || U.isReverted || (k || (k = []), k.unshift(U), U.revert(!0, !0)), U !== Us[st] && (at--, st--);
                                        for (Za(it) && (it = it(St)), it = Na(it, "start", St), l = ao(it, Q, W, dt, Ct(), h, d, St, X, Mt, _t, q, ct, St._startClamp && "_startClamp") || ($ ? -.001 : 0), Za(J) && (J = J(St)), Ka(J) && !J.indexOf("+=") && (~J.indexOf(" ") ? J = (Ka(it) ? it.split(" ")[0] : "") + J : (Y = Cs(J.substr(2), W), J = Ka(it) ? it : (ct ? Yr.utils.mapRange(0, ct.duration(), ct.scrollTrigger.start, ct.scrollTrigger.end, l) : l) + Y, nt = Q)), J = Na(J, "end", St), c = Math.max(l, ao(J || (nt ? "100% 0" : q), nt, W, dt, Ct() + Y, u, p, St, X, Mt, _t, q, ct, St._endClamp && "_endClamp")) || -.001, Y = 0, st = at; st--;)(D = (U = Us[st]).pin) && U.start - U._pinPush <= l && !ct && U.end > 0 && (T = U.end - (St._startClamp ? Math.max(0, U.start) : U.start), (D === Q && U.start - U._pinPush < l || D === rt) && isNaN(it) && (Y += T * (1 - U.progress)), D === $ && (K += T));
                                        if (l += Y, c += Y, St._startClamp && (St._startClamp += Y), St._endClamp && !Aa && (St._endClamp = c || -.001, c = Math.min(c, ja(ft, dt))), g = c - l || (l -= .01) && .001, j && (Rt = Yr.utils.clamp(0, 1, Yr.utils.normalize(l, c, z))), St._pinPush = K, h && Y && ((T = {})[dt.a] = "+=" + Y, rt && (T[dt.p] = "-=" + Ct()), Yr.set([h, u], T)), $) T = gs($), P = dt === Br, R = Ct(), E = parseFloat(S(dt.a)) + K, !q && c > 1 && (H = {
                                            style: H = (gt ? Jr.scrollingElement || Qr : ft).style,
                                            value: H["overflow" + dt.a.toUpperCase()]
                                        }, gt && "scroll" !== gs($r)["overflow" + dt.a.toUpperCase()] && (H.style["overflow" + dt.a.toUpperCase()] = "scroll")), to($, y, T), x = io($), w = vs($, !0), N = _t && Hr(ft, P ? zr : Br)(), tt && ((A = [tt + dt.os2, g + K + ms]).t = y, (st = tt === us ? xs($, dt) + g + K : 0) && A.push(dt.d, st + ms), no(A), rt && Us.forEach((function(t) {
                                            t.pin === rt && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0)
                                        })), _t && Ct(z)), _t && ((L = {
                                            top: w.top + (P ? R - l : N) + ms,
                                            left: w.left + (P ? N : R - l) + ms,
                                            boxSizing: "border-box",
                                            position: "fixed"
                                        })[as] = L["max" + ps] = Math.ceil(w.width) + ms, L[ss] = L["max" + fs] = Math.ceil(w.height) + ms, L[ds] = L[ds + cs] = L[ds + os] = L[ds + hs] = L[ds + ls] = "0", L[us] = T[us], L[us + cs] = T[us + cs], L[us + os] = T[us + os], L[us + hs] = T[us + hs], L[us + ls] = T[us + ls], v = function(t, e, n) {
                                            for (var i, r = [], a = t.length, s = n ? 8 : 0; s < a; s += 2) i = t[s], r.push(i, i in e ? e[i] : t[s + 1]);
                                            return r.t = t.t, r
                                        }(_, L, ot), Aa && Ct(0)), n ? (O = n._initted, fa(1), n.render(n.duration(), !0, !0), b = S(dt.a) - E + g + K, C = Math.abs(g - b) > 1, _t && C && v.splice(v.length - 2, 2), n.render(0, !0, !0), O || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), fa(0)) : b = g, H && (H.value ? H.style["overflow" + dt.a.toUpperCase()] = H.value : H.style.removeProperty("overflow-" + dt.a));
                                        else if (Q && Ct() && !ct)
                                            for (w = Q.parentNode; w && w !== $r;) w._pinOffset && (l -= w._pinOffset, c -= w._pinOffset), w = w.parentNode;
                                        k && k.forEach((function(t) {
                                            return t.revert(!1, !0)
                                        })), St.start = l, St.end = c, s = o = Aa ? z : Ct(), ct || Aa || (s < z && Ct(z), St.scroll.rec = 0), St.revert(!1, !0), At = La(), F && (wt = -1, F.restart(!0)), sa = 0, n && pt && (n._initted || B) && n.progress() !== B && n.progress(B || 0, !0).render(n.time(), !0, !0), (j || Rt !== St.progress || ct) && (n && !pt && n.totalProgress(ct && l < -.001 && !Rt ? Yr.utils.normalize(l, c, 0) : Rt, !0), St.progress = j || (s - l) / g === Rt ? 0 : Rt), $ && tt && (y._pinOffset = Math.round(St.progress * b)), I && I.invalidate(), isNaN(V) || (V -= Yr.getProperty(d, dt.p), G -= Yr.getProperty(p, dt.p), co(d, dt, V), co(h, dt, V - (M || 0)), co(p, dt, G), co(u, dt, G - (M || 0))), j && !Aa && St.update(), !Z || Aa || m || (m = !0, Z(St), m = !1)
                                    }
                            }, St.getVelocity = function() {
                                return (Ct() - o) / (La() - ra) * 1e3 || 0
                            }, St.endAnimation = function() {
                                $a(St.callbackAnimation), n && (I ? I.progress(1) : n.paused() ? pt || $a(n, St.direction < 0, 1) : $a(n, n.reversed()))
                            }, St.labelToScroll = function(t) {
                                return n && n.labels && (l || St.refresh() || l) + n.labels[t] / n.duration() * g || 0
                            }, St.getTrailing = function(t) {
                                var e = Us.indexOf(St),
                                    n = St.direction > 0 ? Us.slice(0, e).reverse() : Us.slice(e + 1);
                                return (Ka(t) ? n.filter((function(e) {
                                    return e.vars.preventOverlaps === t
                                })) : n).filter((function(t) {
                                    return St.direction > 0 ? t.end <= l : t.start >= c
                                }))
                            }, St.update = function(t, e, r) {
                                if (!ct || r || t) {
                                    var a, h, u, p, f, m, _, M = !0 === Aa ? z : St.scroll(),
                                        S = t ? 0 : (M - l) / g,
                                        A = S < 0 ? 0 : S > 1 ? 1 : S || 0,
                                        L = St.progress;
                                    if (e && (o = s, s = ct ? Ct() : M, st && (D = U, U = n && !pt ? n.totalProgress() : A)), nt && !A && $ && !sa && !Pa && Da && l < M + (M - o) / (La() - ra) * nt && (A = 1e-4), A !== L && St.enabled) {
                                        if (p = (f = (a = St.isActive = !!A && A < 1) != (!!L && L < 1)) || !!A != !!L, St.direction = A > L ? 1 : -1, St.progress = A, p && !sa && (h = A && !L ? 0 : 1 === A ? 1 : 1 === L ? 2 : 3, pt && (u = !f && "none" !== xt[h + 1] && xt[h + 1] || xt[h], _ = n && ("complete" === u || "reset" === u || u in n))), ut && (f || _) && (_ || J || !n) && (Za(ut) ? ut(St) : St.getTrailing(ut).forEach((function(t) {
                                                return t.endAnimation()
                                            }))), pt || (!I || sa || Pa ? n && n.totalProgress(A, !(!sa || !At && !t)) : (I._dp._time - I._start !== I._time && I.render(I._dp._time - I._start), I.resetTo ? I.resetTo("totalProgress", A, n._tTime / n._tDur) : (I.vars.totalProgress = A, I.invalidate().restart()))), $)
                                            if (t && tt && (y.style[tt + dt.os2] = w), _t) {
                                                if (p) {
                                                    if (m = !t && A > L && c + 1 > M && M + 1 >= ja(ft, dt), ot)
                                                        if (t || !a && !m) oo($, y);
                                                        else {
                                                            var N = vs($, !0),
                                                                O = M - l;
                                                            oo($, $r, N.top + (dt === Br ? O : 0) + ms, N.left + (dt === Br ? 0 : O) + ms)
                                                        }
                                                    no(a || m ? v : x), C && A < 1 && a || T(E + (1 !== A || m ? 0 : b))
                                                }
                                            } else T(Ha(E + b * A));
                                        st && !i.tween && !sa && !Pa && F.restart(!0), j && (f || at && A && (A < 1 || !ba)) && na(j.targets).forEach((function(t) {
                                            return t.classList[a || at ? "add" : "remove"](j.className)
                                        })), q && !pt && !t && q(St), p && !sa ? (pt && (_ && ("complete" === u ? n.pause().totalProgress(1) : "reset" === u ? n.restart(!0).pause() : "restart" === u ? n.restart(!0) : n[u]()), q && q(St)), !f && ba || (K && f && ts(St, K), vt[h] && ts(St, vt[h]), at && (1 === A ? St.kill(!1, 1) : vt[h] = 0), f || vt[h = 1 === A ? 1 : 3] && ts(St, vt[h])), ht && !a && Math.abs(St.getVelocity()) > (Ja(ht) ? ht : 2500) && ($a(St.callbackAnimation), I ? I.progress(1) : $a(n, "reverse" === u ? 1 : !A, 1))) : pt && q && !sa && q(St)
                                    }
                                    if (P) {
                                        var B = ct ? M / ct.duration() * (ct._caScrollDist || 0) : M;
                                        R(B + (d._isFlipped ? 1 : 0)), P(B)
                                    }
                                    k && k(-M / ct.duration() * (ct._caScrollDist || 0))
                                }
                            }, St.enable = function(e, n) {
                                St.enabled || (St.enabled = !0, Ts(ft, "resize", Fs), gt || Ts(ft, "scroll", Ns), Tt && Ts(t, "refreshInit", Tt), !1 !== e && (St.progress = Rt = 0, s = o = wt = Ct()), !1 !== n && St.refresh())
                            }, St.getTween = function(t) {
                                return t && i ? i.tween : I
                            }, St.setPositions = function(t, e, n, i) {
                                if (ct) {
                                    var r = ct.scrollTrigger,
                                        a = ct.duration(),
                                        s = r.end - r.start;
                                    t = r.start + s * t / a, e = r.start + s * e / a
                                }
                                St.refresh(!1, !1, {
                                    start: Oa(t, n && !!St._startClamp),
                                    end: Oa(e, n && !!St._endClamp)
                                }, i), St.update()
                            }, St.adjustPinSpacing = function(t) {
                                if (A && t) {
                                    var e = A.indexOf(dt.d) + 1;
                                    A[e] = parseFloat(A[e]) + t + ms, A[1] = parseFloat(A[1]) + t + ms, no(A)
                                }
                            }, St.disable = function(e, n) {
                                if (St.enabled && (!1 !== e && St.revert(!0, !0), St.enabled = St.isActive = !1, n || I && I.pause(), z = 0, r && (r.uncache = 1), Tt && Es(t, "refreshInit", Tt), F && (F.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !gt)) {
                                    for (var a = Us.length; a--;)
                                        if (Us[a].scroller === ft && Us[a] !== St) return;
                                    Es(ft, "resize", Fs), gt || Es(ft, "scroll", Ns)
                                }
                            }, St.kill = function(t, i) {
                                St.disable(t, i), I && !i && I.kill(), Y && delete Ds[Y];
                                var a = Us.indexOf(St);
                                a >= 0 && Us.splice(a, 1), a === ca && Zs > 0 && ca--, a = 0, Us.forEach((function(t) {
                                    return t.scroller === St.scroller && (a = 1)
                                })), a || Aa || (St.scroll.rec = 0), n && (n.scrollTrigger = null, t && n.revert({
                                    kill: !1
                                }), i || n.kill()), h && [h, u, d, p].forEach((function(t) {
                                    return t.parentNode && t.parentNode.removeChild(t)
                                })), Ca === St && (Ca = 0), $ && (r && (r.uncache = 1), a = 0, Us.forEach((function(t) {
                                    return t.pin === $ && a++
                                })), a || (r.spacer = 0)), e.onKill && e.onKill(St)
                            }, Us.push(St), St.enable(!1, !1), H && H(St), n && n.add && !g) {
                            var Dt = St.update;
                            St.update = function() {
                                St.update = Dt, l || c || St.refresh()
                            }, Yr.delayedCall(.01, St.update), g = .01, l = c = 0
                        } else St.refresh();
                        $ && function() {
                            if (Ra !== qs) {
                                var t = Ra = qs;
                                requestAnimationFrame((function() {
                                    return t === qs && Ys(!0)
                                }))
                            }
                        }()
                    } else this.update = this.refresh = this.kill = ka
                }, t.register = function(e) {
                    return Kr || (Yr = e || Ga(), Va() && window.document && t.enable(), Kr = Ia), Kr
                }, t.defaults = function(t) {
                    if (t)
                        for (var e in t) As[e] = t[e];
                    return As
                }, t.disable = function(t, e) {
                    Ia = 0, Us.forEach((function(n) {
                        return n[e ? "kill" : "disable"](t)
                    })), Es(Zr, "wheel", Ns), Es(Jr, "scroll", Ns), clearInterval(aa), Es(Jr, "touchcancel", ka), Es($r, "touchstart", ka), Ss(Es, Jr, "pointerdown,touchstart,mousedown", za), Ss(Es, Jr, "pointerup,touchend,mouseup", Ba), ea.kill(), Ya(Es);
                    for (var n = 0; n < wr.length; n += 3) bs(Es, wr[n], wr[n + 1]), bs(Es, wr[n], wr[n + 2])
                }, t.enable = function() {
                    if (Zr = window, Jr = document, Qr = Jr.documentElement, $r = Jr.body, Yr && (na = Yr.utils.toArray, ia = Yr.utils.clamp, Ma = Yr.core.context || ka, fa = Yr.core.suppressOverwrites || ka, Sa = Zr.history.scrollRestoration || "auto", Ks = Zr.pageYOffset, Yr.core.globals("ScrollTrigger", t), $r)) {
                        Ia = 1, (Ta = document.createElement("div")).style.height = "100vh", Ta.style.position = "absolute", js(), Fa(), jr.register(Yr), t.isTouch = jr.isTouch, ya = jr.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Ts(Zr, "wheel", Ns), ta = [Zr, Jr, Qr, $r], Yr.matchMedia ? (t.matchMedia = function(t) {
                            var e, n = Yr.matchMedia();
                            for (e in t) n.add(e, t[e]);
                            return n
                        }, Yr.addEventListener("matchMediaInit", (function() {
                            return Ws()
                        })), Yr.addEventListener("matchMediaRevert", (function() {
                            return Gs()
                        })), Yr.addEventListener("matchMedia", (function() {
                            Ys(0, 1), Hs("matchMedia")
                        })), Yr.matchMedia("(orientation: portrait)", (function() {
                            return Os(), Os
                        }))) : console.warn("Requires GSAP 3.11.0 or later"), Os(), Ts(Jr, "scroll", Ns);
                        var e, n, i = $r.style,
                            r = i.borderTopStyle,
                            a = Yr.core.Animation.prototype;
                        for (a.revert || Object.defineProperty(a, "revert", {
                                value: function() {
                                    return this.time(-.01, !0)
                                }
                            }), i.borderTopStyle = "solid", e = vs($r), Br.m = Math.round(e.top + Br.sc()) || 0, zr.m = Math.round(e.left + zr.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), aa = setInterval(Is, 250), Yr.delayedCall(.5, (function() {
                                return Pa = 0
                            })), Ts(Jr, "touchcancel", ka), Ts($r, "touchstart", ka), Ss(Ts, Jr, "pointerdown,touchstart,mousedown", za), Ss(Ts, Jr, "pointerup,touchend,mouseup", Ba), la = Yr.utils.checkPrefix("transform"), $s.push(la), Kr = La(), ea = Yr.delayedCall(.2, Ys).pause(), da = [Jr, "visibilitychange", function() {
                                var t = Zr.innerWidth,
                                    e = Zr.innerHeight;
                                Jr.hidden ? (ha = t, ua = e) : ha === t && ua === e || Fs()
                            }, Jr, "DOMContentLoaded", Ys, Zr, "load", Ys, Zr, "resize", Fs], Ya(Ts), Us.forEach((function(t) {
                                return t.enable(0, 1)
                            })), n = 0; n < wr.length; n += 3) bs(Es, wr[n], wr[n + 1]), bs(Es, wr[n], wr[n + 2])
                    }
                }, t.config = function(e) {
                    "limitCallbacks" in e && (ba = !!e.limitCallbacks);
                    var n = e.syncInterval;
                    n && clearInterval(aa) || (aa = n) && setInterval(Is, n), "ignoreMobileResize" in e && (_a = 1 === t.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (Ya(Es) || Ya(Ts, e.autoRefreshEvents || "none"), ma = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
                }, t.scrollerProxy = function(t, e) {
                    var n = kr(t),
                        i = wr.indexOf(n),
                        r = Wa(n);
                    ~i && wr.splice(i, r ? 6 : 2), e && (r ? Ar.unshift(Zr, e, $r, e, Qr, e) : Ar.unshift(n, e))
                }, t.clearMatchMedia = function(t) {
                    Us.forEach((function(e) {
                        return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0)
                    }))
                }, t.isInViewport = function(t, e, n) {
                    var i = (Ka(t) ? kr(t) : t).getBoundingClientRect(),
                        r = i[n ? as : ss] * e || 0;
                    return n ? i.right - r > 0 && i.left + r < Zr.innerWidth : i.bottom - r > 0 && i.top + r < Zr.innerHeight
                }, t.positionInViewport = function(t, e, n) {
                    Ka(t) && (t = kr(t));
                    var i = t.getBoundingClientRect(),
                        r = i[n ? as : ss],
                        a = null == e ? r / 2 : e in Rs ? Rs[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
                    return n ? (i.left + a) / Zr.innerWidth : (i.top + a) / Zr.innerHeight
                }, t.killAll = function(t) {
                    if (Us.slice(0).forEach((function(t) {
                            return "ScrollSmoother" !== t.vars.id && t.kill()
                        })), !0 !== t) {
                        var e = zs.killAll || [];
                        zs = {}, e.forEach((function(t) {
                            return t()
                        }))
                    }
                }, t
            }();
        uo.version = "3.12.2", uo.saveStyles = function(t) {
            return t ? na(t).forEach((function(t) {
                if (t && t.style) {
                    var e = Vs.indexOf(t);
                    e >= 0 && Vs.splice(e, 5), Vs.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), Yr.core.getCache(t), Ma())
                }
            })) : Vs
        }, uo.revert = function(t, e) {
            return Ws(!t, e)
        }, uo.create = function(t, e) {
            return new uo(t, e)
        }, uo.refresh = function(t) {
            return t ? Fs() : (Kr || uo.register()) && Ys(!0)
        }, uo.update = function(t) {
            return ++wr.cache && Js(!0 === t ? 2 : 0)
        }, uo.clearScrollMemory = Xs, uo.maxScroll = function(t, e) {
            return ja(t, e ? zr : Br)
        }, uo.getScrollFunc = function(t, e) {
            return Hr(kr(t), e ? zr : Br)
        }, uo.getById = function(t) {
            return Ds[t]
        }, uo.getAll = function() {
            return Us.filter((function(t) {
                return "ScrollSmoother" !== t.vars.id
            }))
        }, uo.isScrolling = function() {
            return !!Da
        }, uo.snapDirectional = Ms, uo.addEventListener = function(t, e) {
            var n = zs[t] || (zs[t] = []);
            ~n.indexOf(e) || n.push(e)
        }, uo.removeEventListener = function(t, e) {
            var n = zs[t],
                i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1)
        }, uo.batch = function(t, e) {
            var n, i = [],
                r = {},
                a = e.interval || .016,
                s = e.batchMax || 1e9,
                o = function(t, e) {
                    var n = [],
                        i = [],
                        r = Yr.delayedCall(a, (function() {
                            e(n, i), n = [], i = []
                        })).pause();
                    return function(t) {
                        n.length || r.restart(!0), n.push(t.trigger), i.push(t), s <= n.length && r.progress(1)
                    }
                };
            for (n in e) r[n] = "on" === n.substr(0, 2) && Za(e[n]) && "onRefreshInit" !== n ? o(0, e[n]) : e[n];
            return Za(s) && (s = s(), Ts(uo, "refresh", (function() {
                return s = e.batchMax()
            }))), na(t).forEach((function(t) {
                var e = {};
                for (n in r) e[n] = r[n];
                e.trigger = t, i.push(uo.create(e))
            })), i
        };
        var po, fo = function(t, e, n, i) {
                return e > i ? t(i) : e < 0 && t(0), n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
            },
            mo = function t(e, n) {
                !0 === n ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (jr.isTouch ? " pinch-zoom" : "") : "none", e === Qr && t($r, n)
            },
            go = {
                auto: 1,
                scroll: 1
            },
            _o = function(t) {
                var e, n = t.event,
                    i = t.target,
                    r = t.axis,
                    a = (n.changedTouches ? n.changedTouches[0] : n).target,
                    s = a._gsap || Yr.core.getCache(a),
                    o = La();
                if (!s._isScrollT || o - s._isScrollT > 2e3) {
                    for (; a && a !== $r && (a.scrollHeight <= a.clientHeight && a.scrollWidth <= a.clientWidth || !go[(e = gs(a)).overflowY] && !go[e.overflowX]);) a = a.parentNode;
                    s._isScroll = a && a !== i && !Wa(a) && (go[(e = gs(a)).overflowY] || go[e.overflowX]), s._isScrollT = o
                }(s._isScroll || "x" === r) && (n.stopPropagation(), n._gsapAllow = !0)
            },
            vo = function(t, e, n, i) {
                return jr.create({
                    target: t,
                    capture: !0,
                    debounce: !1,
                    lockAxis: !0,
                    type: e,
                    onWheel: i = i && _o,
                    onPress: i,
                    onDrag: i,
                    onScroll: i,
                    onEnable: function() {
                        return n && Ts(Jr, jr.eventTypes[0], yo, !1, !0)
                    },
                    onDisable: function() {
                        return Es(Jr, jr.eventTypes[0], yo, !0)
                    }
                })
            },
            xo = /(input|label|select|textarea)/i,
            yo = function(t) {
                var e = xo.test(t.target.tagName);
                (e || po) && (t._gsapAllow = !0, po = e)
            };
        uo.sort = function(t) {
            return Us.sort(t || function(t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            })
        }, uo.observe = function(t) {
            return new jr(t)
        }, uo.normalizeScroll = function(t) {
            if (void 0 === t) return ga;
            if (!0 === t && ga) return ga.enable();
            if (!1 === t) return ga && ga.kill();
            var e = t instanceof jr ? t : function(t) {
                Qa(t) || (t = {}), t.preventDefault = t.isNormalizer = t.allowClicks = !0, t.type || (t.type = "wheel,touch"), t.debounce = !!t.debounce, t.id = t.id || "normalizer";
                var e, n, i, r, a, s, o, l, c = t,
                    h = c.normalizeScrollX,
                    u = c.momentum,
                    d = c.allowNestedScroll,
                    p = c.onRelease,
                    f = kr(t.target) || Qr,
                    m = Yr.core.globals().ScrollSmoother,
                    g = m && m.get(),
                    _ = ya && (t.content && kr(t.content) || g && !1 !== t.content && !g.smooth() && g.content()),
                    v = Hr(f, Br),
                    x = Hr(f, zr),
                    y = 1,
                    M = (jr.isTouch && Zr.visualViewport ? Zr.visualViewport.scale * Zr.visualViewport.width : Zr.outerWidth) / Zr.innerWidth,
                    S = 0,
                    T = Za(u) ? function() {
                        return u(e)
                    } : function() {
                        return u || 2.8
                    },
                    E = vo(f, t.type, !0, d),
                    b = function() {
                        return r = !1
                    },
                    w = ka,
                    A = ka,
                    R = function() {
                        n = ja(f, Br), A = ia(ya ? 1 : 0, n), h && (w = ia(0, ja(f, zr))), i = qs
                    },
                    C = function() {
                        _._gsap.y = Ha(parseFloat(_._gsap.y) + v.offset) + "px", _.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(_._gsap.y) + ", 0, 1)", v.offset = v.cacheID = 0
                    },
                    P = function() {
                        R(), a.isActive() && a.vars.scrollY > n && (v() > n ? a.progress(1) && v(n) : a.resetTo("scrollY", n))
                    };
                return _ && Yr.set(_, {
                    y: "+=0"
                }), t.ignoreCheck = function(t) {
                    return ya && "touchmove" === t.type && function() {
                        if (r) {
                            requestAnimationFrame(b);
                            var t = Ha(e.deltaY / 2),
                                n = A(v.v - t);
                            if (_ && n !== v.v + v.offset) {
                                v.offset = n - v.v;
                                var i = Ha((parseFloat(_ && _._gsap.y) || 0) - v.offset);
                                _.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + i + ", 0, 1)", _._gsap.y = i + "px", v.cacheID = wr.cache, Js()
                            }
                            return !0
                        }
                        v.offset && C(), r = !0
                    }() || y > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1
                }, t.onPress = function() {
                    r = !1;
                    var t = y;
                    y = Ha((Zr.visualViewport && Zr.visualViewport.scale || 1) / M), a.pause(), t !== y && mo(f, y > 1.01 || !h && "x"), s = x(), o = v(), R(), i = qs
                }, t.onRelease = t.onGestureStart = function(t, e) {
                    if (v.offset && C(), e) {
                        wr.cache++;
                        var i, r, s = T();
                        h && (r = (i = x()) + .05 * s * -t.velocityX / .227, s *= fo(x, i, r, ja(f, zr)), a.vars.scrollX = w(r)), r = (i = v()) + .05 * s * -t.velocityY / .227, s *= fo(v, i, r, ja(f, Br)), a.vars.scrollY = A(r), a.invalidate().duration(s).play(.01), (ya && a.vars.scrollY >= n || i >= n - 1) && Yr.to({}, {
                            onUpdate: P,
                            duration: s
                        })
                    } else l.restart(!0);
                    p && p(t)
                }, t.onWheel = function() {
                    a._ts && a.pause(), La() - S > 1e3 && (i = 0, S = La())
                }, t.onChange = function(t, e, n, r, a) {
                    if (qs !== i && R(), e && h && x(w(r[2] === e ? s + (t.startX - t.x) : x() + e - r[1])), n) {
                        v.offset && C();
                        var l = a[2] === n,
                            c = l ? o + t.startY - t.y : v() + n - a[1],
                            u = A(c);
                        l && c !== u && (o += u - c), v(u)
                    }(n || e) && Js()
                }, t.onEnable = function() {
                    mo(f, !h && "x"), uo.addEventListener("refresh", P), Ts(Zr, "resize", P), v.smooth && (v.target.style.scrollBehavior = "auto", v.smooth = x.smooth = !1), E.enable()
                }, t.onDisable = function() {
                    mo(f, !0), Es(Zr, "resize", P), uo.removeEventListener("refresh", P), E.kill()
                }, t.lockAxis = !1 !== t.lockAxis, (e = new jr(t)).iOS = ya, ya && !v() && v(1), ya && Yr.ticker.add(ka), l = e._dc, a = Yr.to(e, {
                    ease: "power4",
                    paused: !0,
                    scrollX: h ? "+=0.1" : "+=0",
                    scrollY: "+=0.1",
                    modifiers: {
                        scrollY: lo(v, v(), (function() {
                            return a.pause()
                        }))
                    },
                    onUpdate: Js,
                    onComplete: l.vars.onComplete
                }), e
            }(t);
            return ga && ga.target === e.target && ga.kill(), Wa(e.target) && (ga = e), e
        }, uo.core = {
            _getVelocityProp: Vr,
            _inputObserver: vo,
            _scrollers: wr,
            _proxies: Ar,
            bridge: {
                ss: function() {
                    Da || Hs("scrollStart"), Da = La()
                },
                ref: function() {
                    return sa
                }
            }
        }, Ga() && Yr.registerPlugin(uo), cr.registerPlugin(uo);
        class So {
            constructor() {
                this.scrollSmooth = new M({
                    easing: t => t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
                }), this.handleRaf = t => {
                    this.animate(t)
                }, this.removeRaf = T.add(this.handleRaf, 0), this.header = document.querySelector("[data-header]"), this.linkElements = document.querySelectorAll("nav a"), this.keypressElements = document.querySelectorAll("[data-keypress]"), this.sectionElements = document.querySelectorAll("[data-section]"), this.textElements = document.querySelectorAll(".section p, .section ol, .section ul, .section li "), this.headingElements = document.querySelectorAll("[data-heading]"), this.gridGlitchElement = document.querySelector("[data-grid-glitch]"), this.initScrollInView(), this.initScrollToLinks(), this.initKeypress()
            }
            animate(t) {
                this.scrollSmooth.raf(t)
            }
            initScrollToLinks() {
                const t = window.location.href.split("/").pop(),
                    e = document.querySelector(`[data-section="/${t}"]`);
                e && this.scrollSmooth.scrollTo(e, {
                    offset: .15 * -window.innerHeight,
                    immediate: !0
                }), window.addEventListener("popstate", (t => {
                    "scrollRestoration" in history && (history.scrollRestoration = "manual");
                    const e = window.location.href.split("/").pop(),
                        n = document.querySelector(`[data-section="/${e}"]`);
                    n && this.scrollSmooth.scrollTo(n, {
                        offset: .15 * -window.innerHeight
                    })
                })), this.linkElements.forEach((t => {
                    t.addEventListener("click", (e => {
                        if ([...this.linkElements].map((t => {
                                t.classList.remove("active")
                            })), this.getElementForId(t.getAttribute("href")).map((t => {
                                t.classList.add("active")
                            })), t.getAttribute("href")) {
                            e.preventDefault();
                            const n = t.getAttribute("href"),
                                i = document.querySelector(`[data-section="${t.getAttribute("href")}"]`);
                            i ? (this.scrollSmooth.scrollTo(i, {
                                offset: .15 * -window.innerHeight
                            }), window.history.pushState({}, "", n)) : "/" === n && (this.scrollSmooth.scrollTo(0), window.history.pushState({}, "", "/"))
                        }
                    }))
                }))
            }
            initKeypress() {
                document.addEventListener("keypress", (t => {
                    this.keypressElements.forEach((e => {
                        parseInt(t.key) === parseInt(e.getAttribute("data-keypress")) && (t.preventDefault(), e.click())
                    }))
                }))
            }
            initScrollInView() {
                this.gridGlitch = new c(this.gridGlitchElement), [...this.sectionElements].map((t => {
                    t.headingElement = t.querySelector("[data-heading] h2"), uo.create({
                        trigger: t,
                        start: "top 80%",
                        end: "top 0%",
                        onToggle: e => {
                            e.isActive ? (t.classList.add("active"), t.headingElement && (t.headingElement.textShuffle && t.headingElement.textShuffle.destroy(), t.headingElement.textShuffle = new p(t.headingElement), t.headingElement.textShuffle.trigger())) : t.classList.remove("active")
                        }
                    })
                })), [...this.textElements].map((t => {
                    cr.set(t, {
                        opacity: 0,
                        x: "10%"
                    }), uo.create({
                        trigger: t,
                        start: "top 70%",
                        end: "bottom top",
                        onToggle: e => {
                            e.isActive ? cr.set(t, {
                                opacity: 1,
                                x: 0,
                                ease: "expo.out"
                            }) : cr.set(t, {
                                opacity: 0,
                                x: "10%",
                                ease: "expo.out"
                            })
                        }
                    })
                }))
            }
            getElementForId(t) {
                return [...this.linkElements].filter((e => e.getAttribute("href") === `${t}`))
            }
        }
        n(686);
        const To = new class {
                constructor(t) {
                    this.element = t, this.fontUrl = "./assets/fonts/unifont-15.1.01.otf", this.progress = {
                        loaded: 0,
                        time: 0,
                        total: 0
                    }, this.request = null, this.requestError = !1, this.cityCallback = null, this.introCallback = null, this.cells = [], this.noise = o(), this.frequency = 1, this.colsNum = 0, this.cellsNum = Math.ceil(9 * Math.random()) + 3, this.speed = 2, this.loaded = !1
                }
                init() {
                    this.buildGrid(), this.loadFont(), this.startTime()
                }
                loadFont() {
                    this.request = new XMLHttpRequest, this.request.addEventListener("progress", (t => {
                        this.progress.loaded = t.loaded / t.total, this.progressUpdate()
                    })), this.request.onreadystatechange = () => {
                        4 === this.request.readyState && 200 !== this.request.status && (this.progress.loaded = 1, this.requestError = !0, document.head.innerHTML += '<link href="/assets/css/fonts/" rel="stylesheet">')
                    }, this.request.responseType = "arraybuffer", this.request.open("get", this.fontUrl), this.request.send()
                }
                startTime() {
                    cr.to(this.progress, {
                        duration: this.speed,
                        time: 1,
                        ease: "linear.none",
                        onUpdate: () => {
                            this.progressUpdate()
                        }
                    })
                }
                buildGrid() {
                    this.colsNum = Math.ceil(20 * Math.random()) + 30;
                    for (let t = 0; t < this.colsNum; t++) {
                        const e = document.createElement("div");
                        e.classList.add("col");
                        const n = 10 * Math.random();
                        e.style.setProperty("flex", n), this.element.appendChild(e);
                        const i = Math.ceil(Math.random() * n) + 50;
                        for (let n = 0; n < i; n++) {
                            const i = document.createElement("div"),
                                r = 10 * Math.random(),
                                a = (this.noise(t * this.frequency, n * this.frequency, 0) + 1) / 2;
                            i.classList.add("cell"), i.style.setProperty("flex", r), e.appendChild(i), Math.random() > .06 ? i.classList.add("hidden") : this.cells.push({
                                element: i,
                                delay: a
                            })
                        }
                    }
                    let t = 1,
                        e = 0;
                    this.cells.map((n => {
                        t = Math.min(t, n.delay), e = Math.max(e, n.delay)
                    })), this.cells.map((n => {
                        n.delay = this.scale(n.delay, t, e, 0, 1)
                    }))
                }
                progressUpdate() {
                    this.progress.total = (this.progress.loaded + this.progress.time) / 2, 1 !== this.progress.total || this.loaded ? this.cells.map((t => {
                        t.delay < this.progress.total && t.element.classList.add("hidden")
                    })) : (this.loaded = !0, this.progressComplete())
                }
                progressComplete() {
                    this.requestError || new FontFace("unifont-15.1.01", this.request.response).load().then((t => {
                        document.fonts.add(t), uo.refresh()
                    })).catch((t => {})), this.cityCallback(), this.introCallback(), this.element.remove()
                }
                scale(t, e, n, i, r) {
                    return (t - e) * (r - i) / (n - e) + i
                }
            }(document.querySelector("[data-preloader]")),
            Eo = "154",
            bo = 1,
            wo = 2,
            Ao = 3,
            Ro = 100,
            Co = 0,
            Po = 1,
            Lo = 2,
            Uo = 0,
            Do = 1,
            Io = 2,
            No = 3,
            Oo = 4,
            Fo = 5,
            zo = 301,
            Bo = 302,
            ko = 306,
            Ho = 1e3,
            Vo = 1001,
            Go = 1002,
            Wo = 1003,
            Xo = 1005,
            qo = 1006,
            jo = 1008,
            Yo = 1009,
            Ko = 1012,
            Zo = 1014,
            Jo = 1015,
            Qo = 1016,
            $o = 1020,
            tl = 1023,
            el = 1026,
            nl = 1027,
            il = 33776,
            rl = 33777,
            al = 33778,
            sl = 33779,
            ol = 36492,
            ll = 2300,
            cl = 2301,
            hl = 2302,
            ul = 3001,
            dl = "srgb",
            pl = "srgb-linear",
            fl = "display-p3",
            ml = 7680,
            gl = "300 es",
            _l = 1035,
            vl = 2e3,
            xl = 2001;
        class yl {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const Ml = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
            Sl = Math.PI / 180,
            Tl = 180 / Math.PI;

        function El() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (Ml[255 & t] + Ml[t >> 8 & 255] + Ml[t >> 16 & 255] + Ml[t >> 24 & 255] + "-" + Ml[255 & e] + Ml[e >> 8 & 255] + "-" + Ml[e >> 16 & 15 | 64] + Ml[e >> 24 & 255] + "-" + Ml[63 & n | 128] + Ml[n >> 8 & 255] + "-" + Ml[n >> 16 & 255] + Ml[n >> 24 & 255] + Ml[255 & i] + Ml[i >> 8 & 255] + Ml[i >> 16 & 255] + Ml[i >> 24 & 255]).toLowerCase()
        }

        function bl(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function wl(t, e, n) {
            return (1 - n) * t + n * e
        }

        function Al(t) {
            return 0 == (t & t - 1) && 0 !== t
        }

        function Rl(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }

        function Cl(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint32Array:
                    return t / 4294967295;
                case Uint16Array:
                    return t / 65535;
                case Uint8Array:
                    return t / 255;
                case Int32Array:
                    return Math.max(t / 2147483647, -1);
                case Int16Array:
                    return Math.max(t / 32767, -1);
                case Int8Array:
                    return Math.max(t / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function Pl(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint32Array:
                    return Math.round(4294967295 * t);
                case Uint16Array:
                    return Math.round(65535 * t);
                case Uint8Array:
                    return Math.round(255 * t);
                case Int32Array:
                    return Math.round(2147483647 * t);
                case Int16Array:
                    return Math.round(32767 * t);
                case Int8Array:
                    return Math.round(127 * t);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        class Ll {
            constructor(t = 0, e = 0) {
                Ll.prototype.isVector2 = !0, this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(bl(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = this.x - t.x,
                    a = this.y - t.y;
                return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            } * [Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class Ul {
            constructor(t, e, n, i, r, a, s, o, l) {
                Ul.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, a, s, o, l)
            }
            set(t, e, n, i, r, a, s, o, l) {
                const c = this.elements;
                return c[0] = t, c[1] = i, c[2] = s, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = a, c[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    a = n[0],
                    s = n[3],
                    o = n[6],
                    l = n[1],
                    c = n[4],
                    h = n[7],
                    u = n[2],
                    d = n[5],
                    p = n[8],
                    f = i[0],
                    m = i[3],
                    g = i[6],
                    _ = i[1],
                    v = i[4],
                    x = i[7],
                    y = i[2],
                    M = i[5],
                    S = i[8];
                return r[0] = a * f + s * _ + o * y, r[3] = a * m + s * v + o * M, r[6] = a * g + s * x + o * S, r[1] = l * f + c * _ + h * y, r[4] = l * m + c * v + h * M, r[7] = l * g + c * x + h * S, r[2] = u * f + d * _ + p * y, r[5] = u * m + d * v + p * M, r[8] = u * g + d * x + p * S, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    a = t[4],
                    s = t[5],
                    o = t[6],
                    l = t[7],
                    c = t[8];
                return e * a * c - e * s * l - n * r * c + n * s * o + i * r * l - i * a * o
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    a = t[4],
                    s = t[5],
                    o = t[6],
                    l = t[7],
                    c = t[8],
                    h = c * a - s * l,
                    u = s * o - c * r,
                    d = l * r - a * o,
                    p = e * h + n * u + i * d;
                if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = h * f, t[1] = (i * l - c * n) * f, t[2] = (s * n - i * a) * f, t[3] = u * f, t[4] = (c * e - i * o) * f, t[5] = (i * r - s * e) * f, t[6] = d * f, t[7] = (n * o - l * e) * f, t[8] = (a * e - n * r) * f, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, i, r, a, s) {
                const o = Math.cos(r),
                    l = Math.sin(r);
                return this.set(n * o, n * l, -n * (o * a + l * s) + a + t, -i * l, i * o, -i * (-l * a + o * s) + s + e, 0, 0, 1), this
            }
            scale(t, e) {
                return this.premultiply(Dl.makeScale(t, e)), this
            }
            rotate(t) {
                return this.premultiply(Dl.makeRotation(-t)), this
            }
            translate(t, e) {
                return this.premultiply(Dl.makeTranslation(t, e)), this
            }
            makeTranslation(t, e) {
                return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
            }
            makeRotation(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
            }
            makeScale(t, e) {
                return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Dl = new Ul;

        function Il(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] >= 65535) return !0;
            return !1
        }

        function Nl(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        const Ol = {};

        function Fl(t) {
            t in Ol || (Ol[t] = !0, console.warn(t))
        }

        function zl(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function Bl(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        const kl = (new Ul).fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
            Hl = (new Ul).fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]),
            Vl = {
                [pl]: t => t,
                [dl]: t => t.convertSRGBToLinear(),
                [fl]: function(t) {
                    return t.convertSRGBToLinear().applyMatrix3(Hl)
                }
            },
            Gl = {
                [pl]: t => t,
                [dl]: t => t.convertLinearToSRGB(),
                [fl]: function(t) {
                    return t.applyMatrix3(kl).convertLinearToSRGB()
                }
            },
            Wl = {
                enabled: !0,
                get legacyMode() {
                    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
                },
                set legacyMode(t) {
                    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !t
                },
                get workingColorSpace() {
                    return pl
                },
                set workingColorSpace(t) {
                    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                },
                convert: function(t, e, n) {
                    if (!1 === this.enabled || e === n || !e || !n) return t;
                    const i = Vl[e],
                        r = Gl[n];
                    if (void 0 === i || void 0 === r) throw new Error(`Unsupported color space conversion, "${e}" to "${n}".`);
                    return r(i(t))
                },
                fromWorkingColorSpace: function(t, e) {
                    return this.convert(t, this.workingColorSpace, e)
                },
                toWorkingColorSpace: function(t, e) {
                    return this.convert(t, e, this.workingColorSpace)
                }
            };
        let Xl;
        class ql {
            static getDataURL(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === Xl && (Xl = Nl("canvas")), Xl.width = t.width, Xl.height = t.height;
                    const n = Xl.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Xl
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = Nl("canvas");
                    e.width = t.width, e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const i = n.getImageData(0, 0, t.width, t.height),
                        r = i.data;
                    for (let t = 0; t < r.length; t++) r[t] = 255 * zl(r[t] / 255);
                    return n.putImageData(i, 0, 0), e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * zl(e[t] / 255)) : e[t] = zl(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
            }
        }
        let jl = 0;
        class Yl {
            constructor(t = null) {
                this.isSource = !0, Object.defineProperty(this, "id", {
                    value: jl++
                }), this.uuid = El(), this.data = t, this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    i = this.data;
                if (null !== i) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Kl(i[e].image)) : t.push(Kl(i[e]))
                    } else t = Kl(i);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n), n
            }
        }

        function Kl(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ql.getDataURL(t) : t.data ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        let Zl = 0;
        class Jl extends yl {
            constructor(t = Jl.DEFAULT_IMAGE, e = Jl.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, a = jo, s = tl, o = Yo, l = Jl.DEFAULT_ANISOTROPY, c = "") {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: Zl++
                }), this.uuid = El(), this.name = "", this.source = new Yl(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new Ll(0, 0), this.repeat = new Ll(1, 1), this.center = new Ll(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ul, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, "string" == typeof c ? this.colorSpace = c : (Fl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = c === ul ? dl : ""), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(t = null) {
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case Ho:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Vo:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Go:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case Ho:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Vo:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Go:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++, this.source.needsUpdate = !0)
            }
            get encoding() {
                return Fl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === dl ? ul : 3e3
            }
            set encoding(t) {
                Fl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = t === ul ? dl : ""
            }
        }
        Jl.DEFAULT_IMAGE = null, Jl.DEFAULT_MAPPING = 300, Jl.DEFAULT_ANISOTROPY = 1;
        class Ql {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                Ql.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    a = t.elements;
                return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const a = .01,
                    s = .1,
                    o = t.elements,
                    l = o[0],
                    c = o[4],
                    h = o[8],
                    u = o[1],
                    d = o[5],
                    p = o[9],
                    f = o[2],
                    m = o[6],
                    g = o[10];
                if (Math.abs(c - u) < a && Math.abs(h - f) < a && Math.abs(p - m) < a) {
                    if (Math.abs(c + u) < s && Math.abs(h + f) < s && Math.abs(p + m) < s && Math.abs(l + d + g - 3) < s) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (l + 1) / 2,
                        o = (d + 1) / 2,
                        _ = (g + 1) / 2,
                        v = (c + u) / 4,
                        x = (h + f) / 4,
                        y = (p + m) / 4;
                    return t > o && t > _ ? t < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = v / n, r = x / n) : o > _ ? o < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = v / i, r = y / i) : _ < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(_), n = x / r, i = y / r), this.set(n, i, r, e), this
                }
                let _ = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
                return Math.abs(_) < .001 && (_ = 1), this.x = (m - p) / _, this.y = (h - f) / _, this.z = (u - c) / _, this.w = Math.acos((l + d + g - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            } * [Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class $l extends yl {
            constructor(t = 1, e = 1, n = {}) {
                super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new Ql(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ql(0, 0, t, e);
                const i = {
                    width: t,
                    height: e,
                    depth: 1
                };
                void 0 !== n.encoding && (Fl("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === ul ? dl : ""), this.texture = new Jl(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : qo, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
            }
            setSize(t, e, n = 1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
                const e = Object.assign({}, t.texture.image);
                return this.texture.source = new Yl(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class tc extends Jl {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = Wo, this.minFilter = Wo, this.wrapR = Vo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class ec {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i
            }
            static slerpFlat(t, e, n, i, r, a, s) {
                let o = n[i + 0],
                    l = n[i + 1],
                    c = n[i + 2],
                    h = n[i + 3];
                const u = r[a + 0],
                    d = r[a + 1],
                    p = r[a + 2],
                    f = r[a + 3];
                if (0 === s) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
                if (1 === s) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
                if (h !== f || o !== u || l !== d || c !== p) {
                    let t = 1 - s;
                    const e = o * u + l * d + c * p + h * f,
                        n = e >= 0 ? 1 : -1,
                        i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i),
                            a = Math.atan2(r, e * n);
                        t = Math.sin(t * a) / r, s = Math.sin(s * a) / r
                    }
                    const r = s * n;
                    if (o = o * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + f * r, t === 1 - s) {
                        const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                        o *= t, l *= t, c *= t, h *= t
                    }
                }
                t[e] = o, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, a) {
                const s = n[i],
                    o = n[i + 1],
                    l = n[i + 2],
                    c = n[i + 3],
                    h = r[a],
                    u = r[a + 1],
                    d = r[a + 2],
                    p = r[a + 3];
                return t[e] = s * p + c * h + o * d - l * u, t[e + 1] = o * p + c * u + l * h - s * d, t[e + 2] = l * p + c * d + s * u - o * h, t[e + 3] = c * p - s * h - o * u - l * d, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    a = t._order,
                    s = Math.cos,
                    o = Math.sin,
                    l = s(n / 2),
                    c = s(i / 2),
                    h = s(r / 2),
                    u = o(n / 2),
                    d = o(i / 2),
                    p = o(r / 2);
                switch (a) {
                    case "XYZ":
                        this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                        break;
                    case "YXZ":
                        this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                        break;
                    case "ZXY":
                        this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                        break;
                    case "ZYX":
                        this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                        break;
                    case "YZX":
                        this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                        break;
                    case "XZY":
                        this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                }
                return !1 !== e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    i = e[4],
                    r = e[8],
                    a = e[1],
                    s = e[5],
                    o = e[9],
                    l = e[2],
                    c = e[6],
                    h = e[10],
                    u = n + s + h;
                if (u > 0) {
                    const t = .5 / Math.sqrt(u + 1);
                    this._w = .25 / t, this._x = (c - o) * t, this._y = (r - l) * t, this._z = (a - i) * t
                } else if (n > s && n > h) {
                    const t = 2 * Math.sqrt(1 + n - s - h);
                    this._w = (c - o) / t, this._x = .25 * t, this._y = (i + a) / t, this._z = (r + l) / t
                } else if (s > h) {
                    const t = 2 * Math.sqrt(1 + s - n - h);
                    this._w = (r - l) / t, this._x = (i + a) / t, this._y = .25 * t, this._z = (o + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + h - n - s);
                    this._w = (a - i) / t, this._x = (r + l) / t, this._y = (o + c) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(bl(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(t) {
                return this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    a = t._w,
                    s = e._x,
                    o = e._y,
                    l = e._z,
                    c = e._w;
                return this._x = n * c + a * s + i * l - r * o, this._y = i * c + a * o + r * s - n * l, this._z = r * c + a * l + n * o - i * s, this._w = a * c - n * s - i * o - r * l, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    a = this._w;
                let s = a * t._w + n * t._x + i * t._y + r * t._z;
                if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                const o = 1 - s * s;
                if (o <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * a + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const l = Math.sqrt(o),
                    c = Math.atan2(l, s),
                    h = Math.sin((1 - e) * c) / l,
                    u = Math.sin(e * c) / l;
                return this._w = a * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = Math.random(),
                    e = Math.sqrt(1 - t),
                    n = Math.sqrt(t),
                    i = 2 * Math.PI * Math.random(),
                    r = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {} * [Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class nc {
            constructor(t = 0, e = 0, n = 0) {
                nc.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }
            applyEuler(t) {
                return this.applyQuaternion(rc.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(rc.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements,
                    a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a, this
            }
            applyQuaternion(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.x,
                    a = t.y,
                    s = t.z,
                    o = t.w,
                    l = o * e + a * i - s * n,
                    c = o * n + s * e - r * i,
                    h = o * i + r * n - a * e,
                    u = -r * e - a * n - s * i;
                return this.x = l * o + u * -r + c * -s - h * -a, this.y = c * o + u * -a + h * -r - l * -s, this.z = h * o + u * -s + l * -a - c * -r, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t) {
                return this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z,
                    a = e.x,
                    s = e.y,
                    o = e.z;
                return this.x = i * o - r * s, this.y = r * a - n * o, this.z = n * s - i * a, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return ic.copy(this).projectOnVector(t), this.sub(ic)
            }
            reflect(t) {
                return this.sub(ic.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(bl(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x, this.y = t._y, this.z = t._z, this
            }
            setFromColor(t) {
                return this.x = t.r, this.y = t.g, this.z = t.b, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const t = 2 * (Math.random() - .5),
                    e = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
            } * [Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const ic = new nc,
            rc = new ec;
        class ac {
            constructor(t = new nc(1 / 0, 1 / 0, 1 / 0), e = new nc(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(oc.fromArray(t, e));
                return this
            }
            setFromBufferAttribute(t) {
                this.makeEmpty();
                for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(oc.fromBufferAttribute(t, e));
                return this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = oc.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(t, e = !1) {
                return this.makeEmpty(), this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(t, e = !1) {
                if (t.updateWorldMatrix(!1, !1), void 0 !== t.boundingBox) null === t.boundingBox && t.computeBoundingBox(), lc.copy(t.boundingBox), lc.applyMatrix4(t.matrixWorld), this.union(lc);
                else {
                    const n = t.geometry;
                    if (void 0 !== n)
                        if (e && void 0 !== n.attributes && void 0 !== n.attributes.position) {
                            const e = n.attributes.position;
                            for (let n = 0, i = e.count; n < i; n++) oc.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(oc)
                        } else null === n.boundingBox && n.computeBoundingBox(), lc.copy(n.boundingBox), lc.applyMatrix4(t.matrixWorld), this.union(lc)
                }
                const n = t.children;
                for (let t = 0, i = n.length; t < i; t++) this.expandByObject(n[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, oc), oc.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(mc), gc.subVectors(this.max, mc), cc.subVectors(t.a, mc), hc.subVectors(t.b, mc), uc.subVectors(t.c, mc), dc.subVectors(hc, cc), pc.subVectors(uc, hc), fc.subVectors(cc, uc);
                let e = [0, -dc.z, dc.y, 0, -pc.z, pc.y, 0, -fc.z, fc.y, dc.z, 0, -dc.x, pc.z, 0, -pc.x, fc.z, 0, -fc.x, -dc.y, dc.x, 0, -pc.y, pc.x, 0, -fc.y, fc.x, 0];
                return !!xc(e, cc, hc, uc, gc) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!xc(e, cc, hc, uc, gc) && (_c.crossVectors(dc, pc), e = [_c.x, _c.y, _c.z], xc(e, cc, hc, uc, gc)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return this.clampPoint(t, oc).distanceTo(t)
            }
            getBoundingSphere(t) {
                return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(oc).length()), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (sc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), sc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), sc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), sc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), sc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), sc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), sc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), sc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(sc)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        const sc = [new nc, new nc, new nc, new nc, new nc, new nc, new nc, new nc],
            oc = new nc,
            lc = new ac,
            cc = new nc,
            hc = new nc,
            uc = new nc,
            dc = new nc,
            pc = new nc,
            fc = new nc,
            mc = new nc,
            gc = new nc,
            _c = new nc,
            vc = new nc;

        function xc(t, e, n, i, r) {
            for (let a = 0, s = t.length - 3; a <= s; a += 3) {
                vc.fromArray(t, a);
                const s = r.x * Math.abs(vc.x) + r.y * Math.abs(vc.y) + r.z * Math.abs(vc.z),
                    o = e.dot(vc),
                    l = n.dot(vc),
                    c = i.dot(vc);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) return !1
            }
            return !0
        }
        const yc = new ac,
            Mc = new nc,
            Sc = new nc;
        class Tc {
            constructor(t = new nc, e = -1) {
                this.center = t, this.radius = e
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : yc.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i), this
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            expandByPoint(t) {
                if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                Mc.subVectors(t, this.center);
                const e = Mc.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e),
                        n = .5 * (t - this.radius);
                    this.center.addScaledVector(Mc, n / t), this.radius += n
                }
                return this
            }
            union(t) {
                return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Sc.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Mc.copy(t.center).add(Sc)), this.expandByPoint(Mc.copy(t.center).sub(Sc))), this)
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Ec = new nc,
            bc = new nc,
            wc = new nc,
            Ac = new nc,
            Rc = new nc,
            Cc = new nc,
            Pc = new nc;
        class Lc {
            constructor(t = new nc, e = new nc(0, 0, -1)) {
                this.origin = t, this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return e.copy(this.origin).addScaledVector(this.direction, t)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, Ec)), this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = Ec.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Ec.copy(this.origin).addScaledVector(this.direction, e), Ec.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                bc.copy(t).add(e).multiplyScalar(.5), wc.copy(e).sub(t).normalize(), Ac.copy(this.origin).sub(bc);
                const r = .5 * t.distanceTo(e),
                    a = -this.direction.dot(wc),
                    s = Ac.dot(this.direction),
                    o = -Ac.dot(wc),
                    l = Ac.lengthSq(),
                    c = Math.abs(1 - a * a);
                let h, u, d, p;
                if (c > 0)
                    if (h = a * o - s, u = a * s - o, p = r * c, h >= 0)
                        if (u >= -p)
                            if (u <= p) {
                                const t = 1 / c;
                                h *= t, u *= t, d = h * (h + a * u + 2 * s) + u * (a * h + u + 2 * o) + l
                            } else u = r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
                else u = -r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
                else u <= -p ? (h = Math.max(0, -(-a * r + s)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(a * r + s)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
                else u = a > 0 ? -r : r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(bc).addScaledVector(wc, u), d
            }
            intersectSphere(t, e) {
                Ec.subVectors(t.center, this.origin);
                const n = Ec.dot(this.direction),
                    i = Ec.dot(Ec) - n * n,
                    r = t.radius * t.radius;
                if (i > r) return null;
                const a = Math.sqrt(r - i),
                    s = n - a,
                    o = n + a;
                return o < 0 ? null : s < 0 ? this.at(o, e) : this.at(s, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, a, s, o;
                const l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    h = 1 / this.direction.z,
                    u = this.origin;
                return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, a = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, a = (t.min.y - u.y) * c), n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r), (a < i || isNaN(i)) && (i = a), h >= 0 ? (s = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (s = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, Ec)
            }
            intersectTriangle(t, e, n, i, r) {
                Rc.subVectors(e, t), Cc.subVectors(n, t), Pc.crossVectors(Rc, Cc);
                let a, s = this.direction.dot(Pc);
                if (s > 0) {
                    if (i) return null;
                    a = 1
                } else {
                    if (!(s < 0)) return null;
                    a = -1, s = -s
                }
                Ac.subVectors(this.origin, t);
                const o = a * this.direction.dot(Cc.crossVectors(Ac, Cc));
                if (o < 0) return null;
                const l = a * this.direction.dot(Rc.cross(Ac));
                if (l < 0) return null;
                if (o + l > s) return null;
                const c = -a * Ac.dot(Pc);
                return c < 0 ? null : this.at(c / s, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Uc {
            constructor(t, e, n, i, r, a, s, o, l, c, h, u, d, p, f, m) {
                Uc.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, a, s, o, l, c, h, u, d, p, f, m)
            }
            set(t, e, n, i, r, a, s, o, l, c, h, u, d, p, f, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new Uc).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    i = 1 / Dc.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Dc.setFromMatrixColumn(t, 1).length(),
                    a = 1 / Dc.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z,
                    a = Math.cos(n),
                    s = Math.sin(n),
                    o = Math.cos(i),
                    l = Math.sin(i),
                    c = Math.cos(r),
                    h = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = a * c,
                        n = a * h,
                        i = s * c,
                        r = s * h;
                    e[0] = o * c, e[4] = -o * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -s * o, e[2] = r - t * l, e[6] = i + n * l, e[10] = a * o
                } else if ("YXZ" === t.order) {
                    const t = o * c,
                        n = o * h,
                        i = l * c,
                        r = l * h;
                    e[0] = t + r * s, e[4] = i * s - n, e[8] = a * l, e[1] = a * h, e[5] = a * c, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = a * o
                } else if ("ZXY" === t.order) {
                    const t = o * c,
                        n = o * h,
                        i = l * c,
                        r = l * h;
                    e[0] = t - r * s, e[4] = -a * h, e[8] = i + n * s, e[1] = n + i * s, e[5] = a * c, e[9] = r - t * s, e[2] = -a * l, e[6] = s, e[10] = a * o
                } else if ("ZYX" === t.order) {
                    const t = a * c,
                        n = a * h,
                        i = s * c,
                        r = s * h;
                    e[0] = o * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = o * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = s * o, e[10] = a * o
                } else if ("YZX" === t.order) {
                    const t = a * o,
                        n = a * l,
                        i = s * o,
                        r = s * l;
                    e[0] = o * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = a * c, e[9] = -s * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
                } else if ("XZY" === t.order) {
                    const t = a * o,
                        n = a * l,
                        i = s * o,
                        r = s * l;
                    e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = a * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = s * c, e[10] = r * h + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Nc, t, Oc)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return Bc.subVectors(t, e), 0 === Bc.lengthSq() && (Bc.z = 1), Bc.normalize(), Fc.crossVectors(n, Bc), 0 === Fc.lengthSq() && (1 === Math.abs(n.z) ? Bc.x += 1e-4 : Bc.z += 1e-4, Bc.normalize(), Fc.crossVectors(n, Bc)), Fc.normalize(), zc.crossVectors(Bc, Fc), i[0] = Fc.x, i[4] = zc.x, i[8] = Bc.x, i[1] = Fc.y, i[5] = zc.y, i[9] = Bc.y, i[2] = Fc.z, i[6] = zc.z, i[10] = Bc.z, this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    a = n[0],
                    s = n[4],
                    o = n[8],
                    l = n[12],
                    c = n[1],
                    h = n[5],
                    u = n[9],
                    d = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    _ = n[3],
                    v = n[7],
                    x = n[11],
                    y = n[15],
                    M = i[0],
                    S = i[4],
                    T = i[8],
                    E = i[12],
                    b = i[1],
                    w = i[5],
                    A = i[9],
                    R = i[13],
                    C = i[2],
                    P = i[6],
                    L = i[10],
                    U = i[14],
                    D = i[3],
                    I = i[7],
                    N = i[11],
                    O = i[15];
                return r[0] = a * M + s * b + o * C + l * D, r[4] = a * S + s * w + o * P + l * I, r[8] = a * T + s * A + o * L + l * N, r[12] = a * E + s * R + o * U + l * O, r[1] = c * M + h * b + u * C + d * D, r[5] = c * S + h * w + u * P + d * I, r[9] = c * T + h * A + u * L + d * N, r[13] = c * E + h * R + u * U + d * O, r[2] = p * M + f * b + m * C + g * D, r[6] = p * S + f * w + m * P + g * I, r[10] = p * T + f * A + m * L + g * N, r[14] = p * E + f * R + m * U + g * O, r[3] = _ * M + v * b + x * C + y * D, r[7] = _ * S + v * w + x * P + y * I, r[11] = _ * T + v * A + x * L + y * N, r[15] = _ * E + v * R + x * U + y * O, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    i = t[8],
                    r = t[12],
                    a = t[1],
                    s = t[5],
                    o = t[9],
                    l = t[13],
                    c = t[2],
                    h = t[6],
                    u = t[10],
                    d = t[14];
                return t[3] * (+r * o * h - i * l * h - r * s * u + n * l * u + i * s * d - n * o * d) + t[7] * (+e * o * d - e * l * u + r * a * u - i * a * d + i * l * c - r * o * c) + t[11] * (+e * l * h - e * s * d - r * a * h + n * a * d + r * s * c - n * l * c) + t[15] * (-i * s * c - e * o * h + e * s * u + i * a * h - n * a * u + n * o * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    a = t[4],
                    s = t[5],
                    o = t[6],
                    l = t[7],
                    c = t[8],
                    h = t[9],
                    u = t[10],
                    d = t[11],
                    p = t[12],
                    f = t[13],
                    m = t[14],
                    g = t[15],
                    _ = h * m * l - f * u * l + f * o * d - s * m * d - h * o * g + s * u * g,
                    v = p * u * l - c * m * l - p * o * d + a * m * d + c * o * g - a * u * g,
                    x = c * f * l - p * h * l + p * s * d - a * f * d - c * s * g + a * h * g,
                    y = p * h * o - c * f * o - p * s * u + a * f * u + c * s * m - a * h * m,
                    M = e * _ + n * v + i * x + r * y;
                if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const S = 1 / M;
                return t[0] = _ * S, t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * S, t[2] = (s * m * r - f * o * r + f * i * l - n * m * l - s * i * g + n * o * g) * S, t[3] = (h * o * r - s * u * r - h * i * l + n * u * l + s * i * d - n * o * d) * S, t[4] = v * S, t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * S, t[6] = (p * o * r - a * m * r - p * i * l + e * m * l + a * i * g - e * o * g) * S, t[7] = (a * u * r - c * o * r + c * i * l - e * u * l - a * i * d + e * o * d) * S, t[8] = x * S, t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * S, t[10] = (a * f * r - p * s * r + p * n * l - e * f * l - a * n * g + e * s * g) * S, t[11] = (c * s * r - a * h * r - c * n * l + e * h * l + a * n * d - e * s * d) * S, t[12] = y * S, t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * S, t[14] = (p * s * i - a * f * i - p * n * o + e * f * o + a * n * m - e * s * m) * S, t[15] = (a * h * i - c * s * i + c * n * o - e * h * o - a * n * u + e * s * u) * S, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = 1 - n,
                    a = t.x,
                    s = t.y,
                    o = t.z,
                    l = r * a,
                    c = r * s;
                return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n, i, r, a) {
                return this.set(1, n, r, 0, t, 1, a, 0, e, i, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const i = this.elements,
                    r = e._x,
                    a = e._y,
                    s = e._z,
                    o = e._w,
                    l = r + r,
                    c = a + a,
                    h = s + s,
                    u = r * l,
                    d = r * c,
                    p = r * h,
                    f = a * c,
                    m = a * h,
                    g = s * h,
                    _ = o * l,
                    v = o * c,
                    x = o * h,
                    y = n.x,
                    M = n.y,
                    S = n.z;
                return i[0] = (1 - (f + g)) * y, i[1] = (d + x) * y, i[2] = (p - v) * y, i[3] = 0, i[4] = (d - x) * M, i[5] = (1 - (u + g)) * M, i[6] = (m + _) * M, i[7] = 0, i[8] = (p + v) * S, i[9] = (m - _) * S, i[10] = (1 - (u + f)) * S, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Dc.set(i[0], i[1], i[2]).length();
                const a = Dc.set(i[4], i[5], i[6]).length(),
                    s = Dc.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Ic.copy(this);
                const o = 1 / r,
                    l = 1 / a,
                    c = 1 / s;
                return Ic.elements[0] *= o, Ic.elements[1] *= o, Ic.elements[2] *= o, Ic.elements[4] *= l, Ic.elements[5] *= l, Ic.elements[6] *= l, Ic.elements[8] *= c, Ic.elements[9] *= c, Ic.elements[10] *= c, e.setFromRotationMatrix(Ic), n.x = r, n.y = a, n.z = s, this
            }
            makePerspective(t, e, n, i, r, a, s = 2e3) {
                const o = this.elements,
                    l = 2 * r / (e - t),
                    c = 2 * r / (n - i),
                    h = (e + t) / (e - t),
                    u = (n + i) / (n - i);
                let d, p;
                if (s === vl) d = -(a + r) / (a - r), p = -2 * a * r / (a - r);
                else {
                    if (s !== xl) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                    d = -a / (a - r), p = -a * r / (a - r)
                }
                return o[0] = l, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
            }
            makeOrthographic(t, e, n, i, r, a, s = 2e3) {
                const o = this.elements,
                    l = 1 / (e - t),
                    c = 1 / (n - i),
                    h = 1 / (a - r),
                    u = (e + t) * l,
                    d = (n + i) * c;
                let p, f;
                if (s === vl) p = (a + r) * h, f = -2 * h;
                else {
                    if (s !== xl) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                    p = r * h, f = -1 * h
                }
                return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = f, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        const Dc = new nc,
            Ic = new Uc,
            Nc = new nc(0, 0, 0),
            Oc = new nc(1, 1, 1),
            Fc = new nc,
            zc = new nc,
            Bc = new nc,
            kc = new Uc,
            Hc = new ec;
        class Vc {
            constructor(t = 0, e = 0, n = 0, i = Vc.DEFAULT_ORDER) {
                this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, i = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e = this._order, n = !0) {
                const i = t.elements,
                    r = i[0],
                    a = i[4],
                    s = i[8],
                    o = i[1],
                    l = i[5],
                    c = i[9],
                    h = i[2],
                    u = i[6],
                    d = i[10];
                switch (e) {
                    case "XYZ":
                        this._y = Math.asin(bl(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-bl(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(bl(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-bl(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(bl(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-bl(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(t, e, n) {
                return kc.makeRotationFromQuaternion(t), this.setFromRotationMatrix(kc, e, n)
            }
            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return Hc.setFromEuler(this), this.setFromQuaternion(Hc, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {} * [Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
        }
        Vc.DEFAULT_ORDER = "XYZ";
        class Gc {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }
        let Wc = 0;
        const Xc = new nc,
            qc = new ec,
            jc = new Uc,
            Yc = new nc,
            Kc = new nc,
            Zc = new nc,
            Jc = new ec,
            Qc = new nc(1, 0, 0),
            $c = new nc(0, 1, 0),
            th = new nc(0, 0, 1),
            eh = {
                type: "added"
            },
            nh = {
                type: "removed"
            };
        class ih extends yl {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: Wc++
                }), this.uuid = El(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ih.DEFAULT_UP.clone();
                const t = new nc,
                    e = new Vc,
                    n = new ec,
                    i = new nc(1, 1, 1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                })), n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Uc
                    },
                    normalMatrix: {
                        value: new Ul
                    }
                }), this.matrix = new Uc, this.matrixWorld = new Uc, this.matrixAutoUpdate = ih.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = ih.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Gc, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t), this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return qc.setFromAxisAngle(t, e), this.quaternion.multiply(qc), this
            }
            rotateOnWorldAxis(t, e) {
                return qc.setFromAxisAngle(t, e), this.quaternion.premultiply(qc), this
            }
            rotateX(t) {
                return this.rotateOnAxis(Qc, t)
            }
            rotateY(t) {
                return this.rotateOnAxis($c, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(th, t)
            }
            translateOnAxis(t, e) {
                return Xc.copy(t).applyQuaternion(this.quaternion), this.position.add(Xc.multiplyScalar(e)), this
            }
            translateX(t) {
                return this.translateOnAxis(Qc, t)
            }
            translateY(t) {
                return this.translateOnAxis($c, t)
            }
            translateZ(t) {
                return this.translateOnAxis(th, t)
            }
            localToWorld(t) {
                return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return this.updateWorldMatrix(!0, !1), t.applyMatrix4(jc.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? Yc.copy(t) : Yc.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), Kc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? jc.lookAt(Kc, Yc, this.up) : jc.lookAt(Yc, Kc, this.up), this.quaternion.setFromRotationMatrix(jc), i && (jc.extractRotation(i.matrixWorld), qc.setFromRotationMatrix(jc), this.quaternion.premultiply(qc.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(eh)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(nh)), this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }
            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null, e.dispatchEvent(nh)
                }
                return this.children.length = 0, this
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1), jc.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), jc.multiply(t.parent.matrixWorld)), t.applyMatrix4(jc), this.add(t), t.updateWorldMatrix(!1, !0), this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i) return i
                }
            }
            getObjectsByProperty(t, e) {
                let n = [];
                this[t] === e && n.push(this);
                for (let i = 0, r = this.children.length; i < r; i++) {
                    const r = this.children[i].getObjectsByProperty(t, e);
                    r.length > 0 && (n = n.concat(r))
                }
                return n
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Kc, t, Zc), t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Kc, Jc, t), t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t)
                }
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};

                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            } else r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = a(t.geometries),
                        i = a(t.materials),
                        r = a(t.textures),
                        s = a(t.images),
                        o = a(t.shapes),
                        l = a(t.skeletons),
                        c = a(t.animations),
                        h = a(t.nodes);
                    e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), h.length > 0 && (n.nodes = h)
                }
                return n.object = i, n;

                function a(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        ih.DEFAULT_UP = new nc(0, 1, 0), ih.DEFAULT_MATRIX_AUTO_UPDATE = !0, ih.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const rh = new nc,
            ah = new nc,
            sh = new nc,
            oh = new nc,
            lh = new nc,
            ch = new nc,
            hh = new nc,
            uh = new nc,
            dh = new nc,
            ph = new nc;
        let fh = !1;
        class mh {
            constructor(t = new nc, e = new nc, n = new nc) {
                this.a = t, this.b = e, this.c = n
            }
            static getNormal(t, e, n, i) {
                i.subVectors(n, e), rh.subVectors(t, e), i.cross(rh);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                rh.subVectors(i, e), ah.subVectors(n, e), sh.subVectors(t, e);
                const a = rh.dot(rh),
                    s = rh.dot(ah),
                    o = rh.dot(sh),
                    l = ah.dot(ah),
                    c = ah.dot(sh),
                    h = a * l - s * s;
                if (0 === h) return r.set(-2, -1, -1);
                const u = 1 / h,
                    d = (l * o - s * c) * u,
                    p = (a * c - s * o) * u;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, oh), oh.x >= 0 && oh.y >= 0 && oh.x + oh.y <= 1
            }
            static getUV(t, e, n, i, r, a, s, o) {
                return !1 === fh && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), fh = !0), this.getInterpolation(t, e, n, i, r, a, s, o)
            }
            static getInterpolation(t, e, n, i, r, a, s, o) {
                return this.getBarycoord(t, e, n, i, oh), o.setScalar(0), o.addScaledVector(r, oh.x), o.addScaledVector(a, oh.y), o.addScaledVector(s, oh.z), o
            }
            static isFrontFacing(t, e, n, i) {
                return rh.subVectors(n, e), ah.subVectors(t, e), rh.cross(ah).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            }
            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return rh.subVectors(this.c, this.b), ah.subVectors(this.a, this.b), .5 * rh.cross(ah).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return mh.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return mh.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return !1 === fh && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), fh = !0), mh.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            getInterpolation(t, e, n, i, r) {
                return mh.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return mh.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return mh.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let a, s;
                lh.subVectors(i, n), ch.subVectors(r, n), uh.subVectors(t, n);
                const o = lh.dot(uh),
                    l = ch.dot(uh);
                if (o <= 0 && l <= 0) return e.copy(n);
                dh.subVectors(t, i);
                const c = lh.dot(dh),
                    h = ch.dot(dh);
                if (c >= 0 && h <= c) return e.copy(i);
                const u = o * h - c * l;
                if (u <= 0 && o >= 0 && c <= 0) return a = o / (o - c), e.copy(n).addScaledVector(lh, a);
                ph.subVectors(t, r);
                const d = lh.dot(ph),
                    p = ch.dot(ph);
                if (p >= 0 && d <= p) return e.copy(r);
                const f = d * l - o * p;
                if (f <= 0 && l >= 0 && p <= 0) return s = l / (l - p), e.copy(n).addScaledVector(ch, s);
                const m = c * p - d * h;
                if (m <= 0 && h - c >= 0 && d - p >= 0) return hh.subVectors(r, i), s = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(hh, s);
                const g = 1 / (m + f + u);
                return a = f * g, s = u * g, e.copy(n).addScaledVector(lh, a).addScaledVector(ch, s)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let gh = 0;
        class _h extends yl {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: gh++
                }), this.uuid = El(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Ro, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ml, this.stencilZFail = ml, this.stencilZPass = ml, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = this.alphaHash), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.forceSinglePass && (n.forceSinglePass = this.forceSinglePass), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
                    const e = i(t.textures),
                        r = i(t.images);
                    e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        const vh = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            xh = {
                h: 0,
                s: 0,
                l: 0
            },
            yh = {
                h: 0,
                s: 0,
                l: 0
            };

        function Mh(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        class Sh {
            constructor(t, e, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
            }
            set(t, e, n) {
                if (void 0 === e && void 0 === n) {
                    const e = t;
                    e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                } else this.setRGB(t, e, n);
                return this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t, e = dl) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, Wl.toWorkingColorSpace(this, e), this
            }
            setRGB(t, e, n, i = Wl.workingColorSpace) {
                return this.r = t, this.g = e, this.b = n, Wl.toWorkingColorSpace(this, i), this
            }
            setHSL(t, e, n, i = Wl.workingColorSpace) {
                if (t = function(t, e) {
                        return (t % e + e) % e
                    }(t, 1), e = bl(e, 0, 1), n = bl(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                        r = 2 * n - i;
                    this.r = Mh(r, i, t + 1 / 3), this.g = Mh(r, i, t), this.b = Mh(r, i, t - 1 / 3)
                }
                return Wl.toWorkingColorSpace(this, i), this
            }
            setStyle(t, e = dl) {
                function n(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                    let r;
                    const a = i[1],
                        s = i[2];
                    switch (a) {
                        case "rgb":
                        case "rgba":
                            if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                            if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                            break;
                        case "hsl":
                        case "hsla":
                            if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                            break;
                        default:
                            console.warn("THREE.Color: Unknown color model " + t)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const n = i[1],
                        r = n.length;
                    if (3 === r) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, e);
                    if (6 === r) return this.setHex(parseInt(n, 16), e);
                    console.warn("THREE.Color: Invalid hex color " + t)
                } else if (t && t.length > 0) return this.setColorName(t, e);
                return this
            }
            setColorName(t, e = dl) {
                const n = vh[t.toLowerCase()];
                return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copySRGBToLinear(t) {
                return this.r = zl(t.r), this.g = zl(t.g), this.b = zl(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = Bl(t.r), this.g = Bl(t.g), this.b = Bl(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(t = dl) {
                return Wl.fromWorkingColorSpace(Th.copy(this), t), 65536 * Math.round(bl(255 * Th.r, 0, 255)) + 256 * Math.round(bl(255 * Th.g, 0, 255)) + Math.round(bl(255 * Th.b, 0, 255))
            }
            getHexString(t = dl) {
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t, e = Wl.workingColorSpace) {
                Wl.fromWorkingColorSpace(Th.copy(this), e);
                const n = Th.r,
                    i = Th.g,
                    r = Th.b,
                    a = Math.max(n, i, r),
                    s = Math.min(n, i, r);
                let o, l;
                const c = (s + a) / 2;
                if (s === a) o = 0, l = 0;
                else {
                    const t = a - s;
                    switch (l = c <= .5 ? t / (a + s) : t / (2 - a - s), a) {
                        case n:
                            o = (i - r) / t + (i < r ? 6 : 0);
                            break;
                        case i:
                            o = (r - n) / t + 2;
                            break;
                        case r:
                            o = (n - i) / t + 4
                    }
                    o /= 6
                }
                return t.h = o, t.s = l, t.l = c, t
            }
            getRGB(t, e = Wl.workingColorSpace) {
                return Wl.fromWorkingColorSpace(Th.copy(this), e), t.r = Th.r, t.g = Th.g, t.b = Th.b, t
            }
            getStyle(t = dl) {
                Wl.fromWorkingColorSpace(Th.copy(this), t);
                const e = Th.r,
                    n = Th.g,
                    i = Th.b;
                return t !== dl ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*i)})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(xh), xh.h += t, xh.s += e, xh.l += n, this.setHSL(xh.h, xh.s, xh.l), this
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }
            lerpHSL(t, e) {
                this.getHSL(xh), t.getHSL(yh);
                const n = wl(xh.h, yh.h, e),
                    i = wl(xh.s, yh.s, e),
                    r = wl(xh.l, yh.l, e);
                return this.setHSL(n, i, r), this
            }
            setFromVector3(t) {
                return this.r = t.x, this.g = t.y, this.b = t.z, this
            }
            applyMatrix3(t) {
                const e = this.r,
                    n = this.g,
                    i = this.b,
                    r = t.elements;
                return this.r = r[0] * e + r[3] * n + r[6] * i, this.g = r[1] * e + r[4] * n + r[7] * i, this.b = r[2] * e + r[5] * n + r[8] * i, this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
            }
            toJSON() {
                return this.getHex()
            } * [Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        const Th = new Sh;
        Sh.NAMES = vh;
        class Eh extends _h {
            constructor(t) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Sh(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Co, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
            }
        }
        const bh = new nc,
            wh = new Ll;
        class Ah {
            constructor(t, e, n = !1) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = 35044, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.gpuType = Jo, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
            }
            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t), this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) wh.fromBufferAttribute(this, e), wh.applyMatrix3(t), this.setXY(e, wh.x, wh.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) bh.fromBufferAttribute(this, e), bh.applyMatrix3(t), this.setXYZ(e, bh.x, bh.y, bh.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++) bh.fromBufferAttribute(this, e), bh.applyMatrix4(t), this.setXYZ(e, bh.x, bh.y, bh.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) bh.fromBufferAttribute(this, e), bh.applyNormalMatrix(t), this.setXYZ(e, bh.x, bh.y, bh.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) bh.fromBufferAttribute(this, e), bh.transformDirection(t), this.setXYZ(e, bh.x, bh.y, bh.z);
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            getX(t) {
                let e = this.array[t * this.itemSize];
                return this.normalized && (e = Cl(e, this.array)), e
            }
            setX(t, e) {
                return this.normalized && (e = Pl(e, this.array)), this.array[t * this.itemSize] = e, this
            }
            getY(t) {
                let e = this.array[t * this.itemSize + 1];
                return this.normalized && (e = Cl(e, this.array)), e
            }
            setY(t, e) {
                return this.normalized && (e = Pl(e, this.array)), this.array[t * this.itemSize + 1] = e, this
            }
            getZ(t) {
                let e = this.array[t * this.itemSize + 2];
                return this.normalized && (e = Cl(e, this.array)), e
            }
            setZ(t, e) {
                return this.normalized && (e = Pl(e, this.array)), this.array[t * this.itemSize + 2] = e, this
            }
            getW(t) {
                let e = this.array[t * this.itemSize + 3];
                return this.normalized && (e = Cl(e, this.array)), e
            }
            setW(t, e) {
                return this.normalized && (e = Pl(e, this.array)), this.array[t * this.itemSize + 3] = e, this
            }
            setXY(t, e, n) {
                return t *= this.itemSize, this.normalized && (e = Pl(e, this.array), n = Pl(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize, this.normalized && (e = Pl(e, this.array), n = Pl(n, this.array), i = Pl(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize, this.normalized && (e = Pl(e, this.array), n = Pl(n, this.array), i = Pl(i, this.array), r = Pl(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
            }
        }
        class Rh extends Ah {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Ch extends Ah {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        class Ph extends Ah {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let Lh = 0;
        const Uh = new Uc,
            Dh = new ih,
            Ih = new nc,
            Nh = new ac,
            Oh = new ac,
            Fh = new nc;
        class zh extends yl {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: Lh++
                }), this.uuid = El(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new(Il(t) ? Ch : Rh)(t, 1) : this.index = t, this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }
            deleteAttribute(t) {
                return delete this.attributes[t], this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new Ul).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(t) {
                return Uh.makeRotationFromQuaternion(t), this.applyMatrix4(Uh), this
            }
            rotateX(t) {
                return Uh.makeRotationX(t), this.applyMatrix4(Uh), this
            }
            rotateY(t) {
                return Uh.makeRotationY(t), this.applyMatrix4(Uh), this
            }
            rotateZ(t) {
                return Uh.makeRotationZ(t), this.applyMatrix4(Uh), this
            }
            translate(t, e, n) {
                return Uh.makeTranslation(t, e, n), this.applyMatrix4(Uh), this
            }
            scale(t, e, n) {
                return Uh.makeScale(t, e, n), this.applyMatrix4(Uh), this
            }
            lookAt(t) {
                return Dh.lookAt(t), Dh.updateMatrix(), this.applyMatrix4(Dh.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Ih).negate(), this.translate(Ih.x, Ih.y, Ih.z), this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Ph(e, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new ac);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new nc(-1 / 0, -1 / 0, -1 / 0), new nc(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Nh.setFromBufferAttribute(n), this.morphTargetsRelative ? (Fh.addVectors(this.boundingBox.min, Nh.min), this.boundingBox.expandByPoint(Fh), Fh.addVectors(this.boundingBox.max, Nh.max), this.boundingBox.expandByPoint(Fh)) : (this.boundingBox.expandByPoint(Nh.min), this.boundingBox.expandByPoint(Nh.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Tc);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new nc, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (Nh.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Oh.setFromBufferAttribute(n), this.morphTargetsRelative ? (Fh.addVectors(Nh.min, Oh.min), Nh.expandByPoint(Fh), Fh.addVectors(Nh.max, Oh.max), Nh.expandByPoint(Fh)) : (Nh.expandByPoint(Oh.min), Nh.expandByPoint(Oh.max))
                        }
                    Nh.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++) Fh.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Fh));
                    if (e)
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r],
                                s = this.morphTargetsRelative;
                            for (let e = 0, r = a.count; e < r; e++) Fh.fromBufferAttribute(a, e), s && (Ih.fromBufferAttribute(t, e), Fh.add(Ih)), i = Math.max(i, n.distanceToSquared(Fh))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index,
                    e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array,
                    i = e.position.array,
                    r = e.normal.array,
                    a = e.uv.array,
                    s = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ah(new Float32Array(4 * s), 4));
                const o = this.getAttribute("tangent").array,
                    l = [],
                    c = [];
                for (let t = 0; t < s; t++) l[t] = new nc, c[t] = new nc;
                const h = new nc,
                    u = new nc,
                    d = new nc,
                    p = new Ll,
                    f = new Ll,
                    m = new Ll,
                    g = new nc,
                    _ = new nc;

                function v(t, e, n) {
                    h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(a, 2 * t), f.fromArray(a, 2 * e), m.fromArray(a, 2 * n), u.sub(h), d.sub(h), f.sub(p), m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), _.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(_), c[e].add(_), c[n].add(_))
                }
                let x = this.groups;
                0 === x.length && (x = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) v(n[t + 0], n[t + 1], n[t + 2])
                }
                const y = new nc,
                    M = new nc,
                    S = new nc,
                    T = new nc;

                function E(t) {
                    S.fromArray(r, 3 * t), T.copy(S);
                    const e = l[t];
                    y.copy(e), y.sub(S.multiplyScalar(S.dot(e))).normalize(), M.crossVectors(T, e);
                    const n = M.dot(c[t]) < 0 ? -1 : 1;
                    o[4 * t] = y.x, o[4 * t + 1] = y.y, o[4 * t + 2] = y.z, o[4 * t + 3] = n
                }
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) E(n[t + 0]), E(n[t + 1]), E(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Ah(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const i = new nc,
                        r = new nc,
                        a = new nc,
                        s = new nc,
                        o = new nc,
                        l = new nc,
                        c = new nc,
                        h = new nc;
                    if (t)
                        for (let u = 0, d = t.count; u < d; u += 3) {
                            const d = t.getX(u + 0),
                                p = t.getX(u + 1),
                                f = t.getX(u + 2);
                            i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), a.fromBufferAttribute(e, f), c.subVectors(a, r), h.subVectors(i, r), c.cross(h), s.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), s.add(c), o.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
                        } else
                            for (let t = 0, s = e.count; t < s; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), a.fromBufferAttribute(e, t + 2), c.subVectors(a, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) Fh.fromBufferAttribute(t, e), Fh.normalize(), t.setXYZ(e, Fh.x, Fh.y, Fh.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array,
                        i = t.itemSize,
                        r = t.normalized,
                        a = new n.constructor(e.length * i);
                    let s = 0,
                        o = 0;
                    for (let r = 0, l = e.length; r < l; r++) {
                        s = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                        for (let t = 0; t < i; t++) a[o++] = n[s++]
                    }
                    return new Ah(a, i, r)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new zh,
                    n = this.index.array,
                    i = this.attributes;
                for (const r in i) {
                    const a = t(i[r], n);
                    e.setAttribute(r, a)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const a = [],
                        s = r[i];
                    for (let e = 0, i = s.length; e < i; e++) {
                        const i = t(s[e], n);
                        a.push(i)
                    }
                    e.morphAttributes[i] = a
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const a = this.groups;
                for (let t = 0, n = a.length; t < n; t++) {
                    const n = a[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e],
                        a = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        a.push(i.toJSON(t.data))
                    }
                    a.length > 0 && (i[e] = a, r = !0)
                }
                r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const a = this.groups;
                a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
                const s = this.boundingSphere;
                return null !== s && (t.data.boundingSphere = {
                    center: s.center.toArray(),
                    radius: s.radius
                }), t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = [],
                        i = r[t];
                    for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const a = t.groups;
                for (let t = 0, e = a.length; t < e; t++) {
                    const e = a[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const s = t.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const o = t.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Bh = new Uc,
            kh = new Lc,
            Hh = new Tc,
            Vh = new nc,
            Gh = new nc,
            Wh = new nc,
            Xh = new nc,
            qh = new nc,
            jh = new nc,
            Yh = new Ll,
            Kh = new Ll,
            Zh = new Ll,
            Jh = new nc,
            Qh = new nc,
            $h = new nc,
            tu = new nc,
            eu = new nc;
        class nu extends ih {
            constructor(t = new zh, e = new Eh) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
            getVertexPosition(t, e) {
                const n = this.geometry,
                    i = n.attributes.position,
                    r = n.morphAttributes.position,
                    a = n.morphTargetsRelative;
                e.fromBufferAttribute(i, t);
                const s = this.morphTargetInfluences;
                if (r && s) {
                    jh.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = s[n],
                            o = r[n];
                        0 !== i && (qh.fromBufferAttribute(o, t), a ? jh.addScaledVector(qh, i) : jh.addScaledVector(qh.sub(e), i))
                    }
                    e.add(jh)
                }
                return e
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Hh.copy(n.boundingSphere), Hh.applyMatrix4(r), kh.copy(t.ray).recast(t.near), !1 === Hh.containsPoint(kh.origin)) {
                        if (null === kh.intersectSphere(Hh, Vh)) return;
                        if (kh.origin.distanceToSquared(Vh) > (t.far - t.near) ** 2) return
                    }
                    Bh.copy(r).invert(), kh.copy(t.ray).applyMatrix4(Bh), null !== n.boundingBox && !1 === kh.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, kh)
                }
            }
            _computeIntersections(t, e, n) {
                let i;
                const r = this.geometry,
                    a = this.material,
                    s = r.index,
                    o = r.attributes.position,
                    l = r.attributes.uv,
                    c = r.attributes.uv1,
                    h = r.attributes.normal,
                    u = r.groups,
                    d = r.drawRange;
                if (null !== s)
                    if (Array.isArray(a))
                        for (let r = 0, o = u.length; r < o; r++) {
                            const o = u[r],
                                p = a[o.materialIndex];
                            for (let r = Math.max(o.start, d.start), a = Math.min(s.count, Math.min(o.start + o.count, d.start + d.count)); r < a; r += 3) i = iu(this, p, t, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = o.materialIndex, e.push(i))
                        } else
                            for (let r = Math.max(0, d.start), o = Math.min(s.count, d.start + d.count); r < o; r += 3) i = iu(this, a, t, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), e.push(i));
                    else if (void 0 !== o)
                    if (Array.isArray(a))
                        for (let r = 0, s = u.length; r < s; r++) {
                            const s = u[r],
                                p = a[s.materialIndex];
                            for (let r = Math.max(s.start, d.start), a = Math.min(o.count, Math.min(s.start + s.count, d.start + d.count)); r < a; r += 3) i = iu(this, p, t, n, l, c, h, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = s.materialIndex, e.push(i))
                        } else
                            for (let r = Math.max(0, d.start), s = Math.min(o.count, d.start + d.count); r < s; r += 3) i = iu(this, a, t, n, l, c, h, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), e.push(i))
            }
        }

        function iu(t, e, n, i, r, a, s, o, l, c) {
            t.getVertexPosition(o, Gh), t.getVertexPosition(l, Wh), t.getVertexPosition(c, Xh);
            const h = function(t, e, n, i, r, a, s, o) {
                let l;
                if (l = 1 === e.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 0 === e.side, o), null === l) return null;
                eu.copy(o), eu.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(eu);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: eu.clone(),
                    object: t
                }
            }(t, e, n, i, Gh, Wh, Xh, tu);
            if (h) {
                r && (Yh.fromBufferAttribute(r, o), Kh.fromBufferAttribute(r, l), Zh.fromBufferAttribute(r, c), h.uv = mh.getInterpolation(tu, Gh, Wh, Xh, Yh, Kh, Zh, new Ll)), a && (Yh.fromBufferAttribute(a, o), Kh.fromBufferAttribute(a, l), Zh.fromBufferAttribute(a, c), h.uv1 = mh.getInterpolation(tu, Gh, Wh, Xh, Yh, Kh, Zh, new Ll), h.uv2 = h.uv1), s && (Jh.fromBufferAttribute(s, o), Qh.fromBufferAttribute(s, l), $h.fromBufferAttribute(s, c), h.normal = mh.getInterpolation(tu, Gh, Wh, Xh, Jh, Qh, $h, new nc), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
                const t = {
                    a: o,
                    b: l,
                    c: c,
                    normal: new nc,
                    materialIndex: 0
                };
                mh.getNormal(Gh, Wh, Xh, t.normal), h.face = t
            }
            return h
        }
        class ru extends zh {
            constructor(t = 1, e = 1, n = 1, i = 1, r = 1, a = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                const s = this;
                i = Math.floor(i), r = Math.floor(r), a = Math.floor(a);
                const o = [],
                    l = [],
                    c = [],
                    h = [];
                let u = 0,
                    d = 0;

                function p(t, e, n, i, r, a, p, f, m, g, _) {
                    const v = a / m,
                        x = p / g,
                        y = a / 2,
                        M = p / 2,
                        S = f / 2,
                        T = m + 1,
                        E = g + 1;
                    let b = 0,
                        w = 0;
                    const A = new nc;
                    for (let a = 0; a < E; a++) {
                        const s = a * x - M;
                        for (let o = 0; o < T; o++) {
                            const u = o * v - y;
                            A[t] = u * i, A[e] = s * r, A[n] = S, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / m), h.push(1 - a / g), b += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = u + e + T * t,
                                i = u + e + T * (t + 1),
                                r = u + (e + 1) + T * (t + 1),
                                a = u + (e + 1) + T * t;
                            o.push(n, i, a), o.push(i, r, a), w += 6
                        }
                    s.addGroup(d, w, _), d += w, u += b
                }
                p("z", "y", "x", -1, -1, n, e, t, a, r, 0), p("z", "y", "x", 1, -1, n, e, -t, a, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, a, 2), p("x", "z", "y", 1, -1, t, n, -e, i, a, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Ph(l, 3)), this.setAttribute("normal", new Ph(c, 3)), this.setAttribute("uv", new Ph(h, 2))
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
            static fromJSON(t) {
                return new ru(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
            }
        }

        function au(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }

        function su(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = au(t[n]);
                for (const t in i) e[t] = i[t]
            }
            return e
        }

        function ou(t) {
            return null === t.getRenderTarget() ? t.outputColorSpace : pl
        }
        const lu = {
            clone: au,
            merge: su
        };
        class cu extends _h {
            constructor(t) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = au(t.uniforms), this.uniformsGroups = function(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                    return e
                }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }
        }
        class hu extends ih {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Uc, this.projectionMatrix = new Uc, this.projectionMatrixInverse = new Uc, this.coordinateSystem = vl
            }
            copy(t, e) {
                return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class uu extends hu {
            constructor(t = 50, e = 1, n = .1, i = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Tl * Math.atan(e), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * Sl * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * Tl * Math.atan(Math.tan(.5 * Sl * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, i, r, a) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * Sl * this.fov) / this.zoom,
                    n = 2 * e,
                    i = this.aspect * n,
                    r = -.5 * i;
                const a = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = a.fullWidth,
                        s = a.fullHeight;
                    r += a.offsetX * i / t, e -= a.offsetY * n / s, i *= a.width / t, n *= a.height / s
                }
                const s = this.filmOffset;
                0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }
        const du = -90;
        class pu extends ih {
            constructor(t, e, n) {
                super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null;
                const i = new uu(du, 1, t, e);
                i.layers = this.layers, this.add(i);
                const r = new uu(du, 1, t, e);
                r.layers = this.layers, this.add(r);
                const a = new uu(du, 1, t, e);
                a.layers = this.layers, this.add(a);
                const s = new uu(du, 1, t, e);
                s.layers = this.layers, this.add(s);
                const o = new uu(du, 1, t, e);
                o.layers = this.layers, this.add(o);
                const l = new uu(du, 1, t, e);
                l.layers = this.layers, this.add(l)
            }
            updateCoordinateSystem() {
                const t = this.coordinateSystem,
                    e = this.children.concat(),
                    [n, i, r, a, s, o] = e;
                for (const t of e) this.remove(t);
                if (t === vl) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
                else {
                    if (t !== xl) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1)
                }
                for (const t of e) this.add(t), t.updateMatrixWorld()
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget;
                this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
                const [i, r, a, s, o, l] = this.children, c = t.getRenderTarget(), h = t.toneMapping, u = t.xr.enabled;
                t.toneMapping = Uo, t.xr.enabled = !1;
                const d = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = d, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(c), t.toneMapping = h, t.xr.enabled = u, n.texture.needsPMREMUpdate = !0
            }
        }
        class fu extends Jl {
            constructor(t, e, n, i, r, a, s, o, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : zo, n, i, r, a, s, o, l, c), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        class mu extends $l {
            constructor(t = 1, e = {}) {
                super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: t,
                        height: t,
                        depth: 1
                    },
                    i = [n, n, n, n, n, n];
                void 0 !== e.encoding && (Fl("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), e.colorSpace = e.encoding === ul ? dl : ""), this.texture = new fu(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : qo
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = new ru(5, 5, 5),
                    i = new cu({
                        name: "CubemapFromEquirect",
                        uniforms: au({
                            tEquirect: {
                                value: null
                            }
                        }),
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                        side: 1,
                        blending: 0
                    });
                i.uniforms.tEquirect.value = e;
                const r = new nu(n, i),
                    a = e.minFilter;
                return e.minFilter === jo && (e.minFilter = qo), new pu(1, 10, this).update(t, r), e.minFilter = a, r.geometry.dispose(), r.material.dispose(), this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        const gu = new nc,
            _u = new nc,
            vu = new Ul;
        class xu {
            constructor(t = new nc(1, 0, 0), e = 0) {
                this.isPlane = !0, this.normal = t, this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = gu.subVectors(n, e).cross(_u.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t), this
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
            }
            intersectLine(t, e) {
                const n = t.delta(gu),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || vu.getNormalMatrix(t),
                    i = this.coplanarPoint(gu).applyMatrix4(t),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const yu = new Tc,
            Mu = new nc;
        class Su {
            constructor(t = new xu, e = new xu, n = new xu, i = new xu, r = new xu, a = new xu) {
                this.planes = [t, e, n, i, r, a]
            }
            set(t, e, n, i, r, a) {
                const s = this.planes;
                return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t, e = 2e3) {
                const n = this.planes,
                    i = t.elements,
                    r = i[0],
                    a = i[1],
                    s = i[2],
                    o = i[3],
                    l = i[4],
                    c = i[5],
                    h = i[6],
                    u = i[7],
                    d = i[8],
                    p = i[9],
                    f = i[10],
                    m = i[11],
                    g = i[12],
                    _ = i[13],
                    v = i[14],
                    x = i[15];
                if (n[0].setComponents(o - r, u - l, m - d, x - g).normalize(), n[1].setComponents(o + r, u + l, m + d, x + g).normalize(), n[2].setComponents(o + a, u + c, m + p, x + _).normalize(), n[3].setComponents(o - a, u - c, m - p, x - _).normalize(), n[4].setComponents(o - s, u - h, m - f, x - v).normalize(), e === vl) n[5].setComponents(o + s, u + h, m + f, x + v).normalize();
                else {
                    if (e !== xl) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    n[5].setComponents(s, h, f, v).normalize()
                }
                return this
            }
            intersectsObject(t) {
                if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), yu.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                else {
                    const e = t.geometry;
                    null === e.boundingSphere && e.computeBoundingSphere(), yu.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                }
                return this.intersectsSphere(yu)
            }
            intersectsSprite(t) {
                return yu.center.set(0, 0, 0), yu.radius = .7071067811865476, yu.applyMatrix4(t.matrixWorld), this.intersectsSphere(yu)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    i = -t.radius;
                for (let t = 0; t < 6; t++)
                    if (e[t].distanceToPoint(n) < i) return !1;
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (Mu.x = i.normal.x > 0 ? t.max.x : t.min.x, Mu.y = i.normal.y > 0 ? t.max.y : t.min.y, Mu.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Mu) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Tu() {
            let t = null,
                e = !1,
                n = null,
                i = null;

            function r(e, a) {
                n(e, a), i = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(i), e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }

        function Eu(t, e) {
            const n = e.isWebGL2,
                i = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer), i.delete(e))
                },
                update: function(e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const a = i.get(e);
                    void 0 === a ? i.set(e, function(e, i) {
                        const r = e.array,
                            a = e.usage,
                            s = t.createBuffer();
                        let o;
                        if (t.bindBuffer(i, s), t.bufferData(i, r, a), e.onUploadCallback(), r instanceof Float32Array) o = t.FLOAT;
                        else if (r instanceof Uint16Array)
                            if (e.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                o = t.HALF_FLOAT
                            } else o = t.UNSIGNED_SHORT;
                        else if (r instanceof Int16Array) o = t.SHORT;
                        else if (r instanceof Uint32Array) o = t.UNSIGNED_INT;
                        else if (r instanceof Int32Array) o = t.INT;
                        else if (r instanceof Int8Array) o = t.BYTE;
                        else if (r instanceof Uint8Array) o = t.UNSIGNED_BYTE;
                        else {
                            if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                            o = t.UNSIGNED_BYTE
                        }
                        return {
                            buffer: s,
                            type: o,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : a.version < e.version && (function(e, i, r) {
                        const a = i.array,
                            s = i.updateRange;
                        t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, a) : (n ? t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1), i.onUploadCallback()
                    }(a.buffer, e, r), a.version = e.version)
                }
            }
        }
        class bu extends zh {
            constructor(t = 1, e = 1, n = 1, i = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2,
                    a = e / 2,
                    s = Math.floor(n),
                    o = Math.floor(i),
                    l = s + 1,
                    c = o + 1,
                    h = t / s,
                    u = e / o,
                    d = [],
                    p = [],
                    f = [],
                    m = [];
                for (let t = 0; t < c; t++) {
                    const e = t * u - a;
                    for (let n = 0; n < l; n++) {
                        const i = n * h - r;
                        p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / o)
                    }
                }
                for (let t = 0; t < o; t++)
                    for (let e = 0; e < s; e++) {
                        const n = e + l * t,
                            i = e + l * (t + 1),
                            r = e + 1 + l * (t + 1),
                            a = e + 1 + l * t;
                        d.push(n, i, a), d.push(i, r, a)
                    }
                this.setIndex(d), this.setAttribute("position", new Ph(p, 3)), this.setAttribute("normal", new Ph(f, 3)), this.setAttribute("uv", new Ph(m, 2))
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
            static fromJSON(t) {
                return new bu(t.width, t.height, t.widthSegments, t.heightSegments)
            }
        }
        const wu = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            },
            Au = {
                common: {
                    diffuse: {
                        value: new Sh(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Ul
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ul
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new Ul
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new Ul
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new Ul
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new Ul
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new Ul
                    },
                    normalScale: {
                        value: new Ll(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new Ul
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new Ul
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new Ul
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new Ul
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Sh(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new Sh(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ul
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new Ul
                    }
                },
                sprite: {
                    diffuse: {
                        value: new Sh(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Ll(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Ul
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ul
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            },
            Ru = {
                basic: {
                    uniforms: su([Au.common, Au.specularmap, Au.envmap, Au.aomap, Au.lightmap, Au.fog]),
                    vertexShader: wu.meshbasic_vert,
                    fragmentShader: wu.meshbasic_frag
                },
                lambert: {
                    uniforms: su([Au.common, Au.specularmap, Au.envmap, Au.aomap, Au.lightmap, Au.emissivemap, Au.bumpmap, Au.normalmap, Au.displacementmap, Au.fog, Au.lights, {
                        emissive: {
                            value: new Sh(0)
                        }
                    }]),
                    vertexShader: wu.meshlambert_vert,
                    fragmentShader: wu.meshlambert_frag
                },
                phong: {
                    uniforms: su([Au.common, Au.specularmap, Au.envmap, Au.aomap, Au.lightmap, Au.emissivemap, Au.bumpmap, Au.normalmap, Au.displacementmap, Au.fog, Au.lights, {
                        emissive: {
                            value: new Sh(0)
                        },
                        specular: {
                            value: new Sh(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: wu.meshphong_vert,
                    fragmentShader: wu.meshphong_frag
                },
                standard: {
                    uniforms: su([Au.common, Au.envmap, Au.aomap, Au.lightmap, Au.emissivemap, Au.bumpmap, Au.normalmap, Au.displacementmap, Au.roughnessmap, Au.metalnessmap, Au.fog, Au.lights, {
                        emissive: {
                            value: new Sh(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: wu.meshphysical_vert,
                    fragmentShader: wu.meshphysical_frag
                },
                toon: {
                    uniforms: su([Au.common, Au.aomap, Au.lightmap, Au.emissivemap, Au.bumpmap, Au.normalmap, Au.displacementmap, Au.gradientmap, Au.fog, Au.lights, {
                        emissive: {
                            value: new Sh(0)
                        }
                    }]),
                    vertexShader: wu.meshtoon_vert,
                    fragmentShader: wu.meshtoon_frag
                },
                matcap: {
                    uniforms: su([Au.common, Au.bumpmap, Au.normalmap, Au.displacementmap, Au.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: wu.meshmatcap_vert,
                    fragmentShader: wu.meshmatcap_frag
                },
                points: {
                    uniforms: su([Au.points, Au.fog]),
                    vertexShader: wu.points_vert,
                    fragmentShader: wu.points_frag
                },
                dashed: {
                    uniforms: su([Au.common, Au.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: wu.linedashed_vert,
                    fragmentShader: wu.linedashed_frag
                },
                depth: {
                    uniforms: su([Au.common, Au.displacementmap]),
                    vertexShader: wu.depth_vert,
                    fragmentShader: wu.depth_frag
                },
                normal: {
                    uniforms: su([Au.common, Au.bumpmap, Au.normalmap, Au.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: wu.meshnormal_vert,
                    fragmentShader: wu.meshnormal_frag
                },
                sprite: {
                    uniforms: su([Au.sprite, Au.fog]),
                    vertexShader: wu.sprite_vert,
                    fragmentShader: wu.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Ul
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: wu.background_vert,
                    fragmentShader: wu.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: wu.backgroundCube_vert,
                    fragmentShader: wu.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: wu.cube_vert,
                    fragmentShader: wu.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: wu.equirect_vert,
                    fragmentShader: wu.equirect_frag
                },
                distanceRGBA: {
                    uniforms: su([Au.common, Au.displacementmap, {
                        referencePosition: {
                            value: new nc
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: wu.distanceRGBA_vert,
                    fragmentShader: wu.distanceRGBA_frag
                },
                shadow: {
                    uniforms: su([Au.lights, Au.fog, {
                        color: {
                            value: new Sh(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: wu.shadow_vert,
                    fragmentShader: wu.shadow_frag
                }
            };
        Ru.physical = {
            uniforms: su([Ru.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Ul
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Ul
                },
                clearcoatNormalScale: {
                    value: new Ll(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Ul
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Ul
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Ul
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Sh(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Ul
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Ul
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Ul
                },
                transmissionSamplerSize: {
                    value: new Ll
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Ul
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Sh(0)
                },
                specularColor: {
                    value: new Sh(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Ul
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Ul
                },
                anisotropyVector: {
                    value: new Ll
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Ul
                }
            }]),
            vertexShader: wu.meshphysical_vert,
            fragmentShader: wu.meshphysical_frag
        };
        const Cu = {
            r: 0,
            b: 0,
            g: 0
        };

        function Pu(t, e, n, i, r, a, s) {
            const o = new Sh(0);
            let l, c, h = !0 === a ? 0 : 1,
                u = null,
                d = 0,
                p = null;

            function f(e, n) {
                e.getRGB(Cu, ou(t)), i.buffers.color.setClear(Cu.r, Cu.g, Cu.b, n, s)
            }
            return {
                getClearColor: function() {
                    return o
                },
                setClearColor: function(t, e = 1) {
                    o.set(t), h = e, f(o, h)
                },
                getClearAlpha: function() {
                    return h
                },
                setClearAlpha: function(t) {
                    h = t, f(o, h)
                },
                render: function(a, m) {
                    let g = !1,
                        _ = !0 === m.isScene ? m.background : null;
                    switch (_ && _.isTexture && (_ = (m.backgroundBlurriness > 0 ? n : e).get(_)), null === _ ? f(o, h) : _ && _.isColor && (f(_, 1), g = !0), t.xr.getEnvironmentBlendMode()) {
                        case "opaque":
                            g = !0;
                            break;
                        case "additive":
                            i.buffers.color.setClear(0, 0, 0, 1, s), g = !0;
                            break;
                        case "alpha-blend":
                            i.buffers.color.setClear(0, 0, 0, 0, s), g = !0
                    }(t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), _ && (_.isCubeTexture || _.mapping === ko) ? (void 0 === c && (c = new nu(new ru(1, 1, 1), new cu({
                        name: "BackgroundCubeMaterial",
                        uniforms: au(Ru.backgroundCube.uniforms),
                        vertexShader: Ru.backgroundCube.vertexShader,
                        fragmentShader: Ru.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(c)), c.material.uniforms.envMap.value = _, c.material.uniforms.flipEnvMap.value = _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.toneMapped = _.colorSpace !== dl, u === _ && d === _.version && p === t.toneMapping || (c.material.needsUpdate = !0, u = _, d = _.version, p = t.toneMapping), c.layers.enableAll(), a.unshift(c, c.geometry, c.material, 0, 0, null)) : _ && _.isTexture && (void 0 === l && (l = new nu(new bu(2, 2), new cu({
                        name: "BackgroundMaterial",
                        uniforms: au(Ru.background.uniforms),
                        vertexShader: Ru.background.vertexShader,
                        fragmentShader: Ru.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(l)), l.material.uniforms.t2D.value = _, l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, l.material.toneMapped = _.colorSpace !== dl, !0 === _.matrixAutoUpdate && _.updateMatrix(), l.material.uniforms.uvTransform.value.copy(_.matrix), u === _ && d === _.version && p === t.toneMapping || (l.material.needsUpdate = !0, u = _, d = _.version, p = t.toneMapping), l.layers.enableAll(), a.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function Lu(t, e, n, i) {
            const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                a = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                s = i.isWebGL2 || null !== a,
                o = {},
                l = p(null);
            let c = l,
                h = !1;

            function u(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e)
            }

            function d(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : a.deleteVertexArrayOES(e)
            }

            function p(t) {
                const e = [],
                    n = [],
                    i = [];
                for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function f() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function m(t) {
                g(t, 0)
            }

            function g(n, r) {
                const a = c.newAttributes,
                    s = c.enabledAttributes,
                    o = c.attributeDivisors;
                a[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), o[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r)
            }

            function _() {
                const e = c.newAttributes,
                    n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
            }

            function v(e, n, i, r, a, s, o) {
                !0 === o ? t.vertexAttribIPointer(e, n, i, a, s) : t.vertexAttribPointer(e, n, i, r, a, s)
            }

            function x() {
                y(), h = !0, c !== l && (c = l, u(c.object))
            }

            function y() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function(r, l, d, x, y) {
                    let M = !1;
                    if (s) {
                        const e = function(e, n, r) {
                            const s = !0 === r.wireframe;
                            let l = o[e.id];
                            void 0 === l && (l = {}, o[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {}, l[n.id] = c);
                            let h = c[s];
                            return void 0 === h && (h = p(i.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES()), c[s] = h), h
                        }(x, d, l);
                        c !== e && (c = e, u(c.object)), M = function(t, e, n, i) {
                            const r = c.attributes,
                                a = e.attributes;
                            let s = 0;
                            const o = n.getAttributes();
                            for (const e in o)
                                if (o[e].location >= 0) {
                                    const n = r[e];
                                    let i = a[e];
                                    if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor)), void 0 === n) return !0;
                                    if (n.attribute !== i) return !0;
                                    if (i && n.data !== i.data) return !0;
                                    s++
                                }
                            return c.attributesNum !== s || c.index !== i
                        }(r, x, d, y), M && function(t, e, n, i) {
                            const r = {},
                                a = e.attributes;
                            let s = 0;
                            const o = n.getAttributes();
                            for (const e in o)
                                if (o[e].location >= 0) {
                                    let n = a[e];
                                    void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                    const i = {};
                                    i.attribute = n, n && n.data && (i.data = n.data), r[e] = i, s++
                                }
                            c.attributes = r, c.attributesNum = s, c.index = i
                        }(r, x, d, y)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === x.id && c.program === d.id && c.wireframe === t || (c.geometry = x.id, c.program = d.id, c.wireframe = t, M = !0)
                    }
                    null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER), (M || h) && (h = !1, function(r, a, s, o) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        f();
                        const l = o.attributes,
                            c = s.getAttributes(),
                            h = a.defaultAttributeValues;
                        for (const e in c) {
                            const a = c[e];
                            if (a.location >= 0) {
                                let s = l[e];
                                if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                    const e = s.normalized,
                                        l = s.itemSize,
                                        c = n.get(s);
                                    if (void 0 === c) continue;
                                    const h = c.buffer,
                                        u = c.type,
                                        d = c.bytesPerElement,
                                        p = !0 === i.isWebGL2 && (u === t.INT || u === t.UNSIGNED_INT || 1013 === s.gpuType);
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data,
                                            i = n.stride,
                                            c = s.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < a.locationSize; t++) g(a.location + t, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < a.locationSize; t++) m(a.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, h);
                                        for (let t = 0; t < a.locationSize; t++) v(a.location + t, l / a.locationSize, u, e, i * d, (c + l / a.locationSize * t) * d, p)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let t = 0; t < a.locationSize; t++) g(a.location + t, s.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let t = 0; t < a.locationSize; t++) m(a.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, h);
                                        for (let t = 0; t < a.locationSize; t++) v(a.location + t, l / a.locationSize, u, e, l * d, l / a.locationSize * t * d, p)
                                    }
                                } else if (void 0 !== h) {
                                    const n = h[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(a.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(a.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(a.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(a.location, n)
                                    }
                                }
                            }
                        }
                        _()
                    }(r, l, d, x), null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer))
                },
                reset: x,
                resetDefaultState: y,
                dispose: function() {
                    x();
                    for (const t in o) {
                        const e = o[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) d(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete o[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === o[t.id]) return;
                    const e = o[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) d(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete o[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in o) {
                        const n = o[e];
                        if (void 0 === n[t.id]) continue;
                        const i = n[t.id];
                        for (const t in i) d(i[t].object), delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: _
            }
        }

        function Uu(t, e, n, i) {
            const r = i.isWebGL2;
            let a;
            this.setMode = function(t) {
                a = t
            }, this.render = function(e, i) {
                t.drawArrays(a, e, i), n.update(i, a, 1)
            }, this.renderInstances = function(i, s, o) {
                if (0 === o) return;
                let l, c;
                if (r) l = t, c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](a, i, s, o), n.update(s, a, o)
            }
        }

        function Du(t, e, n) {
            let i;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const a = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
            let s = void 0 !== n.precision ? n.precision : "highp";
            const o = r(s);
            o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
            const l = a || e.has("WEBGL_draw_buffers"),
                c = !0 === n.logarithmicDepthBuffer,
                h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                d = t.getParameter(t.MAX_TEXTURE_SIZE),
                p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                g = t.getParameter(t.MAX_VARYING_VECTORS),
                _ = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                v = u > 0,
                x = a || e.has("OES_texture_float");
            return {
                isWebGL2: a,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== i) return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: s,
                logarithmicDepthBuffer: c,
                maxTextures: h,
                maxVertexTextures: u,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: _,
                vertexTextures: v,
                floatFragmentTextures: x,
                floatVertexTextures: v && x,
                maxSamples: a ? t.getParameter(t.MAX_SAMPLES) : 0
            }
        }

        function Iu(t) {
            const e = this;
            let n = null,
                i = 0,
                r = !1,
                a = !1;
            const s = new xu,
                o = new Ul,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function c(t, n, i, r) {
                const a = null !== t ? t.length : 0;
                let c = null;
                if (0 !== a) {
                    if (c = l.value, !0 !== r || null === c) {
                        const e = i + 4 * a,
                            r = n.matrixWorldInverse;
                        o.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = i; e !== a; ++e, n += 4) s.copy(t[e]).applyMatrix4(r, o), s.normal.toArray(c, n), c[n + 3] = s.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return e.numPlanes = a, e.numIntersection = 0, c
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e) {
                const n = 0 !== t.length || e || 0 !== i || r;
                return r = e, i = t.length, n
            }, this.beginShadows = function() {
                a = !0, c(null)
            }, this.endShadows = function() {
                a = !1
            }, this.setGlobalState = function(t, e) {
                n = c(t, e, 0)
            }, this.setState = function(s, o, h) {
                const u = s.clippingPlanes,
                    d = s.clipIntersection,
                    p = s.clipShadows,
                    f = t.get(s);
                if (!r || null === u || 0 === u.length || a && !p) a ? c(null) : (l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0);
                else {
                    const t = a ? 0 : i,
                        e = 4 * t;
                    let r = f.clippingState || null;
                    l.value = r, r = c(u, o, e, h);
                    for (let t = 0; t !== e; ++t) r[t] = n[t];
                    f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function Nu(t) {
            let e = new WeakMap;

            function n(t, e) {
                return 303 === e ? t.mapping = zo : 304 === e && (t.mapping = Bo), t
            }

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const a = r.mapping;
                        if (303 === a || 304 === a) {
                            if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                const a = r.image;
                                if (a && a.height > 0) {
                                    const s = new mu(a.height / 2);
                                    return s.fromEquirectangularTexture(t, r), e.set(r, s), r.addEventListener("dispose", i), n(s.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        class Ou extends hu {
            constructor(t = -1, e = 1, n = 1, i = -1, r = .1, a = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }
            setViewOffset(t, e, n, i, r, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - t,
                    a = n + t,
                    s = i + e,
                    o = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX, a = r + t * this.view.width, s -= e * this.view.offsetY, o = s - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }
        const Fu = [.125, .215, .35, .446, .526, .582],
            zu = new Ou,
            Bu = new Sh;
        let ku = null;
        const Hu = (1 + Math.sqrt(5)) / 2,
            Vu = 1 / Hu,
            Gu = [new nc(1, 1, 1), new nc(-1, 1, 1), new nc(1, 1, -1), new nc(-1, 1, -1), new nc(0, Hu, Vu), new nc(0, Hu, -Vu), new nc(Vu, 0, Hu), new nc(-Vu, 0, Hu), new nc(Hu, Vu, 0), new nc(-Hu, Vu, 0)];
        class Wu {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e = 0, n = .1, i = 100) {
                ku = this._renderer.getRenderTarget(), this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0, this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            }
            fromEquirectangular(t, e = null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e = null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Yu(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = ju(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(ku), t.scissorTest = !1, qu(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === zo || t.mapping === Bo ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), ku = this._renderer.getRenderTarget();
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112),
                    e = 4 * this._cubeSize,
                    n = {
                        magFilter: qo,
                        minFilter: qo,
                        generateMipmaps: !1,
                        type: Qo,
                        format: tl,
                        colorSpace: pl,
                        depthBuffer: !1
                    },
                    i = Xu(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Xu(t, e, n);
                    const {
                        _lodMax: i
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function(t) {
                        const e = [],
                            n = [],
                            i = [];
                        let r = t;
                        const a = t - 4 + 1 + Fu.length;
                        for (let s = 0; s < a; s++) {
                            const a = Math.pow(2, r);
                            n.push(a);
                            let o = 1 / a;
                            s > t - 4 ? o = Fu[s - t + 4 - 1] : 0 === s && (o = 0), i.push(o);
                            const l = 1 / (a - 2),
                                c = -l,
                                h = 1 + l,
                                u = [c, c, h, c, h, h, c, c, h, h, c, h],
                                d = 6,
                                p = 6,
                                f = 3,
                                m = 2,
                                g = 1,
                                _ = new Float32Array(f * p * d),
                                v = new Float32Array(m * p * d),
                                x = new Float32Array(g * p * d);
                            for (let t = 0; t < d; t++) {
                                const e = t % 3 * 2 / 3 - 1,
                                    n = t > 2 ? 0 : -1,
                                    i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                _.set(i, f * p * t), v.set(u, m * p * t);
                                const r = [t, t, t, t, t, t];
                                x.set(r, g * p * t)
                            }
                            const y = new zh;
                            y.setAttribute("position", new Ah(_, f)), y.setAttribute("uv", new Ah(v, m)), y.setAttribute("faceIndex", new Ah(x, g)), e.push(y), r > 4 && r--
                        }
                        return {
                            lodPlanes: e,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)), this._blurMaterial = function(t, e, n) {
                        const i = new Float32Array(20),
                            r = new nc(0, 1, 0);
                        return new cu({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${t}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(i, t, e)
                }
                return i
            }
            _compileMaterial(t) {
                const e = new nu(this._lodPlanes[0], t);
                this._renderer.compile(e, zu)
            }
            _sceneToCubeUV(t, e, n, i) {
                const r = new uu(90, 1, e, n),
                    a = [1, -1, 1, 1, 1, 1],
                    s = [1, 1, 1, -1, -1, -1],
                    o = this._renderer,
                    l = o.autoClear,
                    c = o.toneMapping;
                o.getClearColor(Bu), o.toneMapping = Uo, o.autoClear = !1;
                const h = new Eh({
                        name: "PMREM.Background",
                        side: 1,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    u = new nu(new ru, h);
                let d = !1;
                const p = t.background;
                p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(Bu), d = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (r.up.set(0, a[e], 0), r.lookAt(s[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, a[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, a[e], 0), r.lookAt(0, 0, s[e]));
                    const l = this._cubeSize;
                    qu(i, n * l, e > 2 ? l : 0, l, l), o.setRenderTarget(i), d && o.render(u, r), o.render(t, r)
                }
                u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = p
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer,
                    i = t.mapping === zo || t.mapping === Bo;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Yu()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = ju());
                const r = i ? this._cubemapMaterial : this._equirectMaterial,
                    a = new nu(this._lodPlanes[0], r);
                r.uniforms.envMap.value = t;
                const s = this._cubeSize;
                qu(e, 0, 0, 3 * s, 2 * s), n.setRenderTarget(e), n.render(a, zu)
            }
            _applyPMREM(t) {
                const e = this._renderer,
                    n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                        i = Gu[(e - 1) % Gu.length];
                    this._blur(t, e - 1, e, n, i)
                }
                e.autoClear = n
            }
            _blur(t, e, n, i, r) {
                const a = this._pingPongRenderTarget;
                this._halfBlur(t, a, e, n, i, "latitudinal", r), this._halfBlur(a, t, n, n, i, "longitudinal", r)
            }
            _halfBlur(t, e, n, i, r, a, s) {
                const o = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new nu(this._lodPlanes[i], l),
                    h = l.uniforms,
                    u = this._sizeLods[n] - 1,
                    d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                    p = r / d,
                    f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let t = 0; t < 20; ++t) {
                    const e = t / p,
                        n = Math.exp(-e * e / 2);
                    m.push(n), 0 === t ? g += n : t < f && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === a, s && (h.poleAxis.value = s);
                const {
                    _lodMax: _
                } = this;
                h.dTheta.value = d, h.mipInt.value = _ - n;
                const v = this._sizeLods[i];
                qu(e, 3 * v * (i > _ - 4 ? i - _ + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, zu)
            }
        }

        function Xu(t, e, n) {
            const i = new $l(t, e, n);
            return i.texture.mapping = ko, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
        }

        function qu(t, e, n, i, r) {
            t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
        }

        function ju() {
            return new cu({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Yu() {
            return new cu({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Ku(t) {
            let e = new WeakMap,
                n = null;

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const a = r.mapping,
                            s = 303 === a || 304 === a,
                            o = a === zo || a === Bo;
                        if (s || o) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let i = e.get(r);
                                return null === n && (n = new Wu(t)), i = s ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
                            }
                            if (e.has(r)) return e.get(r).texture; {
                                const a = r.image;
                                if (s && a && a.height > 0 || o && a && function(t) {
                                        let e = 0;
                                        for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                        return 6 === e
                                    }(a)) {
                                    null === n && (n = new Wu(t));
                                    const a = s ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return e.set(r, a), r.addEventListener("dispose", i), a.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function Zu(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return e[n] = i, i
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                }
            }
        }

        function Ju(t, e, n, i) {
            const r = {},
                a = new WeakMap;

            function s(t) {
                const o = t.target;
                null !== o.index && e.remove(o.index);
                for (const t in o.attributes) e.remove(o.attributes[t]);
                for (const t in o.morphAttributes) {
                    const n = o.morphAttributes[t];
                    for (let t = 0, i = n.length; t < i; t++) e.remove(n[t])
                }
                o.removeEventListener("dispose", s), delete r[o.id];
                const l = a.get(o);
                l && (e.remove(l), a.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
            }

            function o(t) {
                const n = [],
                    i = t.index,
                    r = t.attributes.position;
                let s = 0;
                if (null !== i) {
                    const t = i.array;
                    s = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0],
                            r = t[e + 1],
                            a = t[e + 2];
                        n.push(i, r, r, a, a, i)
                    }
                } else {
                    const t = r.array;
                    s = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0,
                            i = e + 1,
                            r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const o = new(Il(n) ? Ch : Rh)(n, 1);
                o.version = s;
                const l = a.get(t);
                l && e.remove(l), a.set(t, o)
            }
            return {
                get: function(t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", s), r[e.id] = !0, n.memory.geometries++), e
                },
                update: function(n) {
                    const i = n.attributes;
                    for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
                    const r = n.morphAttributes;
                    for (const n in r) {
                        const i = r[n];
                        for (let n = 0, r = i.length; n < r; n++) e.update(i[n], t.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = a.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && o(t)
                    } else o(t);
                    return a.get(t)
                }
            }
        }

        function Qu(t, e, n, i) {
            const r = i.isWebGL2;
            let a, s, o;
            this.setMode = function(t) {
                a = t
            }, this.setIndex = function(t) {
                s = t.type, o = t.bytesPerElement
            }, this.render = function(e, i) {
                t.drawElements(a, i, s, e * o), n.update(i, a, 1)
            }, this.renderInstances = function(i, l, c) {
                if (0 === c) return;
                let h, u;
                if (r) h = t, u = "drawElementsInstanced";
                else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[u](a, l, s, i * o, c), n.update(l, a, c)
            }
        }

        function $u(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function(n, i, r) {
                    switch (e.calls++, i) {
                        case t.TRIANGLES:
                            e.triangles += r * (n / 3);
                            break;
                        case t.LINES:
                            e.lines += r * (n / 2);
                            break;
                        case t.LINE_STRIP:
                            e.lines += r * (n - 1);
                            break;
                        case t.LINE_LOOP:
                            e.lines += r * n;
                            break;
                        case t.POINTS:
                            e.points += r * n;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }

        function td(t, e) {
            return t[0] - e[0]
        }

        function ed(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function nd(t, e, n) {
            const i = {},
                r = new Float32Array(8),
                a = new WeakMap,
                s = new Ql,
                o = [];
            for (let t = 0; t < 8; t++) o[t] = [t, 0];
            return {
                update: function(l, c, h) {
                    const u = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const d = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                            p = void 0 !== d ? d.length : 0;
                        let f = a.get(c);
                        if (void 0 === f || f.count !== p) {
                            void 0 !== f && f.texture.dispose();
                            const _ = void 0 !== c.morphAttributes.position,
                                v = void 0 !== c.morphAttributes.normal,
                                x = void 0 !== c.morphAttributes.color,
                                y = c.morphAttributes.position || [],
                                M = c.morphAttributes.normal || [],
                                S = c.morphAttributes.color || [];
                            let T = 0;
                            !0 === _ && (T = 1), !0 === v && (T = 2), !0 === x && (T = 3);
                            let E = c.attributes.position.count * T,
                                b = 1;
                            E > e.maxTextureSize && (b = Math.ceil(E / e.maxTextureSize), E = e.maxTextureSize);
                            const w = new Float32Array(E * b * 4 * p),
                                A = new tc(w, E, b, p);
                            A.type = Jo, A.needsUpdate = !0;
                            const R = 4 * T;
                            for (let P = 0; P < p; P++) {
                                const L = y[P],
                                    U = M[P],
                                    D = S[P],
                                    I = E * b * 4 * P;
                                for (let N = 0; N < L.count; N++) {
                                    const O = N * R;
                                    !0 === _ && (s.fromBufferAttribute(L, N), w[I + O + 0] = s.x, w[I + O + 1] = s.y, w[I + O + 2] = s.z, w[I + O + 3] = 0), !0 === v && (s.fromBufferAttribute(U, N), w[I + O + 4] = s.x, w[I + O + 5] = s.y, w[I + O + 6] = s.z, w[I + O + 7] = 0), !0 === x && (s.fromBufferAttribute(D, N), w[I + O + 8] = s.x, w[I + O + 9] = s.y, w[I + O + 10] = s.z, w[I + O + 11] = 4 === D.itemSize ? s.w : 1)
                                }
                            }

                            function C() {
                                A.dispose(), a.delete(c), c.removeEventListener("dispose", C)
                            }
                            f = {
                                count: p,
                                texture: A,
                                size: new Ll(E, b)
                            }, a.set(c, f), c.addEventListener("dispose", C)
                        }
                        let m = 0;
                        for (let F = 0; F < u.length; F++) m += u[F];
                        const g = c.morphTargetsRelative ? 1 : 1 - m;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", g), h.getUniforms().setValue(t, "morphTargetInfluences", u), h.getUniforms().setValue(t, "morphTargetsTexture", f.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", f.size)
                    } else {
                        const z = void 0 === u ? 0 : u.length;
                        let B = i[c.id];
                        if (void 0 === B || B.length !== z) {
                            B = [];
                            for (let W = 0; W < z; W++) B[W] = [W, 0];
                            i[c.id] = B
                        }
                        for (let X = 0; X < z; X++) {
                            const q = B[X];
                            q[0] = X, q[1] = u[X]
                        }
                        B.sort(ed);
                        for (let j = 0; j < 8; j++) j < z && B[j][1] ? (o[j][0] = B[j][0], o[j][1] = B[j][1]) : (o[j][0] = Number.MAX_SAFE_INTEGER, o[j][1] = 0);
                        o.sort(td);
                        const k = c.morphAttributes.position,
                            H = c.morphAttributes.normal;
                        let V = 0;
                        for (let Y = 0; Y < 8; Y++) {
                            const K = o[Y],
                                Z = K[0],
                                J = K[1];
                            Z !== Number.MAX_SAFE_INTEGER && J ? (k && c.getAttribute("morphTarget" + Y) !== k[Z] && c.setAttribute("morphTarget" + Y, k[Z]), H && c.getAttribute("morphNormal" + Y) !== H[Z] && c.setAttribute("morphNormal" + Y, H[Z]), r[Y] = J, V += J) : (k && !0 === c.hasAttribute("morphTarget" + Y) && c.deleteAttribute("morphTarget" + Y), H && !0 === c.hasAttribute("morphNormal" + Y) && c.deleteAttribute("morphNormal" + Y), r[Y] = 0)
                        }
                        const G = c.morphTargetsRelative ? 1 : 1 - V;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", G), h.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }
        }

        function id(t, e, n, i) {
            let r = new WeakMap;

            function a(t) {
                const e = t.target;
                e.removeEventListener("dispose", a), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(s) {
                    const o = i.render.frame,
                        l = s.geometry,
                        c = e.get(s, l);
                    if (r.get(c) !== o && (e.update(c), r.set(c, o)), s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a), r.get(s) !== o && (n.update(s.instanceMatrix, t.ARRAY_BUFFER), null !== s.instanceColor && n.update(s.instanceColor, t.ARRAY_BUFFER), r.set(s, o))), s.isSkinnedMesh) {
                        const t = s.skeleton;
                        r.get(t) !== o && (t.update(), r.set(t, o))
                    }
                    return c
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        const rd = new Jl,
            ad = new tc,
            sd = new class extends Jl {
                constructor(t = null, e = 1, n = 1, i = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: t,
                        width: e,
                        height: n,
                        depth: i
                    }, this.magFilter = Wo, this.minFilter = Wo, this.wrapR = Vo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            },
            od = new fu,
            ld = [],
            cd = [],
            hd = new Float32Array(16),
            ud = new Float32Array(9),
            dd = new Float32Array(4);

        function pd(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0) return t;
            const r = e * n;
            let a = ld[r];
            if (void 0 === a && (a = new Float32Array(r), ld[r] = a), 0 !== e) {
                i.toArray(a, 0);
                for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(a, r)
            }
            return a
        }

        function fd(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function md(t, e) {
            for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }

        function gd(t, e) {
            let n = cd[e];
            void 0 === n && (n = new Int32Array(e), cd[e] = n);
            for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function _d(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function vd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (fd(n, e)) return;
                t.uniform2fv(this.addr, e), md(n, e)
            }
        }

        function xd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (fd(n, e)) return;
                t.uniform3fv(this.addr, e), md(n, e)
            }
        }

        function yd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (fd(n, e)) return;
                t.uniform4fv(this.addr, e), md(n, e)
            }
        }

        function Md(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (fd(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), md(n, e)
            } else {
                if (fd(n, i)) return;
                dd.set(i), t.uniformMatrix2fv(this.addr, !1, dd), md(n, i)
            }
        }

        function Sd(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (fd(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), md(n, e)
            } else {
                if (fd(n, i)) return;
                ud.set(i), t.uniformMatrix3fv(this.addr, !1, ud), md(n, i)
            }
        }

        function Td(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (fd(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), md(n, e)
            } else {
                if (fd(n, i)) return;
                hd.set(i), t.uniformMatrix4fv(this.addr, !1, hd), md(n, i)
            }
        }

        function Ed(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function bd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (fd(n, e)) return;
                t.uniform2iv(this.addr, e), md(n, e)
            }
        }

        function wd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (fd(n, e)) return;
                t.uniform3iv(this.addr, e), md(n, e)
            }
        }

        function Ad(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (fd(n, e)) return;
                t.uniform4iv(this.addr, e), md(n, e)
            }
        }

        function Rd(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function Cd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (fd(n, e)) return;
                t.uniform2uiv(this.addr, e), md(n, e)
            }
        }

        function Pd(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (fd(n, e)) return;
                t.uniform3uiv(this.addr, e), md(n, e)
            }
        }

        function Ld(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (fd(n, e)) return;
                t.uniform4uiv(this.addr, e), md(n, e)
            }
        }

        function Ud(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || rd, r)
        }

        function Dd(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || sd, r)
        }

        function Id(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || od, r)
        }

        function Nd(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || ad, r)
        }

        function Od(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Fd(t, e) {
            const n = pd(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function zd(t, e) {
            const n = pd(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function Bd(t, e) {
            const n = pd(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function kd(t, e) {
            const n = pd(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function Hd(t, e) {
            const n = pd(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function Vd(t, e) {
            const n = pd(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function Gd(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Wd(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Xd(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function qd(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function jd(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function Yd(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function Kd(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function Zd(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function Jd(t, e, n) {
            const i = this.cache,
                r = e.length,
                a = gd(n, r);
            fd(i, a) || (t.uniform1iv(this.addr, a), md(i, a));
            for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || rd, a[t])
        }

        function Qd(t, e, n) {
            const i = this.cache,
                r = e.length,
                a = gd(n, r);
            fd(i, a) || (t.uniform1iv(this.addr, a), md(i, a));
            for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || sd, a[t])
        }

        function $d(t, e, n) {
            const i = this.cache,
                r = e.length,
                a = gd(n, r);
            fd(i, a) || (t.uniform1iv(this.addr, a), md(i, a));
            for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || od, a[t])
        }

        function tp(t, e, n) {
            const i = this.cache,
                r = e.length,
                a = gd(n, r);
            fd(i, a) || (t.uniform1iv(this.addr, a), md(i, a));
            for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || ad, a[t])
        }
        class ep {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return _d;
                        case 35664:
                            return vd;
                        case 35665:
                            return xd;
                        case 35666:
                            return yd;
                        case 35674:
                            return Md;
                        case 35675:
                            return Sd;
                        case 35676:
                            return Td;
                        case 5124:
                        case 35670:
                            return Ed;
                        case 35667:
                        case 35671:
                            return bd;
                        case 35668:
                        case 35672:
                            return wd;
                        case 35669:
                        case 35673:
                            return Ad;
                        case 5125:
                            return Rd;
                        case 36294:
                            return Cd;
                        case 36295:
                            return Pd;
                        case 36296:
                            return Ld;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Ud;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Dd;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Id;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Nd
                    }
                }(e.type)
            }
        }
        class np {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Od;
                        case 35664:
                            return Fd;
                        case 35665:
                            return zd;
                        case 35666:
                            return Bd;
                        case 35674:
                            return kd;
                        case 35675:
                            return Hd;
                        case 35676:
                            return Vd;
                        case 5124:
                        case 35670:
                            return Gd;
                        case 35667:
                        case 35671:
                            return Wd;
                        case 35668:
                        case 35672:
                            return Xd;
                        case 35669:
                        case 35673:
                            return qd;
                        case 5125:
                            return jd;
                        case 36294:
                            return Yd;
                        case 36295:
                            return Kd;
                        case 36296:
                            return Zd;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Jd;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Qd;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return $d;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return tp
                    }
                }(e.type)
            }
        }
        class ip {
            constructor(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            setValue(t, e, n) {
                const i = this.seq;
                for (let r = 0, a = i.length; r !== a; ++r) {
                    const a = i[r];
                    a.setValue(t, e[a.id], n)
                }
            }
        }
        const rp = /(\w+)(\])?(\[|\.)?/g;

        function ap(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function sp(t, e, n) {
            const i = t.name,
                r = i.length;
            for (rp.lastIndex = 0;;) {
                const a = rp.exec(i),
                    s = rp.lastIndex;
                let o = a[1];
                const l = "]" === a[2],
                    c = a[3];
                if (l && (o |= 0), void 0 === c || "[" === c && s + 2 === r) {
                    ap(n, void 0 === c ? new ep(o, t, e) : new np(o, t, e));
                    break
                } {
                    let t = n.map[o];
                    void 0 === t && (t = new ip(o), ap(n, t)), n = t
                }
            }
        }
        class op {
            constructor(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    sp(n, t.getUniformLocation(e, n.name), this)
                }
            }
            setValue(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }
            setOptional(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }
            static upload(t, e, n, i) {
                for (let r = 0, a = e.length; r !== a; ++r) {
                    const a = e[r],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(t, s.value, i)
                }
            }
            static seqWithValue(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            }
        }

        function lp(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), i
        }
        let cp = 0;

        function hp(t, e, n) {
            const i = t.getShaderParameter(e, t.COMPILE_STATUS),
                r = t.getShaderInfoLog(e).trim();
            if (i && "" === r) return "";
            const a = /ERROR: 0:(\d+)/.exec(r);
            if (a) {
                const i = parseInt(a[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(t, e) {
                    const n = t.split("\n"),
                        i = [],
                        r = Math.max(e - 6, 0),
                        a = Math.min(e + 6, n.length);
                    for (let t = r; t < a; t++) {
                        const r = t + 1;
                        i.push(`${r===e?">":" "} ${r}: ${n[t]}`)
                    }
                    return i.join("\n")
                }(t.getShaderSource(e), i)
            }
            return r
        }

        function up(t, e) {
            const n = function(t) {
                switch (t) {
                    case pl:
                        return ["Linear", "( value )"];
                    case dl:
                        return ["sRGB", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space:", t), ["Linear", "( value )"]
                }
            }(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function dp(t, e) {
            let n;
            switch (e) {
                case Do:
                    n = "Linear";
                    break;
                case Io:
                    n = "Reinhard";
                    break;
                case No:
                    n = "OptimizedCineon";
                    break;
                case Oo:
                    n = "ACESFilmic";
                    break;
                case Fo:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function pp(t) {
            return "" !== t
        }

        function fp(t, e) {
            const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function mp(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const gp = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function _p(t) {
            return t.replace(gp, xp)
        }
        const vp = new Map([
            ["encodings_fragment", "colorspace_fragment"],
            ["encodings_pars_fragment", "colorspace_pars_fragment"],
            ["output_fragment", "opaque_fragment"]
        ]);

        function xp(t, e) {
            let n = wu[e];
            if (void 0 === n) {
                const t = vp.get(e);
                if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
                n = wu[t], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
            }
            return _p(n)
        }
        const yp = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Mp(t) {
            return t.replace(yp, Sp)
        }

        function Sp(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }

        function Tp(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Ep(t, e, n, i) {
            const r = t.getContext(),
                a = n.defines;
            let s = n.vertexShader,
                o = n.fragmentShader;
            const l = function(t) {
                    let e = "SHADOWMAP_TYPE_BASIC";
                    return t.shadowMapType === bo ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === wo ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Ao && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                c = function(t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case zo:
                        case Bo:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case ko:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                h = function(t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    return t.envMap && t.envMapMode === Bo && (e = "ENVMAP_MODE_REFRACTION"), e
                }(n),
                u = function(t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case Co:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case Po:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case Lo:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                d = function(t) {
                    const e = t.envMapCubeUVHeight;
                    if (null === e) return null;
                    const n = Math.log2(e) - 2,
                        i = 1 / e;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }(n),
                p = n.isWebGL2 ? "" : function(t) {
                    return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(pp).join("\n")
                }(n),
                f = function(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        !1 !== i && e.push("#define " + n + " " + i)
                    }
                    return e.join("\n")
                }(a),
                m = r.createProgram();
            let g, _, v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(pp).join("\n"), g.length > 0 && (g += "\n"), _ = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(pp).join("\n"), _.length > 0 && (_ += "\n")) : (g = [Tp(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(pp).join("\n"), _ = [p, Tp(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Uo ? "#define TONE_MAPPING" : "", n.toneMapping !== Uo ? wu.tonemapping_pars_fragment : "", n.toneMapping !== Uo ? dp("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", wu.colorspace_pars_fragment, up("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(pp).join("\n")), s = _p(s), s = fp(s, n), s = mp(s, n), o = _p(o), o = fp(o, n), o = mp(o, n), s = Mp(s), o = Mp(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (v = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, _ = ["#define varying in", n.glslVersion === gl ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === gl ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
            const x = v + g + s,
                y = v + _ + o,
                M = lp(r, r.VERTEX_SHADER, x),
                S = lp(r, r.FRAGMENT_SHADER, y);
            if (r.attachShader(m, M), r.attachShader(m, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
                const e = r.getProgramInfoLog(m).trim(),
                    n = r.getShaderInfoLog(M).trim(),
                    i = r.getShaderInfoLog(S).trim();
                let a = !0,
                    s = !0;
                if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
                    if (a = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(r, m, M, S);
                    else {
                        const t = hp(r, M, "vertex"),
                            n = hp(r, S, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
                    }
                else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== n && "" !== i || (s = !1);
                s && (this.diagnostics = {
                    runnable: a,
                    programLog: e,
                    vertexShader: {
                        log: n,
                        prefix: g
                    },
                    fragmentShader: {
                        log: i,
                        prefix: _
                    }
                })
            }
            let T, E;
            return r.deleteShader(M), r.deleteShader(S), this.getUniforms = function() {
                return void 0 === T && (T = new op(r, m)), T
            }, this.getAttributes = function() {
                return void 0 === E && (E = function(t, e) {
                    const n = {},
                        i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r),
                            a = i.name;
                        let s = 1;
                        i.type === t.FLOAT_MAT2 && (s = 2), i.type === t.FLOAT_MAT3 && (s = 3), i.type === t.FLOAT_MAT4 && (s = 4), n[a] = {
                            type: i.type,
                            location: t.getAttribLocation(e, a),
                            locationSize: s
                        }
                    }
                    return n
                }(r, m)), E
            }, this.destroy = function() {
                i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
            }, this.type = n.shaderType, this.name = n.shaderName, this.id = cp++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = M, this.fragmentShader = S, this
        }
        let bp = 0;
        class wp {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader,
                    n = t.fragmentShader,
                    i = this._getShaderStage(e),
                    r = this._getShaderStage(n),
                    a = this._getShaderCacheForMaterial(t);
                return !1 === a.has(i) && (a.add(i), i.usedTimes++), !1 === a.has(r) && (a.add(r), r.usedTimes++), this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                return this.materialCache.delete(t), this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                let n = e.get(t);
                return void 0 === n && (n = new Set, e.set(t, n)), n
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                let n = e.get(t);
                return void 0 === n && (n = new Ap(t), e.set(t, n)), n
            }
        }
        class Ap {
            constructor(t) {
                this.id = bp++, this.code = t, this.usedTimes = 0
            }
        }

        function Rp(t, e, n, i, r, a, s) {
            const o = new Gc,
                l = new wp,
                c = [],
                h = r.isWebGL2,
                u = r.logarithmicDepthBuffer,
                d = r.vertexTextures;
            let p = r.precision;
            const f = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };

            function m(t) {
                return 0 === t ? "uv" : `uv${t}`
            }
            return {
                getParameters: function(a, o, c, g, _) {
                    const v = g.fog,
                        x = _.geometry,
                        y = a.isMeshStandardMaterial ? g.environment : null,
                        M = (a.isMeshStandardMaterial ? n : e).get(a.envMap || y),
                        S = M && M.mapping === ko ? M.image.height : null,
                        T = f[a.type];
                    null !== a.precision && (p = r.getMaxPrecision(a.precision), p !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", p, "instead."));
                    const E = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color,
                        b = void 0 !== E ? E.length : 0;
                    let w, A, R, C, P = 0;
                    if (void 0 !== x.morphAttributes.position && (P = 1), void 0 !== x.morphAttributes.normal && (P = 2), void 0 !== x.morphAttributes.color && (P = 3), T) {
                        const t = Ru[T];
                        w = t.vertexShader, A = t.fragmentShader
                    } else w = a.vertexShader, A = a.fragmentShader, l.update(a), R = l.getVertexShaderID(a), C = l.getFragmentShaderID(a);
                    const L = t.getRenderTarget(),
                        U = !0 === _.isInstancedMesh,
                        D = !!a.map,
                        I = !!a.matcap,
                        N = !!M,
                        O = !!a.aoMap,
                        F = !!a.lightMap,
                        z = !!a.bumpMap,
                        B = !!a.normalMap,
                        k = !!a.displacementMap,
                        H = !!a.emissiveMap,
                        V = !!a.metalnessMap,
                        G = !!a.roughnessMap,
                        W = a.anisotropy > 0,
                        X = a.clearcoat > 0,
                        q = a.iridescence > 0,
                        j = a.sheen > 0,
                        Y = a.transmission > 0,
                        K = W && !!a.anisotropyMap,
                        Z = X && !!a.clearcoatMap,
                        J = X && !!a.clearcoatNormalMap,
                        Q = X && !!a.clearcoatRoughnessMap,
                        $ = q && !!a.iridescenceMap,
                        tt = q && !!a.iridescenceThicknessMap,
                        et = j && !!a.sheenColorMap,
                        nt = j && !!a.sheenRoughnessMap,
                        it = !!a.specularMap,
                        rt = !!a.specularColorMap,
                        at = !!a.specularIntensityMap,
                        st = Y && !!a.transmissionMap,
                        ot = Y && !!a.thicknessMap,
                        lt = !!a.gradientMap,
                        ct = !!a.alphaMap,
                        ht = a.alphaTest > 0,
                        ut = !!a.alphaHash,
                        dt = !!a.extensions,
                        pt = !!x.attributes.uv1,
                        ft = !!x.attributes.uv2,
                        mt = !!x.attributes.uv3;
                    return {
                        isWebGL2: h,
                        shaderID: T,
                        shaderType: a.type,
                        shaderName: a.name,
                        vertexShader: w,
                        fragmentShader: A,
                        defines: a.defines,
                        customVertexShaderID: R,
                        customFragmentShaderID: C,
                        isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                        glslVersion: a.glslVersion,
                        precision: p,
                        instancing: U,
                        instancingColor: U && null !== _.instanceColor,
                        supportsVertexTextures: d,
                        outputColorSpace: null === L ? t.outputColorSpace : !0 === L.isXRRenderTarget ? L.texture.colorSpace : pl,
                        map: D,
                        matcap: I,
                        envMap: N,
                        envMapMode: N && M.mapping,
                        envMapCubeUVHeight: S,
                        aoMap: O,
                        lightMap: F,
                        bumpMap: z,
                        normalMap: B,
                        displacementMap: d && k,
                        emissiveMap: H,
                        normalMapObjectSpace: B && 1 === a.normalMapType,
                        normalMapTangentSpace: B && 0 === a.normalMapType,
                        metalnessMap: V,
                        roughnessMap: G,
                        anisotropy: W,
                        anisotropyMap: K,
                        clearcoat: X,
                        clearcoatMap: Z,
                        clearcoatNormalMap: J,
                        clearcoatRoughnessMap: Q,
                        iridescence: q,
                        iridescenceMap: $,
                        iridescenceThicknessMap: tt,
                        sheen: j,
                        sheenColorMap: et,
                        sheenRoughnessMap: nt,
                        specularMap: it,
                        specularColorMap: rt,
                        specularIntensityMap: at,
                        transmission: Y,
                        transmissionMap: st,
                        thicknessMap: ot,
                        gradientMap: lt,
                        opaque: !1 === a.transparent && 1 === a.blending,
                        alphaMap: ct,
                        alphaTest: ht,
                        alphaHash: ut,
                        combine: a.combine,
                        mapUv: D && m(a.map.channel),
                        aoMapUv: O && m(a.aoMap.channel),
                        lightMapUv: F && m(a.lightMap.channel),
                        bumpMapUv: z && m(a.bumpMap.channel),
                        normalMapUv: B && m(a.normalMap.channel),
                        displacementMapUv: k && m(a.displacementMap.channel),
                        emissiveMapUv: H && m(a.emissiveMap.channel),
                        metalnessMapUv: V && m(a.metalnessMap.channel),
                        roughnessMapUv: G && m(a.roughnessMap.channel),
                        anisotropyMapUv: K && m(a.anisotropyMap.channel),
                        clearcoatMapUv: Z && m(a.clearcoatMap.channel),
                        clearcoatNormalMapUv: J && m(a.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: Q && m(a.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: $ && m(a.iridescenceMap.channel),
                        iridescenceThicknessMapUv: tt && m(a.iridescenceThicknessMap.channel),
                        sheenColorMapUv: et && m(a.sheenColorMap.channel),
                        sheenRoughnessMapUv: nt && m(a.sheenRoughnessMap.channel),
                        specularMapUv: it && m(a.specularMap.channel),
                        specularColorMapUv: rt && m(a.specularColorMap.channel),
                        specularIntensityMapUv: at && m(a.specularIntensityMap.channel),
                        transmissionMapUv: st && m(a.transmissionMap.channel),
                        thicknessMapUv: ot && m(a.thicknessMap.channel),
                        alphaMapUv: ct && m(a.alphaMap.channel),
                        vertexTangents: !!x.attributes.tangent && (B || W),
                        vertexColors: a.vertexColors,
                        vertexAlphas: !0 === a.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                        vertexUv1s: pt,
                        vertexUv2s: ft,
                        vertexUv3s: mt,
                        pointsUvs: !0 === _.isPoints && !!x.attributes.uv && (D || ct),
                        fog: !!v,
                        useFog: !0 === a.fog,
                        fogExp2: v && v.isFogExp2,
                        flatShading: !0 === a.flatShading,
                        sizeAttenuation: !0 === a.sizeAttenuation,
                        logarithmicDepthBuffer: u,
                        skinning: !0 === _.isSkinnedMesh,
                        morphTargets: void 0 !== x.morphAttributes.position,
                        morphNormals: void 0 !== x.morphAttributes.normal,
                        morphColors: void 0 !== x.morphAttributes.color,
                        morphTargetsCount: b,
                        morphTextureStride: P,
                        numDirLights: o.directional.length,
                        numPointLights: o.point.length,
                        numSpotLights: o.spot.length,
                        numSpotLightMaps: o.spotLightMap.length,
                        numRectAreaLights: o.rectArea.length,
                        numHemiLights: o.hemi.length,
                        numDirLightShadows: o.directionalShadowMap.length,
                        numPointLightShadows: o.pointShadowMap.length,
                        numSpotLightShadows: o.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: a.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: a.toneMapped ? t.toneMapping : Uo,
                        useLegacyLights: t.useLegacyLights,
                        premultipliedAlpha: a.premultipliedAlpha,
                        doubleSided: 2 === a.side,
                        flipSided: 1 === a.side,
                        useDepthPacking: a.depthPacking >= 0,
                        depthPacking: a.depthPacking || 0,
                        index0AttributeName: a.index0AttributeName,
                        extensionDerivatives: dt && !0 === a.extensions.derivatives,
                        extensionFragDepth: dt && !0 === a.extensions.fragDepth,
                        extensionDrawBuffers: dt && !0 === a.extensions.drawBuffers,
                        extensionShaderTextureLOD: dt && !0 === a.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: a.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (function(t, e) {
                        t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                    }(n, e), function(t, e) {
                        o.disableAll(), e.isWebGL2 && o.enable(0), e.supportsVertexTextures && o.enable(1), e.instancing && o.enable(2), e.instancingColor && o.enable(3), e.matcap && o.enable(4), e.envMap && o.enable(5), e.normalMapObjectSpace && o.enable(6), e.normalMapTangentSpace && o.enable(7), e.clearcoat && o.enable(8), e.iridescence && o.enable(9), e.alphaTest && o.enable(10), e.vertexColors && o.enable(11), e.vertexAlphas && o.enable(12), e.vertexUv1s && o.enable(13), e.vertexUv2s && o.enable(14), e.vertexUv3s && o.enable(15), e.vertexTangents && o.enable(16), e.anisotropy && o.enable(17), t.push(o.mask), o.disableAll(), e.fog && o.enable(0), e.useFog && o.enable(1), e.flatShading && o.enable(2), e.logarithmicDepthBuffer && o.enable(3), e.skinning && o.enable(4), e.morphTargets && o.enable(5), e.morphNormals && o.enable(6), e.morphColors && o.enable(7), e.premultipliedAlpha && o.enable(8), e.shadowMapEnabled && o.enable(9), e.useLegacyLights && o.enable(10), e.doubleSided && o.enable(11), e.flipSided && o.enable(12), e.useDepthPacking && o.enable(13), e.dithering && o.enable(14), e.transmission && o.enable(15), e.sheen && o.enable(16), e.opaque && o.enable(17), e.pointsUvs && o.enable(18), t.push(o.mask)
                    }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function(t) {
                    const e = f[t.type];
                    let n;
                    if (e) {
                        const t = Ru[e];
                        n = lu.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let i;
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        if (e.cacheKey === n) {
                            i = e, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Ep(t, n, e, a), c.push(i)), i
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = c.indexOf(t);
                        c[e] = c[c.length - 1], c.pop(), t.destroy()
                    }
                },
                releaseShaderCache: function(t) {
                    l.remove(t)
                },
                programs: c,
                dispose: function() {
                    l.dispose()
                }
            }
        }

        function Cp() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function Pp(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Lp(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Up() {
            const t = [];
            let e = 0;
            const n = [],
                i = [],
                r = [];

            function a(n, i, r, a, s, o) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: a,
                    renderOrder: n.renderOrder,
                    z: s,
                    group: o
                }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = s, l.group = o), e++, l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    e = 0, n.length = 0, i.length = 0, r.length = 0
                },
                push: function(t, e, s, o, l, c) {
                    const h = a(t, e, s, o, l, c);
                    s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
                },
                unshift: function(t, e, s, o, l, c) {
                    const h = a(t, e, s, o, l, c);
                    s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
                },
                finish: function() {
                    for (let n = e, i = t.length; n < i; n++) {
                        const e = t[n];
                        if (null === e.id) break;
                        e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                    }
                },
                sort: function(t, e) {
                    n.length > 1 && n.sort(t || Pp), i.length > 1 && i.sort(e || Lp), r.length > 1 && r.sort(e || Lp)
                }
            }
        }

        function Dp() {
            let t = new WeakMap;
            return {
                get: function(e, n) {
                    const i = t.get(e);
                    let r;
                    return void 0 === i ? (r = new Up, t.set(e, [r])) : n >= i.length ? (r = new Up, i.push(r)) : r = i[n], r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function Ip() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new nc,
                                color: new Sh
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new nc,
                                direction: new nc,
                                color: new Sh,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new nc,
                                color: new Sh,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new nc,
                                skyColor: new Sh,
                                groundColor: new Sh
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new Sh,
                                position: new nc,
                                halfWidth: new nc,
                                halfHeight: new nc
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let Np = 0;

        function Op(t, e) {
            return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
        }

        function Fp(t, e) {
            const n = new Ip,
                i = function() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Ll
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Ll,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                r = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0
                };
            for (let t = 0; t < 9; t++) r.probe.push(new nc);
            const a = new nc,
                s = new Uc,
                o = new Uc;
            return {
                setup: function(a, s) {
                    let o = 0,
                        l = 0,
                        c = 0;
                    for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                    let h = 0,
                        u = 0,
                        d = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        _ = 0,
                        v = 0,
                        x = 0;
                    a.sort(Op);
                    const y = !0 === s ? Math.PI : 1;
                    for (let t = 0, e = a.length; t < e; t++) {
                        const e = a[t],
                            s = e.color,
                            M = e.intensity,
                            S = e.distance,
                            T = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) o += s.r * M * y, l += s.g * M * y, c += s.b * M * y;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], M);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * y), e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[h] = n, r.directionalShadowMap[h] = T, r.directionalShadowMatrix[h] = e.shadow.matrix, m++
                            }
                            r.directional[h] = t, h++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(s).multiplyScalar(M * y), t.distance = S, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, r.spot[d] = t;
                            const a = e.shadow;
                            if (e.map && (r.spotLightMap[v] = e.map, v++, a.updateMatrices(e), e.castShadow && x++), r.spotLightMatrix[d] = a.matrix, e.castShadow) {
                                const t = i.get(e);
                                t.shadowBias = a.bias, t.shadowNormalBias = a.normalBias, t.shadowRadius = a.radius, t.shadowMapSize = a.mapSize, r.spotShadow[d] = t, r.spotShadowMap[d] = T, _++
                            }
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(s).multiplyScalar(M), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[p] = t, p++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * y), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = T, r.pointShadowMatrix[u] = e.shadow.matrix, g++
                            }
                            r.point[u] = t, u++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(M * y), t.groundColor.copy(e.groundColor).multiplyScalar(M * y), r.hemi[f] = t, f++
                        }
                    }
                    p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Au.LTC_FLOAT_1, r.rectAreaLTC2 = Au.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Au.LTC_HALF_1, r.rectAreaLTC2 = Au.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                    const M = r.hash;
                    M.directionalLength === h && M.pointLength === u && M.spotLength === d && M.rectAreaLength === p && M.hemiLength === f && M.numDirectionalShadows === m && M.numPointShadows === g && M.numSpotShadows === _ && M.numSpotMaps === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = _, r.spotShadowMap.length = _, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = _ + v - x, r.spotLightMap.length = v, r.numSpotLightShadowsWithMaps = x, M.directionalLength = h, M.pointLength = u, M.spotLength = d, M.rectAreaLength = p, M.hemiLength = f, M.numDirectionalShadows = m, M.numPointShadows = g, M.numSpotShadows = _, M.numSpotMaps = v, r.version = Np++)
                },
                setupView: function(t, e) {
                    let n = 0,
                        i = 0,
                        l = 0,
                        c = 0,
                        h = 0;
                    const u = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(u), n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(u), l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), o.identity(), s.copy(d.matrixWorld), s.premultiply(u), o.extractRotation(s), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(o), t.halfHeight.applyMatrix4(o), c++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[h];
                            t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), h++
                        }
                    }
                },
                state: r
            }
        }

        function zp(t, e) {
            const n = new Fp(t, e),
                i = [],
                r = [];
            return {
                init: function() {
                    i.length = 0, r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function(t) {
                    n.setup(i, t)
                },
                setupLightsView: function(t) {
                    n.setupView(i, t)
                },
                pushLight: function(t) {
                    i.push(t)
                },
                pushShadow: function(t) {
                    r.push(t)
                }
            }
        }

        function Bp(t, e) {
            let n = new WeakMap;
            return {
                get: function(i, r = 0) {
                    const a = n.get(i);
                    let s;
                    return void 0 === a ? (s = new zp(t, e), n.set(i, [s])) : r >= a.length ? (s = new zp(t, e), a.push(s)) : s = a[r], s
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class kp extends _h {
            constructor(t) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }
        }
        class Hp extends _h {
            constructor(t) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }
        }

        function Vp(t, e, n) {
            let i = new Su;
            const r = new Ll,
                a = new Ll,
                s = new Ql,
                o = new kp({
                    depthPacking: 3201
                }),
                l = new Hp,
                c = {},
                h = n.maxTextureSize,
                u = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                d = new cu({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Ll
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                p = d.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new zh;
            f.setAttribute("position", new Ah(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new nu(f, d),
                g = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = bo;
            let _ = this.type;

            function v(n, i) {
                const a = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new $l(r.x, r.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, a, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, a, p, m, null)
            }

            function x(e, n, i, r) {
                let a = null;
                const s = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (void 0 !== s) a = s;
                else if (a = !0 === i.isPointLight ? l : o, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const t = a.uuid,
                        e = n.uuid;
                    let i = c[t];
                    void 0 === i && (i = {}, c[t] = i);
                    let r = i[e];
                    void 0 === r && (r = a.clone(), i[e] = r), a = r
                }
                return a.visible = n.visible, a.wireframe = n.wireframe, a.side = r === Ao ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side], a.alphaMap = n.alphaMap, a.alphaTest = n.alphaTest, a.map = n.map, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.clipIntersection = n.clipIntersection, a.displacementMap = n.displacementMap, a.displacementScale = n.displacementScale, a.displacementBias = n.displacementBias, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, !0 === i.isPointLight && !0 === a.isMeshDistanceMaterial && (t.properties.get(a).light = i), a
            }

            function y(n, r, a, s, o) {
                if (!1 === n.visible) return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === Ao) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n),
                        r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l],
                                h = r[c.materialIndex];
                            if (h && h.visible) {
                                const e = x(n, h, s, o);
                                t.renderBufferDirect(a, null, i, e, n, c)
                            }
                        }
                    } else if (r.visible) {
                        const e = x(n, r, s, o);
                        t.renderBufferDirect(a, null, i, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++) y(l[t], r, a, s, o)
            }
            this.render = function(e, n, o) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const l = t.getRenderTarget(),
                    c = t.getActiveCubeFace(),
                    u = t.getActiveMipmapLevel(),
                    d = t.state;
                d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                const p = _ !== Ao && this.type === Ao,
                    f = _ === Ao && this.type !== Ao;
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l],
                        u = c.shadow;
                    if (void 0 === u) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                    r.copy(u.mapSize);
                    const m = u.getFrameExtents();
                    if (r.multiply(m), a.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (a.x = Math.floor(h / m.x), r.x = a.x * m.x, u.mapSize.x = a.x), r.y > h && (a.y = Math.floor(h / m.y), r.y = a.y * m.y, u.mapSize.y = a.y)), null === u.map || !0 === p || !0 === f) {
                        const t = this.type !== Ao ? {
                            minFilter: Wo,
                            magFilter: Wo
                        } : {};
                        null !== u.map && u.map.dispose(), u.map = new $l(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(u.map), t.clear();
                    const g = u.getViewportCount();
                    for (let t = 0; t < g; t++) {
                        const e = u.getViewport(t);
                        s.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w), d.viewport(s), u.updateMatrices(c, t), i = u.getFrustum(), y(n, o, u.camera, c, this.type)
                    }!0 !== u.isPointLightShadow && this.type === Ao && v(u, o), u.needsUpdate = !1
                }
                _ = this.type, g.needsUpdate = !1, t.setRenderTarget(l, c, u)
            }
        }

        function Gp(t, e, n) {
            const i = n.isWebGL2,
                r = new function() {
                    let e = !1;
                    const n = new Ql;
                    let i = null;
                    const r = new Ql(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            i === n || e || (t.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, i, a, s, o) {
                            !0 === o && (e *= s, i *= s, a *= s), n.set(e, i, a, s), !1 === r.equals(n) && (t.clearColor(e, i, a, s), r.copy(n))
                        },
                        reset: function() {
                            e = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                a = new function() {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function(e) {
                            e ? k(t.DEPTH_TEST) : H(t.DEPTH_TEST)
                        },
                        setMask: function(i) {
                            n === i || e || (t.depthMask(i), n = i)
                        },
                        setFunc: function(e) {
                            if (i !== e) {
                                switch (e) {
                                    case 0:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case 1:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case 2:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case 3:
                                    default:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case 4:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case 5:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case 6:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case 7:
                                        t.depthFunc(t.NOTEQUAL)
                                }
                                i = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function() {
                            e = !1, n = null, i = null, r = null
                        }
                    }
                },
                s = new function() {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        s = null,
                        o = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function(n) {
                            e || (n ? k(t.STENCIL_TEST) : H(t.STENCIL_TEST))
                        },
                        setMask: function(i) {
                            n === i || e || (t.stencilMask(i), n = i)
                        },
                        setFunc: function(e, n, s) {
                            i === e && r === n && a === s || (t.stencilFunc(e, n, s), i = e, r = n, a = s)
                        },
                        setOp: function(e, n, i) {
                            s === e && o === n && l === i || (t.stencilOp(e, n, i), s = e, o = n, l = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            c !== e && (t.clearStencil(e), c = e)
                        },
                        reset: function() {
                            e = !1, n = null, i = null, r = null, a = null, s = null, o = null, l = null, c = null
                        }
                    }
                },
                o = new WeakMap,
                l = new WeakMap;
            let c = {},
                h = {},
                u = new WeakMap,
                d = [],
                p = null,
                f = !1,
                m = null,
                g = null,
                _ = null,
                v = null,
                x = null,
                y = null,
                M = null,
                S = !1,
                T = null,
                E = null,
                b = null,
                w = null,
                A = null;
            const R = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let C = !1,
                P = 0;
            const L = t.getParameter(t.VERSION); - 1 !== L.indexOf("WebGL") ? (P = parseFloat(/^WebGL (\d)/.exec(L)[1]), C = P >= 1) : -1 !== L.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), C = P >= 2);
            let U = null,
                D = {};
            const I = t.getParameter(t.SCISSOR_BOX),
                N = t.getParameter(t.VIEWPORT),
                O = (new Ql).fromArray(I),
                F = (new Ql).fromArray(N);

            function z(e, n, r, a) {
                const s = new Uint8Array(4),
                    o = t.createTexture();
                t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (let o = 0; o < r; o++) !i || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, s) : t.texImage3D(n, 0, t.RGBA, 1, 1, a, 0, t.RGBA, t.UNSIGNED_BYTE, s);
                return o
            }
            const B = {};

            function k(e) {
                !0 !== c[e] && (t.enable(e), c[e] = !0)
            }

            function H(e) {
                !1 !== c[e] && (t.disable(e), c[e] = !1)
            }
            B[t.TEXTURE_2D] = z(t.TEXTURE_2D, t.TEXTURE_2D, 1), B[t.TEXTURE_CUBE_MAP] = z(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (B[t.TEXTURE_2D_ARRAY] = z(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), B[t.TEXTURE_3D] = z(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), k(t.DEPTH_TEST), a.setFunc(3), X(!1), q(1), k(t.CULL_FACE), W(0);
            const V = {
                [Ro]: t.FUNC_ADD,
                101: t.FUNC_SUBTRACT,
                102: t.FUNC_REVERSE_SUBTRACT
            };
            if (i) V[103] = t.MIN, V[104] = t.MAX;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (V[103] = t.MIN_EXT, V[104] = t.MAX_EXT)
            }
            const G = {
                200: t.ZERO,
                201: t.ONE,
                202: t.SRC_COLOR,
                204: t.SRC_ALPHA,
                210: t.SRC_ALPHA_SATURATE,
                208: t.DST_COLOR,
                206: t.DST_ALPHA,
                203: t.ONE_MINUS_SRC_COLOR,
                205: t.ONE_MINUS_SRC_ALPHA,
                209: t.ONE_MINUS_DST_COLOR,
                207: t.ONE_MINUS_DST_ALPHA
            };

            function W(e, n, i, r, a, s, o, l) {
                if (0 !== e) {
                    if (!1 === f && (k(t.BLEND), f = !0), 5 === e) a = a || n, s = s || i, o = o || r, n === g && a === x || (t.blendEquationSeparate(V[n], V[a]), g = n, x = a), i === _ && r === v && s === y && o === M || (t.blendFuncSeparate(G[i], G[r], G[s], G[o]), _ = i, v = r, y = s, M = o), m = e, S = !1;
                    else if (e !== m || l !== S) {
                        if (g === Ro && x === Ro || (t.blendEquation(t.FUNC_ADD), g = Ro, x = Ro), l) switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFunc(t.ZERO, t.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        _ = null, v = null, y = null, M = null, m = e, S = l
                    }
                } else !0 === f && (H(t.BLEND), f = !1)
            }

            function X(e) {
                T !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), T = e)
            }

            function q(e) {
                0 !== e ? (k(t.CULL_FACE), e !== E && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : H(t.CULL_FACE), E = e
            }

            function j(e, n, i) {
                e ? (k(t.POLYGON_OFFSET_FILL), w === n && A === i || (t.polygonOffset(n, i), w = n, A = i)) : H(t.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: r,
                    depth: a,
                    stencil: s
                },
                enable: k,
                disable: H,
                bindFramebuffer: function(e, n) {
                    return h[e] !== n && (t.bindFramebuffer(e, n), h[e] = n, i && (e === t.DRAW_FRAMEBUFFER && (h[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (h[t.DRAW_FRAMEBUFFER] = n)), !0)
                },
                drawBuffers: function(i, r) {
                    let a = d,
                        s = !1;
                    if (i)
                        if (a = u.get(r), void 0 === a && (a = [], u.set(r, a)), i.isWebGLMultipleRenderTargets) {
                            const e = i.texture;
                            if (a.length !== e.length || a[0] !== t.COLOR_ATTACHMENT0) {
                                for (let n = 0, i = e.length; n < i; n++) a[n] = t.COLOR_ATTACHMENT0 + n;
                                a.length = e.length, s = !0
                            }
                        } else a[0] !== t.COLOR_ATTACHMENT0 && (a[0] = t.COLOR_ATTACHMENT0, s = !0);
                    else a[0] !== t.BACK && (a[0] = t.BACK, s = !0);
                    s && (n.isWebGL2 ? t.drawBuffers(a) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))
                },
                useProgram: function(e) {
                    return p !== e && (t.useProgram(e), p = e, !0)
                },
                setBlending: W,
                setMaterial: function(e, n) {
                    2 === e.side ? H(t.CULL_FACE) : k(t.CULL_FACE);
                    let i = 1 === e.side;
                    n && (i = !i), X(i), 1 === e.blending && !1 === e.transparent ? W(0) : W(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite);
                    const o = e.stencilWrite;
                    s.setTest(o), o && (s.setMask(e.stencilWriteMask), s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), j(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? k(t.SAMPLE_ALPHA_TO_COVERAGE) : H(t.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: X,
                setCullFace: q,
                setLineWidth: function(e) {
                    e !== b && (C && t.lineWidth(e), b = e)
                },
                setPolygonOffset: j,
                setScissorTest: function(e) {
                    e ? k(t.SCISSOR_TEST) : H(t.SCISSOR_TEST)
                },
                activeTexture: function(e) {
                    void 0 === e && (e = t.TEXTURE0 + R - 1), U !== e && (t.activeTexture(e), U = e)
                },
                bindTexture: function(e, n, i) {
                    void 0 === i && (i = null === U ? t.TEXTURE0 + R - 1 : U);
                    let r = D[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, D[i] = r), r.type === e && r.texture === n || (U !== i && (t.activeTexture(i), U = i), t.bindTexture(e, n || B[e]), r.type = e, r.texture = n)
                },
                unbindTexture: function() {
                    const e = D[U];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        t.compressedTexImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                updateUBOMapping: function(e, n) {
                    let i = l.get(n);
                    void 0 === i && (i = new WeakMap, l.set(n, i));
                    let r = i.get(e);
                    void 0 === r && (r = t.getUniformBlockIndex(n, e.name), i.set(e, r))
                },
                uniformBlockBinding: function(e, n) {
                    const i = l.get(n).get(e);
                    o.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), o.set(n, i))
                },
                texStorage2D: function() {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function() {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function() {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function() {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        t.compressedTexSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), O.copy(e))
                },
                viewport: function(e) {
                    !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e))
                },
                reset: function() {
                    t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === i && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), c = {}, U = null, D = {}, h = {}, u = new WeakMap, d = [], p = null, f = !1, m = null, g = null, _ = null, v = null, x = null, y = null, M = null, S = !1, T = null, E = null, b = null, w = null, A = null, O.set(0, 0, t.canvas.width, t.canvas.height), F.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), a.reset(), s.reset()
                }
            }
        }

        function Wp(t, e, n, i, r, a, s) {
            const o = r.isWebGL2,
                l = r.maxTextures,
                c = r.maxCubemapSize,
                h = r.maxTextureSize,
                u = r.maxSamples,
                d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                p = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                f = new WeakMap;
            let m;
            const g = new WeakMap;
            let _ = !1;
            try {
                _ = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function v(t, e) {
                return _ ? new OffscreenCanvas(t, e) : Nl("canvas")
            }

            function x(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? Rl : Math.floor,
                            a = i(r * t.width),
                            s = i(r * t.height);
                        void 0 === m && (m = v(a, s));
                        const o = n ? v(a, s) : m;
                        return o.width = a, o.height = s, o.getContext("2d").drawImage(t, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + s + ")."), o
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                }
                return t
            }

            function y(t) {
                return Al(t.width) && Al(t.height)
            }

            function M(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Wo && t.minFilter !== qo
            }

            function S(e) {
                t.generateMipmap(e)
            }

            function T(n, i, r, a, s = !1) {
                if (!1 === o) return i;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = i;
                return i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA && (r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = a === dl && !1 === s ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)), l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
            }

            function E(t, e, n) {
                return !0 === M(t, n) || t.isFramebufferTexture && t.minFilter !== Wo && t.minFilter !== qo ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }

            function b(e) {
                return e === Wo || 1004 === e || e === Xo ? t.NEAREST : t.LINEAR
            }

            function w(t) {
                const e = t.target;
                e.removeEventListener("dispose", w),
                    function(t) {
                        const e = i.get(t);
                        if (void 0 === e.__webglInit) return;
                        const n = t.source,
                            r = g.get(n);
                        if (r) {
                            const i = r[e.__cacheKey];
                            i.usedTimes--, 0 === i.usedTimes && R(t), 0 === Object.keys(r).length && g.delete(n)
                        }
                        i.remove(t)
                    }(e), e.isVideoTexture && f.delete(e)
            }

            function A(e) {
                const n = e.target;
                n.removeEventListener("dispose", A),
                    function(e) {
                        const n = e.texture,
                            r = i.get(e),
                            a = i.get(n);
                        if (void 0 !== a.__webglTexture && (t.deleteTexture(a.__webglTexture), s.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                        else {
                            if (t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer)
                                for (let e = 0; e < r.__webglColorRenderbuffer.length; e++) r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                            r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                        }
                        if (e.isWebGLMultipleRenderTargets)
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                r.__webglTexture && (t.deleteTexture(r.__webglTexture), s.memory.textures--), i.remove(n[e])
                            }
                        i.remove(n), i.remove(e)
                    }(n)
            }

            function R(e) {
                const n = i.get(e);
                t.deleteTexture(n.__webglTexture);
                const r = e.source;
                delete g.get(r)[n.__cacheKey], s.memory.textures--
            }
            let C = 0;

            function P(e, r) {
                const a = i.get(e);
                if (e.isVideoTexture && function(t) {
                        const e = s.render.frame;
                        f.get(t) !== e && (f.set(t, e), t.update())
                    }(e), !1 === e.isRenderTargetTexture && e.version > 0 && a.__version !== e.version) {
                    const t = e.image;
                    if (null === t) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== t.complete) return void O(a, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(t.TEXTURE_2D, a.__webglTexture, t.TEXTURE0 + r)
            }
            const L = {
                    [Ho]: t.REPEAT,
                    [Vo]: t.CLAMP_TO_EDGE,
                    [Go]: t.MIRRORED_REPEAT
                },
                U = {
                    [Wo]: t.NEAREST,
                    1004: t.NEAREST_MIPMAP_NEAREST,
                    [Xo]: t.NEAREST_MIPMAP_LINEAR,
                    [qo]: t.LINEAR,
                    1007: t.LINEAR_MIPMAP_NEAREST,
                    [jo]: t.LINEAR_MIPMAP_LINEAR
                },
                D = {
                    512: t.NEVER,
                    519: t.ALWAYS,
                    513: t.LESS,
                    515: t.LEQUAL,
                    514: t.EQUAL,
                    518: t.GEQUAL,
                    516: t.GREATER,
                    517: t.NOTEQUAL
                };

            function I(n, a, s) {
                if (s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, L[a.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, L[a.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, L[a.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, U[a.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, U[a.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), a.wrapS === Vo && a.wrapT === Vo || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, b(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, b(a.minFilter)), a.minFilter !== Wo && a.minFilter !== qo && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), a.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, D[a.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const s = e.get("EXT_texture_filter_anisotropic");
                    if (a.magFilter === Wo) return;
                    if (a.minFilter !== Xo && a.minFilter !== jo) return;
                    if (a.type === Jo && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === o && a.type === Qo && !1 === e.has("OES_texture_half_float_linear")) return;
                    (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
                }
            }

            function N(e, n) {
                let i = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w));
                const r = n.source;
                let a = g.get(r);
                void 0 === a && (a = {}, g.set(r, a));
                const o = function(t) {
                    const e = [];
                    return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
                }(n);
                if (o !== e.__cacheKey) {
                    void 0 === a[o] && (a[o] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    }, s.memory.textures++, i = !0), a[o].usedTimes++;
                    const r = a[e.__cacheKey];
                    void 0 !== r && (a[e.__cacheKey].usedTimes--, 0 === r.usedTimes && R(n)), e.__cacheKey = o, e.__webglTexture = a[o].texture
                }
                return i
            }

            function O(e, r, s) {
                let l = t.TEXTURE_2D;
                (r.isDataArrayTexture || r.isCompressedArrayTexture) && (l = t.TEXTURE_2D_ARRAY), r.isData3DTexture && (l = t.TEXTURE_3D);
                const c = N(e, r),
                    u = r.source;
                n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + s);
                const d = i.get(u);
                if (u.version !== d.__version || !0 === c) {
                    n.activeTexture(t.TEXTURE0 + s), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                    const e = function(t) {
                        return !o && (t.wrapS !== Vo || t.wrapT !== Vo || t.minFilter !== Wo && t.minFilter !== qo)
                    }(r) && !1 === y(r.image);
                    let i = x(r.image, e, !1, h);
                    i = V(r, i);
                    const p = y(i) || o,
                        f = a.convert(r.format, r.colorSpace);
                    let m, g = a.convert(r.type),
                        _ = T(r.internalFormat, f, g, r.colorSpace);
                    I(l, r, p);
                    const v = r.mipmaps,
                        b = o && !0 !== r.isVideoTexture,
                        w = void 0 === d.__version || !0 === c,
                        A = E(r, i, p);
                    if (r.isDepthTexture) _ = t.DEPTH_COMPONENT, o ? _ = r.type === Jo ? t.DEPTH_COMPONENT32F : r.type === Zo ? t.DEPTH_COMPONENT24 : r.type === $o ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : r.type === Jo && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === el && _ === t.DEPTH_COMPONENT && r.type !== Ko && r.type !== Zo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Zo, g = a.convert(r.type)), r.format === nl && _ === t.DEPTH_COMPONENT && (_ = t.DEPTH_STENCIL, r.type !== $o && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = $o, g = a.convert(r.type))), w && (b ? n.texStorage2D(t.TEXTURE_2D, 1, _, i.width, i.height) : n.texImage2D(t.TEXTURE_2D, 0, _, i.width, i.height, 0, f, g, null));
                    else if (r.isDataTexture)
                        if (v.length > 0 && p) {
                            b && w && n.texStorage2D(t.TEXTURE_2D, A, _, v[0].width, v[0].height);
                            for (let e = 0, i = v.length; e < i; e++) m = v[e], b ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m.width, m.height, f, g, m.data) : n.texImage2D(t.TEXTURE_2D, e, _, m.width, m.height, 0, f, g, m.data);
                            r.generateMipmaps = !1
                        } else b ? (w && n.texStorage2D(t.TEXTURE_2D, A, _, i.width, i.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, f, g, i.data)) : n.texImage2D(t.TEXTURE_2D, 0, _, i.width, i.height, 0, f, g, i.data);
                    else if (r.isCompressedTexture)
                        if (r.isCompressedArrayTexture) {
                            b && w && n.texStorage3D(t.TEXTURE_2D_ARRAY, A, _, v[0].width, v[0].height, i.depth);
                            for (let e = 0, a = v.length; e < a; e++) m = v[e], r.format !== tl ? null !== f ? b ? n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, m.width, m.height, i.depth, f, m.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, _, m.width, m.height, i.depth, 0, m.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b ? n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, m.width, m.height, i.depth, f, g, m.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, _, m.width, m.height, i.depth, 0, f, g, m.data)
                        } else {
                            b && w && n.texStorage2D(t.TEXTURE_2D, A, _, v[0].width, v[0].height);
                            for (let e = 0, i = v.length; e < i; e++) m = v[e], r.format !== tl ? null !== f ? b ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, m.width, m.height, f, m.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, _, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m.width, m.height, f, g, m.data) : n.texImage2D(t.TEXTURE_2D, e, _, m.width, m.height, 0, f, g, m.data)
                        }
                    else if (r.isDataArrayTexture) b ? (w && n.texStorage3D(t.TEXTURE_2D_ARRAY, A, _, i.width, i.height, i.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, i.width, i.height, i.depth, f, g, i.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, _, i.width, i.height, i.depth, 0, f, g, i.data);
                    else if (r.isData3DTexture) b ? (w && n.texStorage3D(t.TEXTURE_3D, A, _, i.width, i.height, i.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, i.width, i.height, i.depth, f, g, i.data)) : n.texImage3D(t.TEXTURE_3D, 0, _, i.width, i.height, i.depth, 0, f, g, i.data);
                    else if (r.isFramebufferTexture) {
                        if (w)
                            if (b) n.texStorage2D(t.TEXTURE_2D, A, _, i.width, i.height);
                            else {
                                let e = i.width,
                                    r = i.height;
                                for (let i = 0; i < A; i++) n.texImage2D(t.TEXTURE_2D, i, _, e, r, 0, f, g, null), e >>= 1, r >>= 1
                            }
                    } else if (v.length > 0 && p) {
                        b && w && n.texStorage2D(t.TEXTURE_2D, A, _, v[0].width, v[0].height);
                        for (let e = 0, i = v.length; e < i; e++) m = v[e], b ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, g, m) : n.texImage2D(t.TEXTURE_2D, e, _, f, g, m);
                        r.generateMipmaps = !1
                    } else b ? (w && n.texStorage2D(t.TEXTURE_2D, A, _, i.width, i.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, g, i)) : n.texImage2D(t.TEXTURE_2D, 0, _, f, g, i);
                    M(r, p) && S(l), d.__version = u.version, r.onUpdate && r.onUpdate(r)
                }
                e.__version = r.version
            }

            function F(e, r, s, o, l) {
                const c = a.convert(s.format, s.colorSpace),
                    h = a.convert(s.type),
                    u = T(s.internalFormat, c, h, s.colorSpace);
                i.get(r).__hasExternalTextures || (l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(t.FRAMEBUFFER, e), H(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, l, i.get(s).__webglTexture, 0, k(r)) : (l === t.TEXTURE_2D || l >= t.TEXTURE_CUBE_MAP_POSITIVE_X && l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(s).__webglTexture, 0), n.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function z(e, n, i) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                    let r = t.DEPTH_COMPONENT16;
                    if (i || H(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === Jo ? r = t.DEPTH_COMPONENT32F : e.type === Zo && (r = t.DEPTH_COMPONENT24));
                        const i = k(n);
                        H(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                    } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = k(n);
                    i && !1 === H(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : H(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let r = 0; r < e.length; r++) {
                        const s = e[r],
                            o = a.convert(s.format, s.colorSpace),
                            l = a.convert(s.type),
                            c = T(s.internalFormat, o, l, s.colorSpace),
                            h = k(n);
                        i && !1 === H(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, h, c, n.width, n.height) : H(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, h, c, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height)
                    }
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function B(e) {
                const r = i.get(e),
                    a = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (a) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(e, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), P(r.depthTexture, 0);
                        const a = i.get(r.depthTexture).__webglTexture,
                            s = k(r);
                        if (r.depthTexture.format === el) H(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0, s) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0);
                        else {
                            if (r.depthTexture.format !== nl) throw new Error("Unknown depthTexture format");
                            H(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0, s) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (a) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), z(r.__webglDepthbuffer[i], e, !1)
                } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), z(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function k(t) {
                return Math.min(u, t.samples)
            }

            function H(t) {
                const n = i.get(t);
                return o && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function V(t, n) {
                const i = t.colorSpace,
                    r = t.format,
                    a = t.type;
                return !0 === t.isCompressedTexture || t.format === _l || i !== pl && "" !== i && (i === dl ? !1 === o ? !0 === e.has("EXT_sRGB") && r === tl ? (t.format = _l, t.minFilter = qo, t.generateMipmaps = !1) : n = ql.sRGBToLinear(n) : r === tl && a === Yo || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)), n
            }
            this.allocateTextureUnit = function() {
                const t = C;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), C += 1, t
            }, this.resetTextureUnits = function() {
                C = 0
            }, this.setTexture2D = P, this.setTexture2DArray = function(e, r) {
                const a = i.get(e);
                e.version > 0 && a.__version !== e.version ? O(a, e, r) : n.bindTexture(t.TEXTURE_2D_ARRAY, a.__webglTexture, t.TEXTURE0 + r)
            }, this.setTexture3D = function(e, r) {
                const a = i.get(e);
                e.version > 0 && a.__version !== e.version ? O(a, e, r) : n.bindTexture(t.TEXTURE_3D, a.__webglTexture, t.TEXTURE0 + r)
            }, this.setTextureCube = function(e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? function(e, r, s) {
                    if (6 !== r.image.length) return;
                    const l = N(e, r),
                        h = r.source;
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + s);
                    const u = i.get(h);
                    if (h.version !== u.__version || !0 === l) {
                        n.activeTexture(t.TEXTURE0 + s), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                        const e = r.isCompressedTexture || r.image[0].isCompressedTexture,
                            i = r.image[0] && r.image[0].isDataTexture,
                            d = [];
                        for (let t = 0; t < 6; t++) d[t] = e || i ? i ? r.image[t].image : r.image[t] : x(r.image[t], !1, !0, c), d[t] = V(r, d[t]);
                        const p = d[0],
                            f = y(p) || o,
                            m = a.convert(r.format, r.colorSpace),
                            g = a.convert(r.type),
                            _ = T(r.internalFormat, m, g, r.colorSpace),
                            v = o && !0 !== r.isVideoTexture,
                            b = void 0 === u.__version || !0 === l;
                        let w, A = E(r, p, f);
                        if (I(t.TEXTURE_CUBE_MAP, r, f), e) {
                            v && b && n.texStorage2D(t.TEXTURE_CUBE_MAP, A, _, p.width, p.height);
                            for (let e = 0; e < 6; e++) {
                                w = d[e].mipmaps;
                                for (let i = 0; i < w.length; i++) {
                                    const a = w[i];
                                    r.format !== tl ? null !== m ? v ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, a.width, a.height, m, a.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, _, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, a.width, a.height, m, g, a.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, _, a.width, a.height, 0, m, g, a.data)
                                }
                            }
                        } else {
                            w = r.mipmaps, v && b && (w.length > 0 && A++, n.texStorage2D(t.TEXTURE_CUBE_MAP, A, _, d[0].width, d[0].height));
                            for (let e = 0; e < 6; e++)
                                if (i) {
                                    v ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, d[e].width, d[e].height, m, g, d[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, _, d[e].width, d[e].height, 0, m, g, d[e].data);
                                    for (let i = 0; i < w.length; i++) {
                                        const r = w[i].image[e].image;
                                        v ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, r.width, r.height, m, g, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, _, r.width, r.height, 0, m, g, r.data)
                                    }
                                } else {
                                    v ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, m, g, d[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, _, m, g, d[e]);
                                    for (let i = 0; i < w.length; i++) {
                                        const r = w[i];
                                        v ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, m, g, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, _, m, g, r.image[e])
                                    }
                                }
                        }
                        M(r, f) && S(t.TEXTURE_CUBE_MAP), u.__version = h.version, r.onUpdate && r.onUpdate(r)
                    }
                    e.__version = r.version
                }(s, e, r) : n.bindTexture(t.TEXTURE_CUBE_MAP, s.__webglTexture, t.TEXTURE0 + r)
            }, this.rebindTextures = function(e, n, r) {
                const a = i.get(e);
                void 0 !== n && F(a.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), void 0 !== r && B(e)
            }, this.setupRenderTarget = function(e) {
                const l = e.texture,
                    c = i.get(e),
                    h = i.get(l);
                e.addEventListener("dispose", A), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, s.memory.textures++);
                const u = !0 === e.isWebGLCubeRenderTarget,
                    d = !0 === e.isWebGLMultipleRenderTargets,
                    p = y(e) || o;
                if (u) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                } else {
                    if (c.__webglFramebuffer = t.createFramebuffer(), d)
                        if (r.drawBuffers) {
                            const n = e.texture;
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), s.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (o && e.samples > 0 && !1 === H(e)) {
                        const i = d ? l : [l];
                        c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            const r = i[n];
                            c.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const s = a.convert(r.format, r.colorSpace),
                                o = a.convert(r.type),
                                l = T(r.internalFormat, s, o, r.colorSpace, !0 === e.isXRRenderTarget),
                                h = k(e);
                            t.renderbufferStorageMultisample(t.RENDERBUFFER, h, l, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), z(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                }
                if (u) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), I(t.TEXTURE_CUBE_MAP, l, p);
                    for (let n = 0; n < 6; n++) F(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n);
                    M(l, p) && S(t.TEXTURE_CUBE_MAP), n.unbindTexture()
                } else if (d) {
                    const r = e.texture;
                    for (let a = 0, s = r.length; a < s; a++) {
                        const s = r[a],
                            o = i.get(s);
                        n.bindTexture(t.TEXTURE_2D, o.__webglTexture), I(t.TEXTURE_2D, s, p), F(c.__webglFramebuffer, e, s, t.COLOR_ATTACHMENT0 + a, t.TEXTURE_2D), M(s, p) && S(t.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = t.TEXTURE_2D;
                    (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (o ? i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(i, h.__webglTexture), I(i, l, p), F(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i), M(l, p) && S(i), n.unbindTexture()
                }
                e.depthBuffer && B(e)
            }, this.updateRenderTargetMipmap = function(e) {
                const r = y(e) || o,
                    a = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                for (let s = 0, o = a.length; s < o; s++) {
                    const o = a[s];
                    if (M(o, r)) {
                        const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                            a = i.get(o).__webglTexture;
                        n.bindTexture(r, a), S(r), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function(e) {
                if (o && e.samples > 0 && !1 === H(e)) {
                    const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
                        a = e.width,
                        s = e.height;
                    let o = t.COLOR_BUFFER_BIT;
                    const l = [],
                        c = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                        h = i.get(e),
                        u = !0 === e.isWebGLMultipleRenderTargets;
                    if (u)
                        for (let e = 0; e < r.length; e++) n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(t.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
                        const d = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                        if (!1 === d && (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (o |= t.STENCIL_BUFFER_BIT)), u && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, h.__webglColorRenderbuffer[n]), !0 === d && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])), u) {
                            const e = i.get(r[n]).__webglTexture;
                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                        }
                        t.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, t.NEAREST), p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), u)
                        for (let e = 0; e < r.length; e++) {
                            n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, h.__webglColorRenderbuffer[e]);
                            const a = i.get(r[e]).__webglTexture;
                            n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, a, 0)
                        }
                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = B, this.setupFrameBufferTexture = F, this.useMultisampledRTT = H
        }

        function Xp(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function(n, r = "") {
                    let a;
                    if (n === Yo) return t.UNSIGNED_BYTE;
                    if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                    if (1010 === n) return t.BYTE;
                    if (1011 === n) return t.SHORT;
                    if (n === Ko) return t.UNSIGNED_SHORT;
                    if (1013 === n) return t.INT;
                    if (n === Zo) return t.UNSIGNED_INT;
                    if (n === Jo) return t.FLOAT;
                    if (n === Qo) return i ? t.HALF_FLOAT : (a = e.get("OES_texture_half_float"), null !== a ? a.HALF_FLOAT_OES : null);
                    if (1021 === n) return t.ALPHA;
                    if (n === tl) return t.RGBA;
                    if (1024 === n) return t.LUMINANCE;
                    if (1025 === n) return t.LUMINANCE_ALPHA;
                    if (n === el) return t.DEPTH_COMPONENT;
                    if (n === nl) return t.DEPTH_STENCIL;
                    if (n === _l) return a = e.get("EXT_sRGB"), null !== a ? a.SRGB_ALPHA_EXT : null;
                    if (1028 === n) return t.RED;
                    if (1029 === n) return t.RED_INTEGER;
                    if (1030 === n) return t.RG;
                    if (1031 === n) return t.RG_INTEGER;
                    if (1033 === n) return t.RGBA_INTEGER;
                    if (n === il || n === rl || n === al || n === sl)
                        if (r === dl) {
                            if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === a) return null;
                            if (n === il) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === rl) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === al) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === sl) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (a = e.get("WEBGL_compressed_texture_s3tc"), null === a) return null;
                            if (n === il) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === rl) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === al) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === sl) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                        if (a = e.get("WEBGL_compressed_texture_pvrtc"), null === a) return null;
                        if (35840 === n) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === n) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === n) return a = e.get("WEBGL_compressed_texture_etc1"), null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === n || 37496 === n) {
                        if (a = e.get("WEBGL_compressed_texture_etc"), null === a) return null;
                        if (37492 === n) return r === dl ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                        if (37496 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (a = e.get("WEBGL_compressed_texture_astc"), null === a) return null;
                        if (37808 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n) return r === dl ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === ol) {
                        if (a = e.get("EXT_texture_compression_bptc"), null === a) return null;
                        if (n === ol) return r === dl ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    }
                    if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                        if (a = e.get("EXT_texture_compression_rgtc"), null === a) return null;
                        if (n === ol) return a.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === n) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === n) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === n) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === $o ? i ? t.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
                }
            }
        }
        class qp extends uu {
            constructor(t = []) {
                super(), this.isArrayCamera = !0, this.cameras = t
            }
        }
        class jp extends ih {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const Yp = {
            type: "move"
        };
        class Kp {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new jp, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new jp, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new nc, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new nc), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new jp, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new nc, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new nc), this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }
            connect(t) {
                if (t && t.hand) {
                    const e = this._hand;
                    if (e)
                        for (const n of t.hand.values()) this._getHandJoint(e, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: t
                }), this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(t, e, n) {
                let i = null,
                    r = null,
                    a = null;
                const s = this._targetRay,
                    o = this._grip,
                    l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) {
                    if (l && t.hand) {
                        a = !0;
                        for (const i of t.hand.values()) {
                            const t = e.getJointPose(i, n),
                                r = this._getHandJoint(l, i);
                            null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = t.radius), r.visible = null !== t
                        }
                        const i = l.joints["index-finger-tip"],
                            r = l.joints["thumb-tip"],
                            s = i.position.distanceTo(r.position),
                            o = .02,
                            c = .005;
                        l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    null !== s && (i = e.getPose(t.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(Yp)))
                }
                return null !== s && (s.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
            }
            _getHandJoint(t, e) {
                if (void 0 === t.joints[e.jointName]) {
                    const n = new jp;
                    n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
                }
                return t.joints[e.jointName]
            }
        }
        class Zp extends Jl {
            constructor(t, e, n, i, r, a, s, o, l, c) {
                if ((c = void 0 !== c ? c : el) !== el && c !== nl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === el && (n = Zo), void 0 === n && c === nl && (n = $o), super(null, i, r, a, s, o, c, n, l), this.isDepthTexture = !0, this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== s ? s : Wo, this.minFilter = void 0 !== o ? o : Wo, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
            }
            copy(t) {
                return super.copy(t), this.compareFunction = t.compareFunction, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
            }
        }
        class Jp extends yl {
            constructor(t, e) {
                super();
                const n = this;
                let i = null,
                    r = 1,
                    a = null,
                    s = "local-floor",
                    o = 1,
                    l = null,
                    c = null,
                    h = null,
                    u = null,
                    d = null,
                    p = null;
                const f = e.getContextAttributes();
                let m = null,
                    g = null;
                const _ = [],
                    v = [],
                    x = new uu;
                x.layers.enable(1), x.viewport = new Ql;
                const y = new uu;
                y.layers.enable(2), y.viewport = new Ql;
                const M = [x, y],
                    S = new qp;
                S.layers.enable(1), S.layers.enable(2);
                let T = null,
                    E = null;

                function b(t) {
                    const e = v.indexOf(t.inputSource);
                    if (-1 === e) return;
                    const n = _[e];
                    void 0 !== n && (n.update(t.inputSource, t.frame, l || a), n.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    }))
                }

                function w() {
                    i.removeEventListener("select", b), i.removeEventListener("selectstart", b), i.removeEventListener("selectend", b), i.removeEventListener("squeeze", b), i.removeEventListener("squeezestart", b), i.removeEventListener("squeezeend", b), i.removeEventListener("end", w), i.removeEventListener("inputsourceschange", A);
                    for (let t = 0; t < _.length; t++) {
                        const e = v[t];
                        null !== e && (v[t] = null, _[t].disconnect(e))
                    }
                    T = null, E = null, t.setRenderTarget(m), d = null, u = null, h = null, i = null, g = null, U.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function A(t) {
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                            i = v.indexOf(n);
                        i >= 0 && (v[i] = null, _[i].disconnect(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let i = v.indexOf(n);
                        if (-1 === i) {
                            for (let t = 0; t < _.length; t++) {
                                if (t >= v.length) {
                                    v.push(n), i = t;
                                    break
                                }
                                if (null === v[t]) {
                                    v[t] = n, i = t;
                                    break
                                }
                            }
                            if (-1 === i) break
                        }
                        const r = _[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new Kp, _[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new Kp, _[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new Kp, _[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(t) {
                    s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return l || a
                }, this.setReferenceSpace = function(t) {
                    l = t
                }, this.getBaseLayer = function() {
                    return null !== u ? u : d
                }, this.getBinding = function() {
                    return h
                }, this.getFrame = function() {
                    return p
                }, this.getSession = function() {
                    return i
                }, this.setSession = async function(c) {
                    if (i = c, null !== i) {
                        if (m = t.getRenderTarget(), i.addEventListener("select", b), i.addEventListener("selectstart", b), i.addEventListener("selectend", b), i.addEventListener("squeeze", b), i.addEventListener("squeezestart", b), i.addEventListener("squeezeend", b), i.addEventListener("end", w), i.addEventListener("inputsourceschange", A), !0 !== f.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || f.antialias,
                                alpha: !0,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            d = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                baseLayer: d
                            }), g = new $l(d.framebufferWidth, d.framebufferHeight, {
                                format: tl,
                                type: Yo,
                                colorSpace: t.outputColorSpace,
                                stencilBuffer: f.stencil
                            })
                        } else {
                            let n = null,
                                a = null,
                                s = null;
                            f.depth && (s = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = f.stencil ? nl : el, a = f.stencil ? $o : Zo);
                            const o = {
                                colorFormat: e.RGBA8,
                                depthFormat: s,
                                scaleFactor: r
                            };
                            h = new XRWebGLBinding(i, e), u = h.createProjectionLayer(o), i.updateRenderState({
                                layers: [u]
                            }), g = new $l(u.textureWidth, u.textureHeight, {
                                format: tl,
                                type: Yo,
                                depthTexture: new Zp(u.textureWidth, u.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: f.stencil,
                                colorSpace: t.outputColorSpace,
                                samples: f.antialias ? 4 : 0
                            }), t.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues
                        }
                        g.isXRRenderTarget = !0, this.setFoveation(o), l = null, a = await i.requestReferenceSpace(s), U.setContext(i), U.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }, this.getEnvironmentBlendMode = function() {
                    if (null !== i) return i.environmentBlendMode
                };
                const R = new nc,
                    C = new nc;

                function P(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function(t) {
                    if (null === i) return;
                    S.near = y.near = x.near = t.near, S.far = y.far = x.far = t.far, T === S.near && E === S.far || (i.updateRenderState({
                        depthNear: S.near,
                        depthFar: S.far
                    }), T = S.near, E = S.far);
                    const e = t.parent,
                        n = S.cameras;
                    P(S, e);
                    for (let t = 0; t < n.length; t++) P(n[t], e);
                    2 === n.length ? function(t, e, n) {
                            R.setFromMatrixPosition(e.matrixWorld), C.setFromMatrixPosition(n.matrixWorld);
                            const i = R.distanceTo(C),
                                r = e.projectionMatrix.elements,
                                a = n.projectionMatrix.elements,
                                s = r[14] / (r[10] - 1),
                                o = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                c = (r[9] - 1) / r[5],
                                h = (r[8] - 1) / r[0],
                                u = (a[8] + 1) / a[0],
                                d = s * h,
                                p = s * u,
                                f = i / (-h + u),
                                m = f * -h;
                            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                            const g = s + f,
                                _ = o + f,
                                v = d - m,
                                x = p + (i - m),
                                y = l * o / _ * g,
                                M = c * o / _ * g;
                            t.projectionMatrix.makePerspective(v, x, y, M, g, _), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                        }(S, x, y) : S.projectionMatrix.copy(x.projectionMatrix),
                        function(t, e, n) {
                            null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld)), t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0);
                            const i = t.children;
                            for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                            t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * Tl * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                        }(t, S, e)
                }, this.getCamera = function() {
                    return S
                }, this.getFoveation = function() {
                    if (null !== u || null !== d) return o
                }, this.setFoveation = function(t) {
                    o = t, null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                };
                let L = null;
                const U = new Tu;
                U.setAnimationLoop((function(e, i) {
                    if (c = i.getViewerPose(l || a), p = i, null !== c) {
                        const e = c.views;
                        null !== d && (t.setRenderTargetFramebuffer(g, d.framebuffer), t.setRenderTarget(g));
                        let n = !1;
                        e.length !== S.cameras.length && (S.cameras.length = 0, n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let a = null;
                            if (null !== d) a = d.getViewport(r);
                            else {
                                const e = h.getViewSubImage(u, r);
                                a = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                            }
                            let s = M[i];
                            void 0 === s && (s = new uu, s.layers.enable(i), s.viewport = new Ql, M[i] = s), s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.quaternion, s.scale), s.projectionMatrix.fromArray(r.projectionMatrix), s.projectionMatrixInverse.copy(s.projectionMatrix).invert(), s.viewport.set(a.x, a.y, a.width, a.height), 0 === i && (S.matrix.copy(s.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), !0 === n && S.cameras.push(s)
                        }
                    }
                    for (let t = 0; t < _.length; t++) {
                        const e = v[t],
                            n = _[t];
                        null !== e && void 0 !== n && n.update(e, i, l || a)
                    }
                    L && L(e, i), i.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: i
                    }), p = null
                })), this.setAnimationLoop = function(t) {
                    L = t
                }, this.dispose = function() {}
            }
        }

        function Qp(t, e) {
            function n(t, e) {
                !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
            }

            function i(i, r) {
                i.opacity.value = r.opacity, r.color && i.diffuse.value.copy(r.color), r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (i.map.value = r.map, n(r.map, i.mapTransform)), r.alphaMap && (i.alphaMap.value = r.alphaMap, n(r.alphaMap, i.alphaMapTransform)), r.bumpMap && (i.bumpMap.value = r.bumpMap, n(r.bumpMap, i.bumpMapTransform), i.bumpScale.value = r.bumpScale, 1 === r.side && (i.bumpScale.value *= -1)), r.normalMap && (i.normalMap.value = r.normalMap, n(r.normalMap, i.normalMapTransform), i.normalScale.value.copy(r.normalScale), 1 === r.side && i.normalScale.value.negate()), r.displacementMap && (i.displacementMap.value = r.displacementMap, n(r.displacementMap, i.displacementMapTransform), i.displacementScale.value = r.displacementScale, i.displacementBias.value = r.displacementBias), r.emissiveMap && (i.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, i.emissiveMapTransform)), r.specularMap && (i.specularMap.value = r.specularMap, n(r.specularMap, i.specularMapTransform)), r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
                const a = e.get(r).envMap;
                if (a && (i.envMap.value = a, i.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = r.reflectivity, i.ior.value = r.ior, i.refractionRatio.value = r.refractionRatio), r.lightMap) {
                    i.lightMap.value = r.lightMap;
                    const e = !0 === t.useLegacyLights ? Math.PI : 1;
                    i.lightMapIntensity.value = r.lightMapIntensity * e, n(r.lightMap, i.lightMapTransform)
                }
                r.aoMap && (i.aoMap.value = r.aoMap, i.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, i.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(e, n) {
                    n.color.getRGB(e.fogColor.value, ou(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(t, r, a, s, o) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(t, r) : r.isMeshToonMaterial ? (i(t, r), function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(t, r)) : r.isMeshPhongMaterial ? (i(t, r), function(t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                    }(t, r)) : r.isMeshStandardMaterial ? (i(t, r), function(t, i) {
                        t.metalness.value = i.metalness, i.metalnessMap && (t.metalnessMap.value = i.metalnessMap, n(i.metalnessMap, t.metalnessMapTransform)), t.roughness.value = i.roughness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap, n(i.roughnessMap, t.roughnessMapTransform)), e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity)
                    }(t, r), r.isMeshPhysicalMaterial && function(t, e, i) {
                        t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), 1 === e.side && t.clearcoatNormalScale.value.negate())), e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform))), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform)), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform))
                    }(t, r, o)) : r.isMeshMatcapMaterial ? (i(t, r), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap)
                    }(t, r)) : r.isMeshDepthMaterial ? i(t, r) : r.isMeshDistanceMaterial ? (i(t, r), function(t, n) {
                        const i = e.get(n).light;
                        t.referencePosition.value.setFromMatrixPosition(i.matrixWorld), t.nearDistance.value = i.shadow.camera.near, t.farDistance.value = i.shadow.camera.far
                    }(t, r)) : r.isMeshNormalMaterial ? i(t, r) : r.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform))
                    }(t, r), r.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, r)) : r.isPointsMaterial ? function(t, e, i, r) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * r, e.map && (t.map.value = e.map, n(e.map, t.uvTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, r, a, s) : r.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }

        function $p(t, e, n, i) {
            let r = {},
                a = {},
                s = [];
            const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

            function l(t, e, n) {
                const i = t.value;
                if (void 0 === n[e]) {
                    if ("number" == typeof i) n[e] = i;
                    else {
                        const t = Array.isArray(i) ? i : [i],
                            r = [];
                        for (let e = 0; e < t.length; e++) r.push(t[e].clone());
                        n[e] = r
                    }
                    return !0
                }
                if ("number" == typeof i) {
                    if (n[e] !== i) return n[e] = i, !0
                } else {
                    const t = Array.isArray(n[e]) ? n[e] : [n[e]],
                        r = Array.isArray(i) ? i : [i];
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        if (!1 === n.equals(r[e])) return n.copy(r[e]), !0
                    }
                }
                return !1
            }

            function c(t) {
                const e = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e
            }

            function h(e) {
                const n = e.target;
                n.removeEventListener("dispose", h);
                const i = s.indexOf(n.__bindingPointIndex);
                s.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete a[n.id]
            }
            return {
                bind: function(t, e) {
                    const n = e.program;
                    i.uniformBlockBinding(t, n)
                },
                update: function(n, u) {
                    let d = r[n.id];
                    void 0 === d && (function(t) {
                        const e = t.uniforms;
                        let n = 0,
                            i = 0;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t],
                                a = {
                                    boundary: 0,
                                    storage: 0
                                },
                                s = Array.isArray(r.value) ? r.value : [r.value];
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = c(s[t]);
                                a.boundary += e.boundary, a.storage += e.storage
                            }
                            r.__data = new Float32Array(a.storage / Float32Array.BYTES_PER_ELEMENT), r.__offset = n, t > 0 && (i = n % 16, 0 !== i && 16 - i - a.boundary < 0 && (n += 16 - i, r.__offset = n)), n += a.storage
                        }
                        i = n % 16, i > 0 && (n += 16 - i), t.__size = n, t.__cache = {}
                    }(n), d = function(e) {
                        const n = function() {
                            for (let t = 0; t < o; t++)
                                if (-1 === s.indexOf(t)) return s.push(t), t;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }();
                        e.__bindingPointIndex = n;
                        const i = t.createBuffer(),
                            r = e.__size,
                            a = e.usage;
                        return t.bindBuffer(t.UNIFORM_BUFFER, i), t.bufferData(t.UNIFORM_BUFFER, r, a), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, i), i
                    }(n), r[n.id] = d, n.addEventListener("dispose", h));
                    const p = u.program;
                    i.updateUBOMapping(n, p);
                    const f = e.render.frame;
                    a[n.id] !== f && (function(e) {
                        const n = r[e.id],
                            i = e.uniforms,
                            a = e.__cache;
                        t.bindBuffer(t.UNIFORM_BUFFER, n);
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            if (!0 === l(n, e, a)) {
                                const e = n.__offset,
                                    i = Array.isArray(n.value) ? n.value : [n.value];
                                let r = 0;
                                for (let a = 0; a < i.length; a++) {
                                    const s = i[a],
                                        o = c(s);
                                    "number" == typeof s ? (n.__data[0] = s, t.bufferSubData(t.UNIFORM_BUFFER, e + r, n.__data)) : s.isMatrix3 ? (n.__data[0] = s.elements[0], n.__data[1] = s.elements[1], n.__data[2] = s.elements[2], n.__data[3] = s.elements[0], n.__data[4] = s.elements[3], n.__data[5] = s.elements[4], n.__data[6] = s.elements[5], n.__data[7] = s.elements[0], n.__data[8] = s.elements[6], n.__data[9] = s.elements[7], n.__data[10] = s.elements[8], n.__data[11] = s.elements[0]) : (s.toArray(n.__data, r), r += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                }
                                t.bufferSubData(t.UNIFORM_BUFFER, e, n.__data)
                            }
                        }
                        t.bindBuffer(t.UNIFORM_BUFFER, null)
                    }(n), a[n.id] = f)
                },
                dispose: function() {
                    for (const e in r) t.deleteBuffer(r[e]);
                    s = [], r = {}, a = {}
                }
            }
        }

        function tf() {
            const t = Nl("canvas");
            return t.style.display = "block", t
        }
        class ef {
            constructor(t = {}) {
                const {
                    canvas: e = tf(),
                    context: n = null,
                    depth: i = !0,
                    stencil: r = !0,
                    alpha: a = !1,
                    antialias: s = !1,
                    premultipliedAlpha: o = !0,
                    preserveDrawingBuffer: l = !1,
                    powerPreference: c = "default",
                    failIfMajorPerformanceCaveat: h = !1
                } = t;
                let u;
                this.isWebGLRenderer = !0, u = null !== n ? n.getContextAttributes().alpha : a;
                const d = new Uint32Array(4),
                    p = new Int32Array(4);
                let f = null,
                    m = null;
                const g = [],
                    _ = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = dl, this.useLegacyLights = !0, this.toneMapping = Uo, this.toneMappingExposure = 1;
                const v = this;
                let x = !1,
                    y = 0,
                    M = 0,
                    S = null,
                    T = -1,
                    E = null;
                const b = new Ql,
                    w = new Ql;
                let A = null;
                const R = new Sh(0);
                let C = 0,
                    P = e.width,
                    L = e.height,
                    U = 1,
                    D = null,
                    I = null;
                const N = new Ql(0, 0, P, L),
                    O = new Ql(0, 0, P, L);
                let F = !1;
                const z = new Su;
                let B = !1,
                    k = !1,
                    H = null;
                const V = new Uc,
                    G = new Ll,
                    W = new nc,
                    X = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function q() {
                    return null === S ? U : 1
                }
                let j, Y, K, Z, J, Q, $, tt, et, nt, it, rt, at, st, ot, lt, ct, ht, ut, dt, pt, ft, mt, gt, _t = n;

                function vt(t, n) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i],
                            a = e.getContext(r, n);
                        if (null !== a) return a
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: i,
                        stencil: r,
                        antialias: s,
                        premultipliedAlpha: o,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: h
                    };
                    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Eo}`), e.addEventListener("webglcontextlost", Mt, !1), e.addEventListener("webglcontextrestored", St, !1), e.addEventListener("webglcontextcreationerror", Tt, !1), null === _t) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === v.isWebGL1Renderer && e.shift(), _t = vt(e, t), null === _t) throw vt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" != typeof WebGLRenderingContext && _t instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === _t.getShaderPrecisionFormat && (_t.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message), t
                }

                function xt() {
                    j = new Zu(_t), Y = new Du(_t, j, t), j.init(Y), ft = new Xp(_t, j, Y), K = new Gp(_t, j, Y), Z = new $u(_t), J = new Cp, Q = new Wp(_t, j, K, J, Y, ft, Z), $ = new Nu(v), tt = new Ku(v), et = new Eu(_t, Y), mt = new Lu(_t, j, et, Y), nt = new Ju(_t, et, Z, mt), it = new id(_t, nt, et, Z), ut = new nd(_t, Y, Q), lt = new Iu(J), rt = new Rp(v, $, tt, j, Y, mt, lt), at = new Qp(v, J), st = new Dp, ot = new Bp(j, Y), ht = new Pu(v, $, tt, K, it, u, o), ct = new Vp(v, it, Y), gt = new $p(_t, Z, Y, K), dt = new Uu(_t, j, Z, Y), pt = new Qu(_t, j, Z, Y), Z.programs = rt.programs, v.capabilities = Y, v.extensions = j, v.properties = J, v.renderLists = st, v.shadowMap = ct, v.state = K, v.info = Z
                }
                xt();
                const yt = new Jp(v, _t);

                function Mt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
                }

                function St() {
                    console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
                    const t = Z.autoReset,
                        e = ct.enabled,
                        n = ct.autoUpdate,
                        i = ct.needsUpdate,
                        r = ct.type;
                    xt(), Z.autoReset = t, ct.enabled = e, ct.autoUpdate = n, ct.needsUpdate = i, ct.type = r
                }

                function Tt(t) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
                }

                function Et(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", Et),
                        function(t) {
                            (function(t) {
                                const e = J.get(t).programs;
                                void 0 !== e && (e.forEach((function(t) {
                                    rt.releaseProgram(t)
                                })), t.isShaderMaterial && rt.releaseShaderCache(t))
                            })(t), J.remove(t)
                        }(e)
                }
                this.xr = yt, this.getContext = function() {
                    return _t
                }, this.getContextAttributes = function() {
                    return _t.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const t = j.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    const t = j.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return U
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (U = t, this.setSize(P, L, !1))
                }, this.getSize = function(t) {
                    return t.set(P, L)
                }, this.setSize = function(t, n, i = !0) {
                    yt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = t, L = n, e.width = Math.floor(t * U), e.height = Math.floor(n * U), !0 === i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function(t) {
                    return t.set(P * U, L * U).floor()
                }, this.setDrawingBufferSize = function(t, n, i) {
                    P = t, L = n, U = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function(t) {
                    return t.copy(b)
                }, this.getViewport = function(t) {
                    return t.copy(N)
                }, this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), K.viewport(b.copy(N).multiplyScalar(U).floor())
                }, this.getScissor = function(t) {
                    return t.copy(O)
                }, this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), K.scissor(w.copy(O).multiplyScalar(U).floor())
                }, this.getScissorTest = function() {
                    return F
                }, this.setScissorTest = function(t) {
                    K.setScissorTest(F = t)
                }, this.setOpaqueSort = function(t) {
                    D = t
                }, this.setTransparentSort = function(t) {
                    I = t
                }, this.getClearColor = function(t) {
                    return t.copy(ht.getClearColor())
                }, this.setClearColor = function() {
                    ht.setClearColor.apply(ht, arguments)
                }, this.getClearAlpha = function() {
                    return ht.getClearAlpha()
                }, this.setClearAlpha = function() {
                    ht.setClearAlpha.apply(ht, arguments)
                }, this.clear = function(t = !0, e = !0, n = !0) {
                    let i = 0;
                    if (t) {
                        let t = !1;
                        if (null !== S) {
                            const e = S.texture.format;
                            t = 1033 === e || 1031 === e || 1029 === e
                        }
                        if (t) {
                            const t = S.texture.type,
                                e = t === Yo || t === Zo || t === Ko || t === $o || 1017 === t || 1018 === t,
                                n = ht.getClearColor(),
                                i = ht.getClearAlpha(),
                                r = n.r,
                                a = n.g,
                                s = n.b;
                            e ? (d[0] = r, d[1] = a, d[2] = s, d[3] = i, _t.clearBufferuiv(_t.COLOR, 0, d)) : (p[0] = r, p[1] = a, p[2] = s, p[3] = i, _t.clearBufferiv(_t.COLOR, 0, p))
                        } else i |= _t.COLOR_BUFFER_BIT
                    }
                    e && (i |= _t.DEPTH_BUFFER_BIT), n && (i |= _t.STENCIL_BUFFER_BIT), _t.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", Mt, !1), e.removeEventListener("webglcontextrestored", St, !1), e.removeEventListener("webglcontextcreationerror", Tt, !1), st.dispose(), ot.dispose(), J.dispose(), $.dispose(), tt.dispose(), it.dispose(), mt.dispose(), gt.dispose(), rt.dispose(), yt.dispose(), yt.removeEventListener("sessionstart", wt), yt.removeEventListener("sessionend", At), H && (H.dispose(), H = null), Rt.stop()
                }, this.renderBufferDirect = function(t, e, n, i, r, a) {
                    null === e && (e = X);
                    const s = r.isMesh && r.matrixWorld.determinant() < 0,
                        o = function(t, e, n, i, r) {
                            !0 !== e.isScene && (e = X), Q.resetTextureUnits();
                            const a = e.fog,
                                s = i.isMeshStandardMaterial ? e.environment : null,
                                o = null === S ? v.outputColorSpace : !0 === S.isXRRenderTarget ? S.texture.colorSpace : pl,
                                l = (i.isMeshStandardMaterial ? tt : $).get(i.envMap || s),
                                c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                                u = !!n.morphAttributes.position,
                                d = !!n.morphAttributes.normal,
                                p = !!n.morphAttributes.color,
                                f = i.toneMapped ? v.toneMapping : Uo,
                                g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                _ = void 0 !== g ? g.length : 0,
                                x = J.get(i),
                                y = m.state.lights;
                            if (!0 === B && (!0 === k || t !== E)) {
                                const e = t === E && i.id === T;
                                lt.setState(i, t, e)
                            }
                            let M = !1;
                            i.version === x.__version ? x.needsLights && x.lightsStateVersion !== y.state.version || x.outputColorSpace !== o || r.isInstancedMesh && !1 === x.instancing ? M = !0 : r.isInstancedMesh || !0 !== x.instancing ? r.isSkinnedMesh && !1 === x.skinning ? M = !0 : r.isSkinnedMesh || !0 !== x.skinning ? x.envMap !== l || !0 === i.fog && x.fog !== a ? M = !0 : void 0 === x.numClippingPlanes || x.numClippingPlanes === lt.numPlanes && x.numIntersection === lt.numIntersection ? (x.vertexAlphas !== c || x.vertexTangents !== h || x.morphTargets !== u || x.morphNormals !== d || x.morphColors !== p || x.toneMapping !== f || !0 === Y.isWebGL2 && x.morphTargetsCount !== _) && (M = !0) : M = !0 : M = !0 : M = !0 : (M = !0, x.__version = i.version);
                            let b = x.currentProgram;
                            !0 === M && (b = Dt(i, e, r));
                            let w = !1,
                                A = !1,
                                R = !1;
                            const C = b.getUniforms(),
                                P = x.uniforms;
                            if (K.useProgram(b.program) && (w = !0, A = !0, R = !0), i.id !== T && (T = i.id, A = !0), w || E !== t) {
                                if (C.setValue(_t, "projectionMatrix", t.projectionMatrix), Y.logarithmicDepthBuffer && C.setValue(_t, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, A = !0, R = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                                    const e = C.map.cameraPosition;
                                    void 0 !== e && e.setValue(_t, W.setFromMatrixPosition(t.matrixWorld))
                                }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(_t, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && C.setValue(_t, "viewMatrix", t.matrixWorldInverse)
                            }
                            if (r.isSkinnedMesh) {
                                C.setOptional(_t, r, "bindMatrix"), C.setOptional(_t, r, "bindMatrixInverse");
                                const t = r.skeleton;
                                t && (Y.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), C.setValue(_t, "boneTexture", t.boneTexture, Q), C.setValue(_t, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            const D = n.morphAttributes;
                            var I, N;
                            if ((void 0 !== D.position || void 0 !== D.normal || void 0 !== D.color && !0 === Y.isWebGL2) && ut.update(r, n, b), (A || x.receiveShadow !== r.receiveShadow) && (x.receiveShadow = r.receiveShadow, C.setValue(_t, "receiveShadow", r.receiveShadow)), i.isMeshGouraudMaterial && null !== i.envMap && (P.envMap.value = l, P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), A && (C.setValue(_t, "toneMappingExposure", v.toneMappingExposure), x.needsLights && (N = R, (I = P).ambientLightColor.needsUpdate = N, I.lightProbe.needsUpdate = N, I.directionalLights.needsUpdate = N, I.directionalLightShadows.needsUpdate = N, I.pointLights.needsUpdate = N, I.pointLightShadows.needsUpdate = N, I.spotLights.needsUpdate = N, I.spotLightShadows.needsUpdate = N, I.rectAreaLights.needsUpdate = N, I.hemisphereLights.needsUpdate = N), a && !0 === i.fog && at.refreshFogUniforms(P, a), at.refreshMaterialUniforms(P, i, U, L, H), op.upload(_t, x.uniformsList, P, Q)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (op.upload(_t, x.uniformsList, P, Q), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && C.setValue(_t, "center", r.center), C.setValue(_t, "modelViewMatrix", r.modelViewMatrix), C.setValue(_t, "normalMatrix", r.normalMatrix), C.setValue(_t, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                                const t = i.uniformsGroups;
                                for (let e = 0, n = t.length; e < n; e++)
                                    if (Y.isWebGL2) {
                                        const n = t[e];
                                        gt.update(n, b), gt.bind(n, b)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return b
                        }(t, e, n, i, r);
                    K.setMaterial(i, s);
                    let l = n.index,
                        c = 1;
                    !0 === i.wireframe && (l = nt.getWireframeAttribute(n), c = 2);
                    const h = n.drawRange,
                        u = n.attributes.position;
                    let d = h.start * c,
                        p = (h.start + h.count) * c;
                    null !== a && (d = Math.max(d, a.start * c), p = Math.min(p, (a.start + a.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count));
                    const f = p - d;
                    if (f < 0 || f === 1 / 0) return;
                    let g;
                    mt.setup(r, i, o, n, l);
                    let _ = dt;
                    if (null !== l && (g = et.get(l), _ = pt, _.setIndex(g)), r.isMesh) !0 === i.wireframe ? (K.setLineWidth(i.wireframeLinewidth * q()), _.setMode(_t.LINES)) : _.setMode(_t.TRIANGLES);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1), K.setLineWidth(t * q()), r.isLineSegments ? _.setMode(_t.LINES) : r.isLineLoop ? _.setMode(_t.LINE_LOOP) : _.setMode(_t.LINE_STRIP)
                    } else r.isPoints ? _.setMode(_t.POINTS) : r.isSprite && _.setMode(_t.TRIANGLES);
                    if (r.isInstancedMesh) _.renderInstances(d, f, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                            e = Math.min(n.instanceCount, t);
                        _.renderInstances(d, f, e)
                    } else _.render(d, f)
                }, this.compile = function(t, e) {
                    function n(t, e, n) {
                        !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = 1, t.needsUpdate = !0, Dt(t, e, n), t.side = 0, t.needsUpdate = !0, Dt(t, e, n), t.side = 2) : Dt(t, e, n)
                    }
                    m = ot.get(t), m.init(), _.push(m), t.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
                    })), m.setupLights(v.useLegacyLights), t.traverse((function(e) {
                        const i = e.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let r = 0; r < i.length; r++) n(i[r], t, e);
                            else n(i, t, e)
                    })), _.pop(), m = null
                };
                let bt = null;

                function wt() {
                    Rt.stop()
                }

                function At() {
                    Rt.start()
                }
                const Rt = new Tu;

                function Ct(t, e, n, i) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || z.intersectsSprite(t)) {
                            i && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                            const e = it.update(t),
                                r = t.material;
                            r.visible && f.push(t, e, r, n, W.z, null)
                        }
                    } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || z.intersectsObject(t))) {
                        const e = it.update(t),
                            r = t.material;
                        if (i && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), W.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), W.copy(e.boundingSphere.center)), W.applyMatrix4(t.matrixWorld).applyMatrix4(V)), Array.isArray(r)) {
                            const i = e.groups;
                            for (let a = 0, s = i.length; a < s; a++) {
                                const s = i[a],
                                    o = r[s.materialIndex];
                                o && o.visible && f.push(t, e, o, n, W.z, s)
                            }
                        } else r.visible && f.push(t, e, r, n, W.z, null)
                    }
                    const r = t.children;
                    for (let t = 0, a = r.length; t < a; t++) Ct(r[t], e, n, i)
                }

                function Pt(t, e, n, i) {
                    const r = t.opaque,
                        a = t.transmissive,
                        s = t.transparent;
                    m.setupLightsView(n), !0 === B && lt.setGlobalState(v.clippingPlanes, n), a.length > 0 && function(t, e, n, i) {
                        const r = Y.isWebGL2;
                        null === H && (H = new $l(1, 1, {
                            generateMipmaps: !0,
                            type: j.has("EXT_color_buffer_half_float") ? Qo : Yo,
                            minFilter: jo,
                            samples: r ? 4 : 0
                        })), v.getDrawingBufferSize(G), r ? H.setSize(G.x, G.y) : H.setSize(Rl(G.x), Rl(G.y));
                        const a = v.getRenderTarget();
                        v.setRenderTarget(H), v.getClearColor(R), C = v.getClearAlpha(), C < 1 && v.setClearColor(16777215, .5), v.clear();
                        const s = v.toneMapping;
                        v.toneMapping = Uo, Lt(t, n, i), Q.updateMultisampleRenderTarget(H), Q.updateRenderTargetMipmap(H);
                        let o = !1;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t],
                                a = r.object,
                                s = r.geometry,
                                l = r.material,
                                c = r.group;
                            if (2 === l.side && a.layers.test(i.layers)) {
                                const t = l.side;
                                l.side = 1, l.needsUpdate = !0, Ut(a, n, i, s, l, c), l.side = t, l.needsUpdate = !0, o = !0
                            }
                        }!0 === o && (Q.updateMultisampleRenderTarget(H), Q.updateRenderTargetMipmap(H)), v.setRenderTarget(a), v.setClearColor(R, C), v.toneMapping = s
                    }(r, a, e, n), i && K.viewport(b.copy(i)), r.length > 0 && Lt(r, e, n), a.length > 0 && Lt(a, e, n), s.length > 0 && Lt(s, e, n), K.buffers.depth.setTest(!0), K.buffers.depth.setMask(!0), K.buffers.color.setMask(!0), K.setPolygonOffset(!1)
                }

                function Lt(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, a = t.length; r < a; r++) {
                        const a = t[r],
                            s = a.object,
                            o = a.geometry,
                            l = null === i ? a.material : i,
                            c = a.group;
                        s.layers.test(n.layers) && Ut(s, e, n, o, l, c)
                    }
                }

                function Ut(t, e, n, i, r, a) {
                    t.onBeforeRender(v, e, n, i, r, a), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(v, e, n, i, t, a), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, v.renderBufferDirect(n, e, i, r, t, a), r.side = 0, r.needsUpdate = !0, v.renderBufferDirect(n, e, i, r, t, a), r.side = 2) : v.renderBufferDirect(n, e, i, r, t, a), t.onAfterRender(v, e, n, i, r, a)
                }

                function Dt(t, e, n) {
                    !0 !== e.isScene && (e = X);
                    const i = J.get(t),
                        r = m.state.lights,
                        a = m.state.shadowsArray,
                        s = r.state.version,
                        o = rt.getParameters(t, r.state, a, e, n),
                        l = rt.getProgramCacheKey(o);
                    let c = i.programs;
                    i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? tt : $).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Et), c = new Map, i.programs = c);
                    let h = c.get(l);
                    if (void 0 !== h) {
                        if (i.currentProgram === h && i.lightsStateVersion === s) return It(t, o), h
                    } else o.uniforms = rt.getUniforms(t), t.onBuild(n, o, v), t.onBeforeCompile(o, v), h = rt.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                    const u = i.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = lt.uniform), It(t, o), i.needsLights = function(t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), i.lightsStateVersion = s, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const d = h.getUniforms(),
                        p = op.seqWithValue(d.seq, u);
                    return i.currentProgram = h, i.uniformsList = p, h
                }

                function It(t, e) {
                    const n = J.get(t);
                    n.outputColorSpace = e.outputColorSpace, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                }
                Rt.setAnimationLoop((function(t) {
                    bt && bt(t)
                })), "undefined" != typeof self && Rt.setContext(self), this.setAnimationLoop = function(t) {
                    bt = t, yt.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start()
                }, yt.addEventListener("sessionstart", wt), yt.addEventListener("sessionend", At), this.render = function(t, e) {
                    if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === x) return;
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === yt.enabled && !0 === yt.isPresenting && (!0 === yt.cameraAutoUpdate && yt.updateCamera(e), e = yt.getCamera()), !0 === t.isScene && t.onBeforeRender(v, t, e, S), m = ot.get(t, _.length), m.init(), _.push(m), V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), z.setFromProjectionMatrix(V), k = this.localClippingEnabled, B = lt.init(this.clippingPlanes, k), f = st.get(t, g.length), f.init(), g.push(f), Ct(t, e, 0, v.sortObjects), f.finish(), !0 === v.sortObjects && f.sort(D, I), this.info.render.frame++, !0 === B && lt.beginShadows();
                    const n = m.state.shadowsArray;
                    if (ct.render(n, t, e), !0 === B && lt.endShadows(), !0 === this.info.autoReset && this.info.reset(), ht.render(f, t), m.setupLights(v.useLegacyLights), e.isArrayCamera) {
                        const n = e.cameras;
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            Pt(f, t, i, i.viewport)
                        }
                    } else Pt(f, t, e);
                    null !== S && (Q.updateMultisampleRenderTarget(S), Q.updateRenderTargetMipmap(S)), !0 === t.isScene && t.onAfterRender(v, t, e), mt.resetDefaultState(), T = -1, E = null, _.pop(), m = _.length > 0 ? _[_.length - 1] : null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return y
                }, this.getActiveMipmapLevel = function() {
                    return M
                }, this.getRenderTarget = function() {
                    return S
                }, this.setRenderTargetTextures = function(t, e, n) {
                    J.get(t.texture).__webglTexture = e, J.get(t.depthTexture).__webglTexture = n;
                    const i = J.get(t);
                    i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === j.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function(t, e) {
                    const n = J.get(t);
                    n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                }, this.setRenderTarget = function(t, e = 0, n = 0) {
                    S = t, y = e, M = n;
                    let i = !0,
                        r = null,
                        a = !1,
                        s = !1;
                    if (t) {
                        const n = J.get(t);
                        void 0 !== n.__useDefaultFramebuffer ? (K.bindFramebuffer(_t.FRAMEBUFFER, null), i = !1) : void 0 === n.__webglFramebuffer ? Q.setupRenderTarget(t) : n.__hasExternalTextures && Q.rebindTextures(t, J.get(t.texture).__webglTexture, J.get(t.depthTexture).__webglTexture);
                        const o = t.texture;
                        (o.isData3DTexture || o.isDataArrayTexture || o.isCompressedArrayTexture) && (s = !0);
                        const l = J.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (r = l[e], a = !0) : r = Y.isWebGL2 && t.samples > 0 && !1 === Q.useMultisampledRTT(t) ? J.get(t).__webglMultisampledFramebuffer : l, b.copy(t.viewport), w.copy(t.scissor), A = t.scissorTest
                    } else b.copy(N).multiplyScalar(U).floor(), w.copy(O).multiplyScalar(U).floor(), A = F;
                    if (K.bindFramebuffer(_t.FRAMEBUFFER, r) && Y.drawBuffers && i && K.drawBuffers(t, r), K.viewport(b), K.scissor(w), K.setScissorTest(A), a) {
                        const i = J.get(t.texture);
                        _t.framebufferTexture2D(_t.FRAMEBUFFER, _t.COLOR_ATTACHMENT0, _t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                    } else if (s) {
                        const i = J.get(t.texture),
                            r = e || 0;
                        _t.framebufferTextureLayer(_t.FRAMEBUFFER, _t.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    T = -1
                }, this.readRenderTargetPixels = function(t, e, n, i, r, a, s) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = J.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                        K.bindFramebuffer(_t.FRAMEBUFFER, o);
                        try {
                            const s = t.texture,
                                o = s.format,
                                l = s.type;
                            if (o !== tl && ft.convert(o) !== _t.getParameter(_t.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === Qo && (j.has("EXT_color_buffer_half_float") || Y.isWebGL2 && j.has("EXT_color_buffer_float"));
                            if (!(l === Yo || ft.convert(l) === _t.getParameter(_t.IMPLEMENTATION_COLOR_READ_TYPE) || l === Jo && (Y.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && _t.readPixels(e, n, i, r, ft.convert(o), ft.convert(l), a)
                        } finally {
                            const t = null !== S ? J.get(S).__webglFramebuffer : null;
                            K.bindFramebuffer(_t.FRAMEBUFFER, t)
                        }
                    }
                }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                    const i = Math.pow(2, -n),
                        r = Math.floor(e.image.width * i),
                        a = Math.floor(e.image.height * i);
                    Q.setTexture2D(e, 0), _t.copyTexSubImage2D(_t.TEXTURE_2D, n, 0, 0, t.x, t.y, r, a), K.unbindTexture()
                }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                    const r = e.image.width,
                        a = e.image.height,
                        s = ft.convert(n.format),
                        o = ft.convert(n.type);
                    Q.setTexture2D(n, 0), _t.pixelStorei(_t.UNPACK_FLIP_Y_WEBGL, n.flipY), _t.pixelStorei(_t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), _t.pixelStorei(_t.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? _t.texSubImage2D(_t.TEXTURE_2D, i, t.x, t.y, r, a, s, o, e.image.data) : e.isCompressedTexture ? _t.compressedTexSubImage2D(_t.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : _t.texSubImage2D(_t.TEXTURE_2D, i, t.x, t.y, s, o, e.image), 0 === i && n.generateMipmaps && _t.generateMipmap(_t.TEXTURE_2D), K.unbindTexture()
                }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
                    if (v.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const a = t.max.x - t.min.x + 1,
                        s = t.max.y - t.min.y + 1,
                        o = t.max.z - t.min.z + 1,
                        l = ft.convert(i.format),
                        c = ft.convert(i.type);
                    let h;
                    if (i.isData3DTexture) Q.setTexture3D(i, 0), h = _t.TEXTURE_3D;
                    else {
                        if (!i.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        Q.setTexture2DArray(i, 0), h = _t.TEXTURE_2D_ARRAY
                    }
                    _t.pixelStorei(_t.UNPACK_FLIP_Y_WEBGL, i.flipY), _t.pixelStorei(_t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), _t.pixelStorei(_t.UNPACK_ALIGNMENT, i.unpackAlignment);
                    const u = _t.getParameter(_t.UNPACK_ROW_LENGTH),
                        d = _t.getParameter(_t.UNPACK_IMAGE_HEIGHT),
                        p = _t.getParameter(_t.UNPACK_SKIP_PIXELS),
                        f = _t.getParameter(_t.UNPACK_SKIP_ROWS),
                        m = _t.getParameter(_t.UNPACK_SKIP_IMAGES),
                        g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                    _t.pixelStorei(_t.UNPACK_ROW_LENGTH, g.width), _t.pixelStorei(_t.UNPACK_IMAGE_HEIGHT, g.height), _t.pixelStorei(_t.UNPACK_SKIP_PIXELS, t.min.x), _t.pixelStorei(_t.UNPACK_SKIP_ROWS, t.min.y), _t.pixelStorei(_t.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? _t.texSubImage3D(h, r, e.x, e.y, e.z, a, s, o, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), _t.compressedTexSubImage3D(h, r, e.x, e.y, e.z, a, s, o, l, g.data)) : _t.texSubImage3D(h, r, e.x, e.y, e.z, a, s, o, l, c, g), _t.pixelStorei(_t.UNPACK_ROW_LENGTH, u), _t.pixelStorei(_t.UNPACK_IMAGE_HEIGHT, d), _t.pixelStorei(_t.UNPACK_SKIP_PIXELS, p), _t.pixelStorei(_t.UNPACK_SKIP_ROWS, f), _t.pixelStorei(_t.UNPACK_SKIP_IMAGES, m), 0 === r && i.generateMipmaps && _t.generateMipmap(h), K.unbindTexture()
                }, this.initTexture = function(t) {
                    t.isCubeTexture ? Q.setTextureCube(t, 0) : t.isData3DTexture ? Q.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? Q.setTexture2DArray(t, 0) : Q.setTexture2D(t, 0), K.unbindTexture()
                }, this.resetState = function() {
                    y = 0, M = 0, S = null, K.reset(), mt.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            get coordinateSystem() {
                return vl
            }
            get physicallyCorrectLights() {
                return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
            }
            set physicallyCorrectLights(t) {
                console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !t
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === dl ? ul : 3e3
            }
            set outputEncoding(t) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = t === ul ? dl : pl
            }
        }(class extends ef {}).prototype.isWebGL1Renderer = !0;
        class nf extends ih {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e
            }
        }
        class rf extends _h {
            constructor(t) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Sh(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
            }
        }
        const af = new nc,
            sf = new nc,
            of = new Uc,
            lf = new Lc,
            cf = new Tc;
        class hf extends ih {
            constructor(t = new zh, e = new rf) {
                super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [0];
                    for (let t = 1, i = e.count; t < i; t++) af.fromBufferAttribute(e, t - 1), sf.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += af.distanceTo(sf);
                    t.setAttribute("lineDistance", new Ph(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Line.threshold,
                    a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), cf.copy(n.boundingSphere), cf.applyMatrix4(i), cf.radius += r, !1 === t.ray.intersectsSphere(cf)) return;
                of.copy(i).invert(), lf.copy(t.ray).applyMatrix4(of);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = s * s,
                    l = new nc,
                    c = new nc,
                    h = new nc,
                    u = new nc,
                    d = this.isLineSegments ? 2 : 1,
                    p = n.index,
                    f = n.attributes.position;
                if (null !== p)
                    for (let n = Math.max(0, a.start), i = Math.min(p.count, a.start + a.count) - 1; n < i; n += d) {
                        const i = p.getX(n),
                            r = p.getX(n + 1);
                        if (l.fromBufferAttribute(f, i), c.fromBufferAttribute(f, r), lf.distanceSqToSegment(l, c, u, h) > o) continue;
                        u.applyMatrix4(this.matrixWorld);
                        const a = t.ray.origin.distanceTo(u);
                        a < t.near || a > t.far || e.push({
                            distance: a,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    } else
                        for (let n = Math.max(0, a.start), i = Math.min(f.count, a.start + a.count) - 1; n < i; n += d) {
                            if (l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1), lf.distanceSqToSegment(l, c, u, h) > o) continue;
                            u.applyMatrix4(this.matrixWorld);
                            const i = t.ray.origin.distanceTo(u);
                            i < t.near || i > t.far || e.push({
                                distance: i,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }
        const uf = new nc,
            df = new nc;
        class pf extends hf {
            constructor(t, e) {
                super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [];
                    for (let t = 0, i = e.count; t < i; t += 2) uf.fromBufferAttribute(e, t), df.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + uf.distanceTo(df);
                    t.setAttribute("lineDistance", new Ph(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        const ff = new nc,
            mf = new nc,
            gf = new nc,
            _f = new mh;
        class vf extends zh {
            constructor(t = null, e = 1) {
                if (super(), this.type = "EdgesGeometry", this.parameters = {
                        geometry: t,
                        thresholdAngle: e
                    }, null !== t) {
                    const n = 4,
                        i = Math.pow(10, n),
                        r = Math.cos(Sl * e),
                        a = t.getIndex(),
                        s = t.getAttribute("position"),
                        o = a ? a.count : s.count,
                        l = [0, 0, 0],
                        c = ["a", "b", "c"],
                        h = new Array(3),
                        u = {},
                        d = [];
                    for (let t = 0; t < o; t += 3) {
                        a ? (l[0] = a.getX(t), l[1] = a.getX(t + 1), l[2] = a.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2);
                        const {
                            a: e,
                            b: n,
                            c: o
                        } = _f;
                        if (e.fromBufferAttribute(s, l[0]), n.fromBufferAttribute(s, l[1]), o.fromBufferAttribute(s, l[2]), _f.getNormal(gf), h[0] = `${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`, h[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, h[2] = `${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
                            for (let t = 0; t < 3; t++) {
                                const e = (t + 1) % 3,
                                    n = h[t],
                                    i = h[e],
                                    a = _f[c[t]],
                                    s = _f[c[e]],
                                    o = `${n}_${i}`,
                                    p = `${i}_${n}`;
                                p in u && u[p] ? (gf.dot(u[p].normal) <= r && (d.push(a.x, a.y, a.z), d.push(s.x, s.y, s.z)), u[p] = null) : o in u || (u[o] = {
                                    index0: l[t],
                                    index1: l[e],
                                    normal: gf.clone()
                                })
                            }
                    }
                    for (const t in u)
                        if (u[t]) {
                            const {
                                index0: e,
                                index1: n
                            } = u[t];
                            ff.fromBufferAttribute(s, e), mf.fromBufferAttribute(s, n), d.push(ff.x, ff.y, ff.z), d.push(mf.x, mf.y, mf.z)
                        }
                    this.setAttribute("position", new Ph(d, 3))
                }
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
        }
        class xf extends _h {
            constructor(t) {
                super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ll(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
            }
        }

        function yf(t, e, n) {
            return Sf(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        }

        function Mf(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }

        function Sf(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        }
        class Tf {
            constructor(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    i = e[n],
                    r = e[n - 1];
                t: {
                    e: {
                        let a;n: {
                            i: if (!(t < i)) {
                                for (let a = n + 2;;) {
                                    if (void 0 === i) {
                                        if (t < r) break i;
                                        return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === a) break;
                                    if (r = i, i = e[++n], t < i) break e
                                }
                                a = e.length;
                                break n
                            }if (t >= r) break t; {
                                const s = e[1];
                                t < s && (n = 2, r = s);
                                for (let a = n - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === a) break;
                                    if (i = r, r = e[--n - 1], t >= r) break e
                                }
                                a = n, n = 0
                            }
                        }
                        for (; n < a;) {
                            const i = n + a >>> 1;
                            t < e[i] ? a = i : n = i + 1
                        }
                        if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (void 0 === i) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = t * i;
                for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class Ef extends Tf {
            constructor(t, e, n, i) {
                super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: 2400,
                    endingEnd: 2400
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2,
                    a = t + 1,
                    s = i[r],
                    o = i[a];
                if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, s = 2 * e - n;
                        break;
                    case 2402:
                        r = i.length - 2, s = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t, s = n
                }
                if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        a = t, o = 2 * n - e;
                        break;
                    case 2402:
                        a = 1, o = n + i[1] - i[0];
                        break;
                    default:
                        a = t - 1, o = e
                }
                const l = .5 * (n - e),
                    c = this.valueSize;
                this._weightPrev = l / (e - s), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = a * c
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    a = this.sampleValues,
                    s = this.valueSize,
                    o = t * s,
                    l = o - s,
                    c = this._offsetPrev,
                    h = this._offsetNext,
                    u = this._weightPrev,
                    d = this._weightNext,
                    p = (n - e) / (i - e),
                    f = p * p,
                    m = f * p,
                    g = -u * m + 2 * u * f - u * p,
                    _ = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1,
                    v = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                    x = d * m - d * f;
                for (let t = 0; t !== s; ++t) r[t] = g * a[c + t] + _ * a[l + t] + v * a[o + t] + x * a[h + t];
                return r
            }
        }
        class bf extends Tf {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    a = this.sampleValues,
                    s = this.valueSize,
                    o = t * s,
                    l = o - s,
                    c = (n - e) / (i - e),
                    h = 1 - c;
                for (let t = 0; t !== s; ++t) r[t] = a[l + t] * h + a[o + t] * c;
                return r
            }
        }
        class wf extends Tf {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class Af {
            constructor(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Mf(e, this.TimeBufferType), this.values = Mf(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: Mf(t.times, Array),
                        values: Mf(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new wf(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new bf(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new Ef(this.times, this.values, this.getValueSize(), t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case ll:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case cl:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case hl:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return ll;
                    case this.InterpolantFactoryMethodLinear:
                        return cl;
                    case this.InterpolantFactoryMethodSmooth:
                        return hl
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    a = i - 1;
                for (; r !== i && n[r] < t;) ++r;
                for (; - 1 !== a && n[a] > e;) --a;
                if (++a, 0 !== r || a !== i) {
                    r >= a && (a = Math.max(a, 1), r = a - 1);
                    const t = this.getValueSize();
                    this.times = yf(n, r, a), this.values = yf(this.values, r * t, a * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                let a = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                        break
                    }
                    if (null !== a && a > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, a), t = !1;
                        break
                    }
                    a = i
                }
                if (void 0 !== i && Sf(i))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = yf(this.times),
                    e = yf(this.values),
                    n = this.getValueSize(),
                    i = this.getInterpolation() === hl,
                    r = t.length - 1;
                let a = 1;
                for (let s = 1; s < r; ++s) {
                    let r = !1;
                    const o = t[s];
                    if (o !== t[s + 1] && (1 !== s || o !== t[0]))
                        if (i) r = !0;
                        else {
                            const t = s * n,
                                i = t - n,
                                a = t + n;
                            for (let s = 0; s !== n; ++s) {
                                const n = e[t + s];
                                if (n !== e[i + s] || n !== e[a + s]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (s !== a) {
                            t[a] = t[s];
                            const i = s * n,
                                r = a * n;
                            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                        }++a
                    }
                }
                if (r > 0) {
                    t[a] = t[r];
                    for (let t = r * n, i = a * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];
                    ++a
                }
                return a !== t.length ? (this.times = yf(t, 0, a), this.values = yf(e, 0, a * n)) : (this.times = t, this.values = e), this
            }
            clone() {
                const t = yf(this.times, 0),
                    e = yf(this.values, 0),
                    n = new(0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        Af.prototype.TimeBufferType = Float32Array, Af.prototype.ValueBufferType = Float32Array, Af.prototype.DefaultInterpolation = cl;
        class Rf extends Af {}
        Rf.prototype.ValueTypeName = "bool", Rf.prototype.ValueBufferType = Array, Rf.prototype.DefaultInterpolation = ll, Rf.prototype.InterpolantFactoryMethodLinear = void 0, Rf.prototype.InterpolantFactoryMethodSmooth = void 0, class extends Af {}.prototype.ValueTypeName = "color", class extends Af {}.prototype.ValueTypeName = "number";
        class Cf extends Tf {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    a = this.sampleValues,
                    s = this.valueSize,
                    o = (n - e) / (i - e);
                let l = t * s;
                for (let t = l + s; l !== t; l += 4) ec.slerpFlat(r, 0, a, l - s, a, l, o);
                return r
            }
        }
        class Pf extends Af {
            InterpolantFactoryMethodLinear(t) {
                return new Cf(this.times, this.values, this.getValueSize(), t)
            }
        }
        Pf.prototype.ValueTypeName = "quaternion", Pf.prototype.DefaultInterpolation = cl, Pf.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Lf extends Af {}
        Lf.prototype.ValueTypeName = "string", Lf.prototype.ValueBufferType = Array, Lf.prototype.DefaultInterpolation = ll, Lf.prototype.InterpolantFactoryMethodLinear = void 0, Lf.prototype.InterpolantFactoryMethodSmooth = void 0, class extends Af {}.prototype.ValueTypeName = "vector";
        class Uf {
            constructor(t = !0) {
                this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Df(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const e = Df();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }

        function Df() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        const If = "\\[\\]\\.:\\/",
            Nf = new RegExp("[" + If + "]", "g"),
            Of = "[^" + If + "]",
            Ff = "[^" + If.replace("\\.", "") + "]",
            zf = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Of) + /(WCOD+)?/.source.replace("WCOD", Ff) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Of) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Of) + "$"),
            Bf = ["material", "materials", "bones", "map"];
        class kf {
            constructor(t, e, n) {
                this.path = e, this.parsedPath = n || kf.parseTrackName(e), this.node = kf.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new kf.Composite(t, e, n) : new kf(t, e, n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(Nf, "")
            }
            static parseTrackName(t) {
                const e = zf.exec(t);
                if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1); - 1 !== Bf.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function(t) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (r.name === e || r.uuid === e) return r;
                                const a = n(r.children);
                                if (a) return a
                            }
                            return null
                        },
                        i = n(t.children);
                    if (i) return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = kf.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++)
                                if (t[e].name === i) {
                                    i = e;
                                    break
                                }
                            break;
                        case "map":
                            if ("map" in t) {
                                t = t.map;
                                break
                            }
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            t = t.material.map;
                            break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const a = t[i];
                if (void 0 === a) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let s = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
                } else void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        kf.Composite = class {
            constructor(t, e, n) {
                const i = n || kf.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }, kf.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, kf.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, kf.prototype.GetterByBindingType = [kf.prototype._getValue_direct, kf.prototype._getValue_array, kf.prototype._getValue_arrayElement, kf.prototype._getValue_toArray], kf.prototype.SetterByBindingTypeAndVersioning = [
            [kf.prototype._setValue_direct, kf.prototype._setValue_direct_setNeedsUpdate, kf.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [kf.prototype._setValue_array, kf.prototype._setValue_array_setNeedsUpdate, kf.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [kf.prototype._setValue_arrayElement, kf.prototype._setValue_arrayElement_setNeedsUpdate, kf.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [kf.prototype._setValue_fromArray, kf.prototype._setValue_fromArray_setNeedsUpdate, kf.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ], new Float32Array(1);
        class Hf extends pf {
            constructor(t = 1) {
                const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    n = new zh;
                n.setAttribute("position", new Ph(e, 3)), n.setAttribute("color", new Ph([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new rf({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "AxesHelper"
            }
            setColors(t, e, n) {
                const i = new Sh,
                    r = this.geometry.attributes.color.array;
                return i.set(t), i.toArray(r, 0), i.toArray(r, 3), i.set(e), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: Eo
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Eo);
        const Vf = {
            name: "CopyShader",
            uniforms: {
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"
        };
        class Gf {
            constructor() {
                this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }
            setSize() {}
            render() {
                console.error("THREE.Pass: .render() must be implemented in derived pass.")
            }
            dispose() {}
        }
        const Wf = new Ou(-1, 1, 1, -1, 0, 1),
            Xf = new zh;
        Xf.setAttribute("position", new Ph([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Xf.setAttribute("uv", new Ph([0, 2, 0, 0, 2, 0], 2));
        class qf {
            constructor(t) {
                this._mesh = new nu(Xf, t)
            }
            dispose() {
                this._mesh.geometry.dispose()
            }
            render(t) {
                t.render(this._mesh, Wf)
            }
            get material() {
                return this._mesh.material
            }
            set material(t) {
                this._mesh.material = t
            }
        }
        class jf extends Gf {
            constructor(t, e) {
                super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof cu ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = lu.clone(t.uniforms), this.material = new cu({
                    name: void 0 !== t.name ? t.name : "unspecified",
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })), this.fsQuad = new qf(this.material)
            }
            render(t, e, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
            }
            dispose() {
                this.material.dispose(), this.fsQuad.dispose()
            }
        }
        class Yf extends Gf {
            constructor(t, e) {
                super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            }
            render(t, e, n) {
                const i = t.getContext(),
                    r = t.state;
                let a, s;
                r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0), this.inverse ? (a = 0, s = 1) : (a = 1, s = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, a, 4294967295), r.buffers.stencil.setClear(s), r.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0)
            }
        }
        class Kf extends Gf {
            constructor() {
                super(), this.needsSwap = !1
            }
            render(t) {
                t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
            }
        }
        class Zf {
            constructor(t, e) {
                if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), void 0 === e) {
                    const n = t.getSize(new Ll);
                    this._width = n.width, this._height = n.height, (e = new $l(this._width * this._pixelRatio, this._height * this._pixelRatio, {
                        type: Qo
                    })).texture.name = "EffectComposer.rt1"
                } else this._width = e.width, this._height = e.height;
                this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new jf(Vf), this.copyPass.material.blending = 0, this.clock = new Uf
            }
            swapBuffers() {
                const t = this.readBuffer;
                this.readBuffer = this.writeBuffer, this.writeBuffer = t
            }
            addPass(t) {
                this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            insertPass(t, e) {
                this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            removePass(t) {
                const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1)
            }
            isLastEnabledPass(t) {
                for (let e = t + 1; e < this.passes.length; e++)
                    if (this.passes[e].enabled) return !1;
                return !0
            }
            render(t) {
                void 0 === t && (t = this.clock.getDelta());
                const e = this.renderer.getRenderTarget();
                let n = !1;
                for (let e = 0, i = this.passes.length; e < i; e++) {
                    const i = this.passes[e];
                    if (!1 !== i.enabled) {
                        if (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), i.needsSwap) {
                            if (n) {
                                const e = this.renderer.getContext(),
                                    n = this.renderer.state.buffers.stencil;
                                n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295)
                            }
                            this.swapBuffers()
                        }
                        void 0 !== Yf && (i instanceof Yf ? n = !0 : i instanceof Kf && (n = !1))
                    }
                }
                this.renderer.setRenderTarget(e)
            }
            reset(t) {
                if (void 0 === t) {
                    const e = this.renderer.getSize(new Ll);
                    this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                }
                this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
            }
            setSize(t, e) {
                this._width = t, this._height = e;
                const n = this._width * this._pixelRatio,
                    i = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i)
            }
            setPixelRatio(t) {
                this._pixelRatio = t, this.setSize(this._width, this._height)
            }
            dispose() {
                this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose()
            }
        }
        class Jf extends Gf {
            constructor(t, e, n, i = {}) {
                super(), this.pixelSize = t, this.resolution = new Ll, this.renderResolution = new Ll, this.pixelatedMaterial = this.createPixelatedMaterial(), this.normalMaterial = new xf, this.fsQuad = new qf(this.pixelatedMaterial), this.scene = e, this.camera = n, this.normalEdgeStrength = i.normalEdgeStrength || .3, this.depthEdgeStrength = i.depthEdgeStrength || .4, this.beautyRenderTarget = new $l, this.beautyRenderTarget.texture.minFilter = Wo, this.beautyRenderTarget.texture.magFilter = Wo, this.beautyRenderTarget.texture.type = Qo, this.beautyRenderTarget.depthTexture = new Zp, this.normalRenderTarget = new $l, this.normalRenderTarget.texture.minFilter = Wo, this.normalRenderTarget.texture.magFilter = Wo, this.normalRenderTarget.texture.type = Qo
            }
            dispose() {
                this.beautyRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.pixelatedMaterial.dispose(), this.normalMaterial.dispose(), this.fsQuad.dispose()
            }
            setSize(t, e) {
                this.resolution.set(t, e), this.renderResolution.set(t / this.pixelSize | 0, e / this.pixelSize | 0);
                const {
                    x: n,
                    y: i
                } = this.renderResolution;
                this.beautyRenderTarget.setSize(n, i), this.normalRenderTarget.setSize(n, i), this.fsQuad.material.uniforms.resolution.value.set(n, i, 1 / n, 1 / i)
            }
            setPixelSize(t) {
                this.pixelSize = t, this.setSize(this.resolution.x, this.resolution.y)
            }
            render(t, e) {
                const n = this.fsQuad.material.uniforms;
                n.normalEdgeStrength.value = this.normalEdgeStrength, n.depthEdgeStrength.value = this.depthEdgeStrength, t.setRenderTarget(this.beautyRenderTarget), t.render(this.scene, this.camera);
                const i = this.scene.overrideMaterial;
                t.setRenderTarget(this.normalRenderTarget), this.scene.overrideMaterial = this.normalMaterial, t.render(this.scene, this.camera), this.scene.overrideMaterial = i, n.tDiffuse.value = this.beautyRenderTarget.texture, n.tDepth.value = this.beautyRenderTarget.depthTexture, n.tNormal.value = this.normalRenderTarget.texture, this.renderToScreen ? t.setRenderTarget(null) : (t.setRenderTarget(e), this.clear && t.clear()), this.fsQuad.render(t)
            }
            createPixelatedMaterial() {
                return new cu({
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        tDepth: {
                            value: null
                        },
                        tNormal: {
                            value: null
                        },
                        resolution: {
                            value: new Ql(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)
                        },
                        normalEdgeStrength: {
                            value: 0
                        },
                        depthEdgeStrength: {
                            value: 0
                        }
                    },
                    vertexShader: "\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0)\n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0;\n\t\t\t\t\tif (normalEdgeStrength > 0.0)\n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t"
                })
            }
        }
        const Qf = {
            shaderID: "luminosityHighPass",
            uniforms: {
                tDiffuse: {
                    value: null
                },
                luminosityThreshold: {
                    value: 1
                },
                smoothWidth: {
                    value: 1
                },
                defaultColor: {
                    value: new Sh(0)
                },
                defaultOpacity: {
                    value: 0
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"
        };
        class $f extends Gf {
            constructor(t, e, n, i) {
                super(), this.strength = void 0 !== e ? e : 1, this.radius = n, this.threshold = i, this.resolution = void 0 !== t ? new Ll(t.x, t.y) : new Ll(256, 256), this.clearColor = new Sh(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
                let r = Math.round(this.resolution.x / 2),
                    a = Math.round(this.resolution.y / 2);
                this.renderTargetBright = new $l(r, a, {
                    type: Qo
                }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
                for (let t = 0; t < this.nMips; t++) {
                    const e = new $l(r, a, {
                        type: Qo
                    });
                    e.texture.name = "UnrealBloomPass.h" + t, e.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(e);
                    const n = new $l(r, a, {
                        type: Qo
                    });
                    n.texture.name = "UnrealBloomPass.v" + t, n.texture.generateMipmaps = !1, this.renderTargetsVertical.push(n), r = Math.round(r / 2), a = Math.round(a / 2)
                }
                const s = Qf;
                this.highPassUniforms = lu.clone(s.uniforms), this.highPassUniforms.luminosityThreshold.value = i, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new cu({
                    uniforms: this.highPassUniforms,
                    vertexShader: s.vertexShader,
                    fragmentShader: s.fragmentShader
                }), this.separableBlurMaterials = [];
                const o = [3, 5, 7, 9, 11];
                r = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
                for (let t = 0; t < this.nMips; t++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[t])), this.separableBlurMaterials[t].uniforms.texSize.value = new Ll(r, a), r = Math.round(r / 2), a = Math.round(a / 2);
                this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new nc(1, 1, 1), new nc(1, 1, 1), new nc(1, 1, 1), new nc(1, 1, 1), new nc(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
                const l = Vf;
                this.copyUniforms = lu.clone(l.uniforms), this.blendMaterial = new cu({
                    uniforms: this.copyUniforms,
                    vertexShader: l.vertexShader,
                    fragmentShader: l.fragmentShader,
                    blending: 2,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Sh, this.oldClearAlpha = 1, this.basic = new Eh, this.fsQuad = new qf(null)
            }
            dispose() {
                for (let t = 0; t < this.renderTargetsHorizontal.length; t++) this.renderTargetsHorizontal[t].dispose();
                for (let t = 0; t < this.renderTargetsVertical.length; t++) this.renderTargetsVertical[t].dispose();
                this.renderTargetBright.dispose();
                for (let t = 0; t < this.separableBlurMaterials.length; t++) this.separableBlurMaterials[t].dispose();
                this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose()
            }
            setSize(t, e) {
                let n = Math.round(t / 2),
                    i = Math.round(e / 2);
                this.renderTargetBright.setSize(n, i);
                for (let t = 0; t < this.nMips; t++) this.renderTargetsHorizontal[t].setSize(n, i), this.renderTargetsVertical[t].setSize(n, i), this.separableBlurMaterials[t].uniforms.texSize.value = new Ll(n, i), n = Math.round(n / 2), i = Math.round(i / 2)
            }
            render(t, e, n, i, r) {
                t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha();
                const a = t.autoClear;
                t.autoClear = !1, t.setClearColor(this.clearColor, 0), r && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t);
                let s = this.renderTargetBright;
                for (let e = 0; e < this.nMips; e++) this.fsQuad.material = this.separableBlurMaterials[e], this.separableBlurMaterials[e].uniforms.colorTexture.value = s.texture, this.separableBlurMaterials[e].uniforms.direction.value = $f.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[e]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture, this.separableBlurMaterials[e].uniforms.direction.value = $f.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[e]), t.clear(), this.fsQuad.render(t), s = this.renderTargetsVertical[e];
                this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(n), this.fsQuad.render(t)), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = a
            }
            getSeperableBlurMaterial(t) {
                return new cu({
                    defines: {
                        KERNEL_RADIUS: t,
                        SIGMA: t
                    },
                    uniforms: {
                        colorTexture: {
                            value: null
                        },
                        texSize: {
                            value: new Ll(.5, .5)
                        },
                        direction: {
                            value: new Ll(.5, .5)
                        }
                    },
                    vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                    fragmentShader: "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
                })
            }
            getCompositeMaterial(t) {
                return new cu({
                    defines: {
                        NUM_MIPS: t
                    },
                    uniforms: {
                        blurTexture1: {
                            value: null
                        },
                        blurTexture2: {
                            value: null
                        },
                        blurTexture3: {
                            value: null
                        },
                        blurTexture4: {
                            value: null
                        },
                        blurTexture5: {
                            value: null
                        },
                        bloomStrength: {
                            value: 1
                        },
                        bloomFactors: {
                            value: null
                        },
                        bloomTintColors: {
                            value: null
                        },
                        bloomRadius: {
                            value: 0
                        }
                    },
                    vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                    fragmentShader: "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"
                })
            }
        }
        $f.BlurDirectionX = new Ll(1, 0), $f.BlurDirectionY = new Ll(0, 1);
        class tm {
            constructor(t) {
                this.text = t
            }
            evaluate() {
                return Number(this.text)
            }
            toString() {
                return this.text
            }
        }
        const em = {
            "**": (t, e) => Math.pow(t, e),
            "*": (t, e) => t * e,
            "/": (t, e) => t / e,
            "%": (t, e) => t % e,
            "+": (t, e) => t + e,
            "-": (t, e) => t - e,
            "<<": (t, e) => t << e,
            ">>": (t, e) => t >> e,
            ">>>": (t, e) => t >>> e,
            "&": (t, e) => t & e,
            "^": (t, e) => t ^ e,
            "|": (t, e) => t | e
        };
        class nm {
            constructor(t, e, n) {
                this.left = e, this.operator = t, this.right = n
            }
            evaluate() {
                const t = em[this.operator];
                if (!t) throw new Error(`unexpected binary operator: '${this.operator}`);
                return t(this.left.evaluate(), this.right.evaluate())
            }
            toString() {
                return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
            }
        }
        const im = {
            "+": t => t,
            "-": t => -t,
            "~": t => ~t
        };
        class rm {
            constructor(t, e) {
                this.operator = t, this.expression = e
            }
            evaluate() {
                const t = im[this.operator];
                if (!t) throw new Error(`unexpected unary operator: '${this.operator}`);
                return t(this.expression.evaluate())
            }
            toString() {
                return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
            }
        }

        function am(t) {
            return (e, n) => {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i](e, n);
                    if ("" !== r) return r
                }
                return ""
            }
        }

        function sm(t, e) {
            var n;
            const i = t.substr(e).match(/^\s+/);
            return null !== (n = i && i[0]) && void 0 !== n ? n : ""
        }

        function om(t, e) {
            var n;
            const i = t.substr(e).match(/^[0-9]+/);
            return null !== (n = i && i[0]) && void 0 !== n ? n : ""
        }

        function lm(t, e) {
            const n = t.substr(e, 1);
            if (e += 1, "e" !== n.toLowerCase()) return "";
            const i = function(t, e) {
                const n = om(t, e);
                if ("" !== n) return n;
                const i = t.substr(e, 1);
                if ("-" !== i && "+" !== i) return "";
                const r = om(t, e += 1);
                return "" === r ? "" : i + r
            }(t, e);
            return "" === i ? "" : n + i
        }

        function cm(t, e) {
            const n = t.substr(e, 1);
            if ("0" === n) return n;
            const i = function(t, e) {
                const n = t.substr(e, 1);
                return n.match(/^[1-9]$/) ? n : ""
            }(t, e);
            return e += i.length, "" === i ? "" : i + om(t, e)
        }
        const hm = am([function(t, e) {
                const n = cm(t, e);
                if (e += n.length, "" === n) return "";
                const i = t.substr(e, 1);
                if (e += i.length, "." !== i) return "";
                const r = om(t, e);
                return n + i + r + lm(t, e += r.length)
            }, function(t, e) {
                const n = t.substr(e, 1);
                if (e += n.length, "." !== n) return "";
                const i = om(t, e);
                return e += i.length, "" === i ? "" : n + i + lm(t, e)
            }, function(t, e) {
                const n = cm(t, e);
                return e += n.length, "" === n ? "" : n + lm(t, e)
            }]),
            um = am([function(t, e) {
                const n = t.substr(e, 2);
                if (e += n.length, "0b" !== n.toLowerCase()) return "";
                const i = function(t, e) {
                    var n;
                    const i = t.substr(e).match(/^[01]+/);
                    return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                }(t, e);
                return "" === i ? "" : n + i
            }, function(t, e) {
                const n = t.substr(e, 2);
                if (e += n.length, "0o" !== n.toLowerCase()) return "";
                const i = function(t, e) {
                    var n;
                    const i = t.substr(e).match(/^[0-7]+/);
                    return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                }(t, e);
                return "" === i ? "" : n + i
            }, function(t, e) {
                const n = t.substr(e, 2);
                if (e += n.length, "0x" !== n.toLowerCase()) return "";
                const i = function(t, e) {
                    var n;
                    const i = t.substr(e).match(/^[0-9a-f]+/i);
                    return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                }(t, e);
                return "" === i ? "" : n + i
            }]),
            dm = am([um, hm]);

        function pm(t, e, n) {
            n += sm(e, n).length;
            const i = t.filter((t => e.startsWith(t, n)))[0];
            return i ? (n += i.length, {
                cursor: n += sm(e, n).length,
                operator: i
            }) : null
        }
        const fm = [
            ["**"],
            ["*", "/", "%"],
            ["+", "-"],
            ["<<", ">>>", ">>"],
            ["&"],
            ["^"],
            ["|"]
        ].reduce(((t, e) => function(t, e) {
            return (n, i) => {
                const r = t(n, i);
                if (!r) return null;
                i = r.cursor;
                let a = r.evaluable;
                for (;;) {
                    const r = pm(e, n, i);
                    if (!r) break;
                    i = r.cursor;
                    const s = t(n, i);
                    if (!s) return null;
                    i = s.cursor, a = new nm(r.operator, a, s.evaluable)
                }
                return a ? {
                    cursor: i,
                    evaluable: a
                } : null
            }
        }(t, e)), (function t(e, n) {
            const i = function(t, e) {
                var n;
                return null !== (n = function(t, e) {
                    const n = dm(t, e);
                    return e += n.length, "" === n ? null : {
                        evaluable: new tm(n),
                        cursor: e
                    }
                }(t, e)) && void 0 !== n ? n : function(t, e) {
                    const n = t.substr(e, 1);
                    if (e += n.length, "(" !== n) return null;
                    const i = mm(t, e);
                    if (!i) return null;
                    e = i.cursor, e += sm(t, e).length;
                    const r = t.substr(e, 1);
                    return e += r.length, ")" !== r ? null : {
                        evaluable: i.evaluable,
                        cursor: e
                    }
                }(t, e)
            }(e, n);
            if (i) return i;
            const r = e.substr(n, 1);
            if (n += r.length, "+" !== r && "-" !== r && "~" !== r) return null;
            const a = t(e, n);
            return a ? {
                cursor: n = a.cursor,
                evaluable: new rm(r, a.evaluable)
            } : null
        }));

        function mm(t, e) {
            return e += sm(t, e).length, fm(t, e)
        }

        function gm(t) {
            return e => n => {
                if (!e && void 0 === n) return {
                    succeeded: !1,
                    value: void 0
                };
                if (e && void 0 === n) return {
                    succeeded: !0,
                    value: void 0
                };
                const i = t(n);
                return void 0 !== i ? {
                    succeeded: !0,
                    value: i
                } : {
                    succeeded: !1,
                    value: void 0
                }
            }
        }

        function _m(t) {
            return {
                custom: e => gm(e)(t),
                boolean: gm((t => "boolean" == typeof t ? t : void 0))(t),
                number: gm((t => "number" == typeof t ? t : void 0))(t),
                string: gm((t => "string" == typeof t ? t : void 0))(t),
                function: gm((t => "function" == typeof t ? t : void 0))(t),
                constant: e => gm((t => t === e ? e : void 0))(t),
                raw: gm((t => t))(t),
                object: e => gm((t => {
                    var n;
                    if (null !== (n = t) && "object" == typeof n) return function(t, e) {
                        return Object.keys(e).reduce(((n, i) => {
                            if (void 0 === n) return;
                            const r = (0, e[i])(t[i]);
                            return r.succeeded ? Object.assign(Object.assign({}, n), {
                                [i]: r.value
                            }) : void 0
                        }), {})
                    }(t, e)
                }))(t),
                array: e => gm((t => {
                    var n;
                    if (Array.isArray(t)) return n = e, t.reduce(((t, e) => {
                        if (void 0 === t) return;
                        const i = n(e);
                        return i.succeeded && void 0 !== i.value ? [...t, i.value] : void 0
                    }), [])
                }))(t)
            }
        }
        _m(!0), _m(!1);
        const vm = "tp";

        function xm(t) {
            return (e, n) => [vm, "-", t, "v", e ? `_${e}` : "", n ? `-${n}` : ""].join("")
        }
        xm("lbl");
        xm("");
        xm("btn");
        class ym {
            constructor(t) {
                const [e, n] = t.split("-"), i = e.split(".");
                this.major = parseInt(i[0], 10), this.minor = parseInt(i[1], 10), this.patch = parseInt(i[2], 10), this.prerelease = null != n ? n : null
            }
            toString() {
                const t = [this.major, this.minor, this.patch].join(".");
                return null !== this.prerelease ? [t, this.prerelease].join("-") : t
            }
        }
        new ym("2.0.1");
        new ym("4.0.1"), cr.registerPlugin(uo);
        class Mm {
            constructor(n) {
                this.element = n, this.scroll = {
                    velocity: 0,
                    direction: -1
                }, this.PARAMS = {
                    pixelSize: 2,
                    bloomStrength: .4,
                    bloomRadius: .1,
                    cameraSpeed: .02,
                    cameraY: 3.25,
                    cameraFov: 100,
                    cameraRotation: 0,
                    cameraLensStrength: 1.7,
                    mouseXOffset: .5,
                    mouseYOffset: 1
                }, this.noise = function(n = Math.random) {
                    const i = l(n),
                        s = new Float64Array(i).map((t => a[t % 12 * 2])),
                        o = new Float64Array(i).map((t => a[t % 12 * 2 + 1]));
                    return function(n, a) {
                        let l = 0,
                            c = 0,
                            h = 0;
                        const u = (n + a) * t,
                            d = r(n + u),
                            p = r(a + u),
                            f = (d + p) * e,
                            m = n - (d - f),
                            g = a - (p - f);
                        let _, v;
                        m > g ? (_ = 1, v = 0) : (_ = 0, v = 1);
                        const x = m - _ + e,
                            y = g - v + e,
                            M = m - 1 + 2 * e,
                            S = g - 1 + 2 * e,
                            T = 255 & d,
                            E = 255 & p;
                        let b = .5 - m * m - g * g;
                        if (b >= 0) {
                            const t = T + i[E];
                            b *= b, l = b * b * (s[t] * m + o[t] * g)
                        }
                        let w = .5 - x * x - y * y;
                        if (w >= 0) {
                            const t = T + _ + i[E + v];
                            w *= w, c = w * w * (s[t] * x + o[t] * y)
                        }
                        let A = .5 - M * M - S * S;
                        if (A >= 0) {
                            const t = T + 1 + i[E + 1];
                            A *= A, h = A * A * (s[t] * M + o[t] * S)
                        }
                        return 70 * (l + c + h)
                    }
                }(), this.rows = [], this.speed = .01, this.noiseZ = 0, this.cubeSize = 1, this.cubeHeight = 3.5, this.lineSize = .01, this.rowSize = 31, this.depthSize = 15, this.freqX = 5, this.freqZ = .5, this.cameraAnimation = {
                    rotation: 50,
                    y: 2
                }, this.cameraMouse = {
                    x: 0,
                    y: 0
                }, this.scene = new nf, this.viewAspectRatio = 1, this.camera = new uu(this.PARAMS.cameraFov, this.element.clientWidth / this.element.clientHeight, .1, 2e3), this.camera.target = new nc(0, 0, 0), this.camera.position.z = 10, this.camera.position.y = this.PARAMS.cameraY + this.cameraAnimation.y, this.renderer = new ef({
                    alpha: !1,
                    preserveDrawingBuffer: !0
                }), this.renderer.setSize(this.element.clientWidth, this.element.clientHeight), this.renderer.setPixelRatio(window.devicePixelRatio), this.initEffectComposer(), this.renderTarget = new $l(this.element.clientWidth, this.element.clientHeight, {
                    type: Qo
                }), this.element.appendChild(this.renderer.domElement), this.initGenerativeGrid(), this.handleRaf = () => {
                    this.animationFrame()
                }, this.removeRaf = () => {}, this.playIntro = !1, To.cityCallback = () => {
                    this.initAnimation()
                }, addEventListener("resize", (() => {
                    this.resize()
                })), this.resize(), this.element.addEventListener("mousemove", (t => {
                    this.mouseMove(t)
                }))
            }
            initPane() {
                const t = new Dy({
                    title: "Parameters"
                });
                t.addBinding(this.PARAMS, "cameraSpeed", {
                    min: 0,
                    max: .05,
                    step: .001
                }), t.addBinding(this.PARAMS, "cameraY", {
                    min: 0,
                    max: 5,
                    step: .05
                }).on("change", (t => {
                    this.camera.position.y = t.value
                })), t.addBinding(this.PARAMS, "cameraRotation", {
                    min: -5,
                    max: 5,
                    step: .05
                }), t.addBinding(this.PARAMS, "cameraFov", {
                    min: 20,
                    max: 200,
                    step: 1
                }).on("change", (t => {
                    this.camera.fov = this.PARAMS.cameraFov, this.camera.updateProjectionMatrix()
                })), t.addBinding(this.PARAMS, "cameraLensStrength", {
                    min: 0,
                    max: 2,
                    step: .01
                }).on("change", (t => {
                    this.lensEffect.uniforms.strength.value = t.value
                })), t.addBinding(this.PARAMS, "pixelSize", {
                    min: 1,
                    max: 100,
                    step: 1
                }).on("change", (t => {
                    this.pixelPass.setPixelSize(t.value * window.devicePixelRatio)
                })), t.addBinding(this.PARAMS, "bloomStrength", {
                    min: 0,
                    max: 20,
                    step: .1
                }).on("change", (t => {
                    this.bloomPass.strength = t.value
                })), t.addBinding(this.PARAMS, "bloomRadius", {
                    min: 0,
                    max: 20,
                    step: .1
                }).on("change", (t => {
                    this.bloomPass.radius = t.value
                }))
            }
            initDebugGeometry() {
                const t = new Hf(5);
                this.scene.add(t);
                let e = new bu(5, 5, 10, 10),
                    n = new Eh({
                        color: 16777215,
                        side: 2,
                        wireframe: !0
                    });
                this.plane = new nu(e, n), this.scene.add(this.plane)
            }
            initAnimation() {
                this.playIntro = !0, this.removeRaf = T.add(this.handleRaf, 0), cr.to(this.cameraAnimation, {
                    y: 0,
                    duration: 5,
                    ease: "expo.out"
                }), cr.to(this.cameraAnimation, {
                    rotation: 3.5,
                    duration: 5,
                    ease: "expo.out"
                })
            }
            initGenerativeGrid() {
                for (let t = 0; t < 2 * this.depthSize; t++) this.generateRow(-t)
            }
            initEffectComposer() {
                this.composer = new Zf(this.renderer), this.pixelPass = new Jf(this.PARAMS.pixelSize * window.devicePixelRatio, this.scene, this.camera, {
                    normalEdgeStrength: 0,
                    depthEdgeStrength: 0
                }), this.composer.addPass(this.pixelPass), this.bloomPass = new $f(new Ll(window.innerWidth, window.innerHeight)), this.bloomPass.threshold = 0, this.bloomPass.strength = this.PARAMS.bloomStrength, this.bloomPass.radius = this.PARAMS.bloomRadius, this.composer.addPass(this.bloomPass), this.lensEffect = new jf(this.getDistortionShaderDefinition()), this.composer.addPass(this.lensEffect), this.lensEffect.renderToScreen = !0, this.updateLensDistortion()
            }
            generateRow(t) {
                const e = new jp;
                e.position.set(0 + this.cubeSize / 2 - this.rowSize / 2, 0, t + this.depthSize / 2);
                for (let n = 0; n < this.rowSize; n++) this.generateCube(e, n, -t);
                this.noiseZ += 1, this.rows.push(e), this.scene.add(e)
            }
            generateCube(t, e, n) {
                let i = (this.noise(e * this.freqX, this.noiseZ * this.freqZ) + 1) / 2 * this.cubeHeight;
                ((e + 1) % 4 == 0 || (n + 1) % 4 == 0) && (i = 0);
                const r = new ru(1, i, 1),
                    a = new Eh({
                        color: 0,
                        wireframe: !1
                    }),
                    s = new nu(r, a);
                s.position.set(e, i / 2, 0), s.scale.set(.998, .998, .998), t.add(s);
                const o = new vf(r),
                    l = new rf({
                        color: 16777215,
                        linewidth: 10
                    }),
                    c = new pf(o, l);
                c.position.set(e, i / 2, 0), t.add(c)
            }
            updateRow(t, e) {
                t.remove(...t.children);
                for (let n = 0; n < this.rowSize; n++) this.generateCube(t, n, -e);
                this.noiseZ += 1
            }
            animateGrid() {
                this.rows.map(((t, e) => {
                    t.position.z += this.PARAMS.cameraSpeed, t.position.z > this.depthSize && (t.position.z = -this.depthSize, this.updateRow(t, e))
                }))
            }
            initScrollInView() {
                uo.create({
                    trigger: this.element,
                    start: "top bottom",
                    end: "bottom top",
                    onToggle: t => {
                        t.isActive && this.playIntro ? this.removeRaf = T.add(this.handleRaf, 0) : this.removeRaf()
                    }
                })
            }
            updateScroll(t) {}
            animationFrame() {
                this.camera.position.y = this.PARAMS.cameraY + this.cameraAnimation.y - this.cameraMouse.y, this.camera.position.x = this.cameraMouse.x, this.camera.lookAt(0, this.cameraAnimation.rotation + this.PARAMS.cameraRotation, 0), this.animateGrid(), this.composer.render()
            }
            mouseMove(t) {
                cr.to(this.cameraMouse, {
                    x: (t.clientX - window.innerWidth / 2) / (window.innerWidth / 2) * this.PARAMS.mouseXOffset,
                    y: (t.clientY - window.innerHeight / 2) / (window.innerHeight / 2) * this.PARAMS.mouseYOffset,
                    duration: 2,
                    ease: "expo.out"
                })
            }
            resize() {
                this.camera.aspect = this.element.clientWidth / this.element.clientHeight, this.pixelPass.setPixelSize(this.PARAMS.pixelSize * window.devicePixelRatio), this.renderer.setSize(this.element.clientWidth, this.element.clientHeight), this.composer.setSize(this.element.clientWidth, this.element.clientHeight), this.updateLensDistortion(), this.camera.updateProjectionMatrix()
            }
            updateLensDistortion() {
                let t = this.PARAMS.cameraLensStrength;
                t = this.camera.aspect > this.viewAspectRatio ? this.PARAMS.cameraLensStrength : .5 * this.PARAMS.cameraLensStrength;
                const e = Math.tan(function(t) {
                    return t * Sl
                }(this.PARAMS.cameraFov) / 2) / this.camera.aspect;
                this.lensEffect.uniforms.strength.value = t, this.lensEffect.uniforms.height.value = e, this.lensEffect.uniforms.aspectRatio.value = this.camera.aspect, this.lensEffect.uniforms.cylindricalRatio.value = 2
            }
            getDistortionShaderDefinition() {
                return {
                    uniforms: {
                        tDiffuse: {
                            type: "t",
                            value: null
                        },
                        strength: {
                            type: "f",
                            value: 0
                        },
                        height: {
                            type: "f",
                            value: 1
                        },
                        aspectRatio: {
                            type: "f",
                            value: 1
                        },
                        cylindricalRatio: {
                            type: "f",
                            value: 1
                        }
                    },
                    vertexShader: ["uniform float strength;", "uniform float height;", "uniform float aspectRatio;", "uniform float cylindricalRatio;", "varying vec3 vUV;", "varying vec2 vUVDot;", "void main() {", "gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));", "float scaledHeight = strength * height;", "float cylAspectRatio = aspectRatio * cylindricalRatio;", "float aspectDiagSq = aspectRatio * aspectRatio + 1.0;", "float diagSq = scaledHeight * scaledHeight * aspectDiagSq;", "vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));", "float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;", "float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);", "vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;", "vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);", "vUV.xy += uv;", "}"].join("\n"),
                    fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec3 vUV;", "varying vec2 vUVDot;", "void main() {", "vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;", "gl_FragColor = texture2DProj(tDiffuse, uv);", "}"].join("\n")
                }
            }
        }
        new class {
            constructor() {
                console.log("mail: akirahack@tuta.io"), console.log("development: akira"), this.initPreloader(), this.initScroll(), this.initCity(), this.initIntro(), this.initConsent(), this.initGoogleTranslate()
            }
            initPreloader() {
                this.preloaderElement = document.querySelector("[data-preloader]"), To.init(this.preloaderElement)
            }
            initScroll() {
                new So
            }
            initCity() {
                this.cityElement = document.querySelector("[data-city]"), this.cityElement && (this.city = new Mm(this.cityElement))
            }
            initIntro() {
                new Iy
            }
            initConsent() {
                new Mo
            }
            initGoogleTranslate() {
                new Ny
            }
        }
    })()
})();